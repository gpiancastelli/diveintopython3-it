<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Uso avanzato degli iteratori - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
body{counter-reset:h1 7}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#advanced-iterators>Dive Into Python 3</a> <span>&#8227;</span>
<p id=level>Livello di difficoltà: <span title=advanced>&#x2666;&#x2666;&#x2666;&#x2666;&#x2662;</span>
<h1>Uso avanzato degli iteratori</h1>
<blockquote class=q>
<p><span>&#x275D;</span> Great fleas have little fleas upon their backs to bite &#8217;em,<br>And little fleas have lesser fleas, and so ad infinitum. <span>&#x275E;</span><br>&mdash; Augustus De Morgan
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>H<code>AWAII + IDAHO + IOWA + OHIO == STATES</code>. Oppure, per dirlo in un altro modo, <code>510199 + 98153 + 9301 + 3593 == 621246</code>. &Egrave; un fenomeno di glossolalia? No, è solamente un rompicapo.

<p>Lasciate che vi mostri come scomporlo.

<pre><code>HAWAII + IDAHO + IOWA + OHIO == STATES
510199 + 98153 + 9301 + 3593 == 621246

H = 5
A = 1
W = 0
I = 9
D = 8
O = 3
S = 6
T = 2
E = 4</code></pre>

<p>Rompicapo come questi sono chiamati <i>criptarismi</i> o più precisamente criptarismi <i>alfametici</i>. Le lettere formano parole vere, ma se sostituite ogni lettera con una cifra da <code>0</code> a <code>9</code>, il rompicapo &#8220;forma&#8221; anche una equazione aritmetica. Il trucco è scoprire quali lettere corrispondono a quali cifre. Tutte le occorrenze di ogni lettera devono corrispondere alla stessa cifra, nesuna cifra può essere ripetuta, e nessuna &#8220;parola&#8221; può cominciare con la cifra <code>0</code>.

<p>Il rompicapo alfametico più conosciuto è <code>SEND + MORE = MONEY</code>.

<p>In questo capitolo, analizzeremo un incredibile programma Python originariamente scritto da Raymond Hettinger. Questo programma risolve rompicapi di alfametica <em>in sole 14 righe di codice</em>.

<p class=d>[<a href=esempi/alphametics.py>scarica <code>alphametics.py</code></a>]
<pre><code>import re
import itertools

def solve(puzzle):
    words = re.findall('[A-Z]+', puzzle.upper())
    unique_characters = {c for c in ''.join(words)}
    assert len(unique_characters) <= 10
    first_letters = {word[0] for word in words}
    n = len(first_letters)
    sorted_characters = ''.join(first_letters) + \
        ''.join(unique_characters - first_letters)
    characters = tuple(ord(c) for c in sorted_characters)
    digits = tuple(ord(c) for c in '0123456789')
    zero = digits[0]
    for guess in itertools.permutations(digits, len(characters)):
        if zero not in guess[:n]:
            equation = puzzle.translate(dict(zip(characters, guess)))
            if eval(equation):
                return equation

if __name__ == '__main__':
    import sys
    for puzzle in sys.argv[1:]:
        print(puzzle)
        solution = solve(puzzle)
        if solution:
            print(solution)</code></pre>

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 alphametics.py "HAWAII + IDAHO + IOWA + OHIO = STATES"</kbd>
<samp>HAWAII + IDAHO + IOWA + OHIO = STATES
510199 + 98153 + 9301 + 3593 == 621246</samp>
<samp class=p>you@localhost:~$ </samp><kbd>python3 alphametics.py "I + LOVE + YOU == DORA"</kbd>
<samp>I + LOVE + YOU == DORA
1 + 2784 + 975 == 3760</samp>
<samp class=p>you@localhost:~$ </samp><kbd>python3 alphametics.py "SEND + MORE == MONEY"</kbd>
<samp>SEND + MORE == MONEY
9567 + 1085 == 10652</samp></pre>

<h2 id=re-findall>Trovare tutte le occorrenze di un pattern</h2>

<p>La prima cosa che fa questo risolutore di alfametica è trovare tutte le lettere (A&ndash;Z) nel rompicapo.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import re</kbd>
<a><samp class=p>>>> </samp><kbd>re.findall('[0-9]+', '16 2-by-4s in rows of 8')</kbd>  <span>&#x2460;</span></a>
<samp>['16', '2', '4', '8']</samp>
<a><samp class=p>>>> </samp><kbd>re.findall('[A-Z]+', 'SEND + MORE == MONEY')</kbd>     <span>&#x2461;</span></a>
<samp>['SEND', 'MORE', 'MONEY']</samp></pre>
<ol>
<li>Il modulo <code>re</code> è l'implementazione Python delle <a href=espressioni-regolari.html>espressioni regolari</a>. Include un'elegante funzione chiamata <code>findall()</code> che accetta un pattern di espressione regolare e una stringa, e trova tutte le occorrenze del pattern all'interno della stringa. In questo caso, il pattern corrisponde a sequenze di numeri. La funzione <code>findall()</code> restituisce una lista di tutte le sottostringhe che corrispondono al pattern.
<li>Qui il pattern di espressione regolare corrisponde a sequenze di lettere. Ancora, il valore di ritorno è una lista, e ogni elemento nella lista è una stringa che corrisponde a quel pattern di espressione regolare.
</ol>

<h2 id=unique-items>Trovare elementi unici in una sequenza</h2>

<p>Le descrizioni di insieme rendono banale trovare gli elementi unici di una sequenza. <span class=fixme>[FIXME-not sure if I&#8217;m going to cover set comprehensions in an earlier chapter; if not, this is certainly an abrupt and inadequate introduction to the topic.]</span>

<pre class=screen>
<samp class=p>>>> </samp><kbd>a_list = ['a', 'c', 'b', 'a', 'd', 'b']</kbd>
<a><samp class=p>>>> </samp><kbd>{c for c in a_list}</kbd>                      <span>&#x2460;</span></a>
<samp>{'a', 'c', 'b', 'd'}</samp>
<samp class=p>>>> </samp><kbd>a_string = 'EAST IS EAST'</kbd>
<a><samp class=p>>>> </samp><kbd>{c for c in a_string}</kbd>                    <span>&#x2461;</span></a>
<samp>{'A', ' ', 'E', 'I', 'S', 'T'}</samp>
<samp class=p>>>> </samp><kbd>words = ['SEND', 'MORE', 'MONEY']</kbd>
<a><samp class=p>>>> </samp><kbd>''.join(words)</kbd>                           <span>&#x2462;</span></a>
<samp>'SENDMOREMONEY'</samp>
<a><samp class=p>>>> </samp><kbd>{c for c in ''.join(words)}</kbd>              <span>&#x2463;</span></a>
<samp>{'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</samp></pre>
<ol>
<li>Data una lista contenente diverse stringhe, una descrizione di insieme con la funzione identità restituirà un insieme di stringhe uniche dalla lista. Questa operazione ha senso se lo pensate come un ciclo <code>for</code>. Prendete il primo elemento della lista, mettetelo nell'insieme. Il secondo. Il terzo. Il quarto &mdash; aspettate, quello è già nell'insieme, quindi va elencato solo una volta. Il quinto. Il sesto &mdash; ancora, un duplicato, quindi va elencato solo una volta. Il risultato finale? Tutti gli elementi unici della lista originale, senza alcun duplicato. La lista originale non deve nemmeno essere ordinata prima.
<li>La stessa tecnica funziona con le stringhe, dato che una stringa è solamente una sequenza di caratteri.
<li>Data una lista di stringhe, <code>''.join(<var>a_list</var>)</code> le concatena tutte in un'unica stringa.
<li>Quindi, data una lista di stringhe, questa descrizione di insieme restituisce tutti i caratteri unici su tutte le stringhe, senza alcun duplicato.
</ol>

<p>Il risolutore di alfametica usa questa tecnica per ottenere una lista di tutti i caratteri unici nel rompicapo.

<pre><code>unique_characters = {c for c in ''.join(words)}</code></pre>

<p>Questa lista viene successivamente usata per assegnare le cifre ai caratteri man mano che il risolutore itera attraverso le possibili soluzioni.

<h2 id=assert>Fare asserzioni</h2>

<p>Come molti linguaggi di programmazione, Python possiede una istruzione <code>assert</code>. Ecco come funziona.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>assert 1 + 1 == 2</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>assert 1 + 1 == 3</kbd>  <span>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in <module>
AssertionError</samp></pre>
<ol>
<li>L'istruzione <code>assert</code> è seguita da una qualsiasi espressione Python valida. In questo caso, l'espressione <code>1 + 1 == 2</code> viene valutata a <code>True</code>, quindi l'istruzione <code>assert</code> non fa nulla.
<li>Comunque, se l'espressione Python viene valutata a <code>False</code>, l'istruzione <code>assert</code> solleverà una eccezione di tipo <code>AssertionError</code>.
</ol>

<p>Perciò, questa riga di codice:

<pre><code>assert len(unique_characters) <= 10</code></pre>

<p>&hellip;è equivalente a&hellip;

<pre><code>if len(unique_characters) > 10:
    raise AssertionError</code></pre>

<p>Ma è leggermente più facile da leggere e scrivere.

<p>Il risolutore di alfametica usa proprio questa istruzione di <code>assert</code> per interrompere la propria esecuzione nel caso il rompicapo contenga più di dieci singole lettere. Dato che a ogni lettera va assegnata una singola cifra, e ci sono solo dieci cifre, un rompicapo con più di dieci singole lettere non è risolvibile.

<h2 id=generator-expressions>Espressioni generatore</h2>

<p>Una espressione generatore è come una <a href=generatori.html>funzione generatore</a> senza la funzione.

<pre class=screen>
<samp>>>> </samp><kbd>unique_characters = {'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</kbd>
<a><samp>>>> </samp><kbd>gen = (ord(c) for c in unique_characters)</kbd>  <span>&#x2460;</span></a>
<a><samp>>>> </samp><kbd>gen</kbd>                                        <span>&#x2461;</span></a>
<samp>&lt;generator object &lt;genexpr> at 0x00BADC10></samp>
<a><samp>>>> </samp><kbd>next(gen)</kbd>                                  <span>&#x2462;</span></a>
<samp>69</samp>
<samp>>>> </samp><kbd>next(gen)</kbd>
<samp>68</samp>
<a><samp>>>> </samp><kbd>tuple(ord(c) for c in unique_characters)</kbd>   <span>&#x2463;</span></a>
<samp>(69, 68, 77, 79, 78, 83, 82, 89)</samp></pre>
<ol>
<li>Una espressione generatore è come una funzione anonima che produce valori. L'espressione stessa somiglia a una descrizione di lista <span class=fixme>[FIXME have we introduced this yet?]</span>, ma è circondata da parentesi tonde invece che parentesi quadre.
<li>Una espressione generatore restitiusce&hellip; un iteratore.
<li>Invocare <code>next(<var>gen</var>)</code> restituisce il valore successivo dall'iteratore.
<li>Se volete, potete iterare attraverso tutti i possibili valori e restituire una tupla, una lista, o un insieme, passando l'espressione generatore a <code>tuple()</code>, <code>list()</code>, o <code>set()</code>.
</ol>

<p>Ecco un altro modo di realizzare la stessa cosa, utilizzando una <a href=generatori.html>funzione generatore</a>:

<pre><code>def ord_map(a_string):
    for c in a_string:
        yield ord(c)

gen = ord_map(unique_characters)</code></pre>

<h2 id=permutations>Calcolare le permutazioni&hellip; in maniera ritardata!</h2>

<p>Prima di tutto, cosa diavolo sono le permutazioni? Le permutazioni sono un concetto matematico. (Ci sono effettivamente diverse definizioni, a seconda di quale matematica state utilizzando. Qui sto parlando di combinatoria, ma se questo non vi dice niente, non preoccupatevi. Come sempre, <a href="http://it.wikipedia.org/wiki/Permutazioni">Wikipedia è vostra amica</a>.)

<p>L'idea alla base delle permutazioni è quella di prendere una lista di cose (potrebbero essere numeri, potrebbero essere lettere, potrebbero essere orsi danzanti) e trovare tutti i modi possibili per dividerla in liste più piccole. Tutte le liste più piccole hanno la stessa dimensione, che può essere tanto piccola quanto 1 e tanto grande quanto il numero totale degli elementi. Oh, e nessun oggetto può essere ripetuto. I matematici dicono cose come &#8220;troviamo le permutazioni di 3 elementi differenti presi 2 alla volta,&#8221; che significa trovare tutte le possibili coppie ordinate a partire da una sequenza di 3 elementi.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>import itertools</kbd>                              <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>perms = itertools.permutations([1, 2, 3], 2)</kbd>  <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>next(perms)</kbd>                                   <span>&#x2462;</span></a>
<samp>(1, 2)</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>(1, 3)</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<a><samp>(2, 1)</samp>                                            <span>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>(2, 3)</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>(3, 1)</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd>next(perms)</kbd>                                   <span>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in <module>
StopIteration</samp></pre>
<ol>
<li>Il modulo <code>itertools</code> contiene i più svariati tipi di roba divertente, compresa una funzione <code>permutations()</code> che si sobbarca tutto il duro lavoro della ricerca di permutazioni.
<li>La funzione <code>permutations()</code> prende una sequenza (qui una lista di tre interi) e un numero, che è il numero di elementi che volete includere in ogni gruppo più piccolo. La funzione restituisce un iteratore, che potete usare in un ciclo <code>for</code> o in qualsiasi altro vecchio luogo che itera. Qui attraverserò l'iteratore manualmente per mostrare tutti i valori.
<li>La prima permutazione degli elementi di <code>[1, 2, 3]</code> presi 2 alla volta è <code>(1, 2)</code>.
<li>Notate che le permutazioni sono ordinate: <code>(2, 1)</code> è diversa da <code>(1, 2)</code>.
<li>Ecco qua! Quelle che abbiamo visto sono tutte le permutazioni degli elementi di <code>[1, 2, 3]</code> presi 2 alla volta. Coppie come <code>(1, 1)</code> e <code>(2, 2)</code> non compaiono mai, perché contengono ripetizioni e quindi non sono permutazioni valide. Quando non ci sono più permutazioni, l'iteratore solleva una eccezione di tipo <code>StopIteration</code>.
</ol>

<p>La funzione <code>permutations()</code> non deve prendere una lista. Può prendere ogni sequenza &mdash; persino una stringa.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd>perms = itertools.permutations('ABC', 3)</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<a><samp>('A', 'B', 'C')</samp>                               <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>('A', 'C', 'B')</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>('B', 'A', 'C')</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>('B', 'C', 'A')</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>('C', 'A', 'B')</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp>('C', 'B', 'A')</samp>
<samp class=p>>>> </samp><kbd>next(perms)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in <module>
StopIteration</samp>
<a><samp class=p>>>> </samp><kbd>list(itertools.permutations('ABC', 3))</kbd>    <span>&#x2462;</span></a>
<samp>[('A', 'B', 'C'), ('A', 'C', 'B'),
 ('B', 'A', 'C'), ('B', 'C', 'A'),
 ('C', 'A', 'B'), ('C', 'B', 'A')]</samp></pre>
<ol>
<li>Una stringa è semplicemente una sequenza di caratteri. Allo scopo di trovare permutazioni, la stringa <code>'ABC'</code> è equivalente alla lista <code>['A', 'B', 'C']</code>.
<li>La prima permutazione dei 3 elementi in <code>['A', 'B', 'C']</code>, presi 3 alla volta, è <code>('A', 'B', 'C')</code>. Esistono altre cinque permutazioni &mdash; gli stessi tre caratteri in ogni ordine possibile.
<li>Dato che la funzione <code>permutations()</code> restituisce sempre un iteratore, si può facilmente effettuare il debug sulle permutazioni passando l'iteratore alla funzione built-in <code>list()</code> per vedere immediatamente tutte le permutazioni.
</ol>

<h2 id=more-itertools>Altra roba divertente nel modulo <code>itertools</code></h2>
<pre class=screen>
<samp class=p>>>> </samp><kbd>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd>list(itertools.product('ABC', '123'))</kbd>   <span>&#x2460;</span></a>
<samp>[('A', '1'), ('A', '2'), ('A', '3'), 
 ('B', '1'), ('B', '2'), ('B', '3'), 
 ('C', '1'), ('C', '2'), ('C', '3')]</samp>
<a><samp class=p>>>> </samp><kbd>list(itertools.combinations('ABC', 2))</kbd>  <span>&#x2461;</span></a>
<samp>[('A', 'B'), ('A', 'C'), ('B', 'C')]</samp></pre>
<ol>
<li>La funzione <code>itertools.product()</code> restituisce un iteratore contenente il prodotto cartesiano di due sequenze.
<li>La funzione <code>itertools.combinations()</code> restituisce un iteratore contenente tutte le possibili combinazioni di lunghezza data a partire dalla sequenza data. Questa funzione si comporta come la funzione <code>itertools.permutations()</code>, a parte il fatto che le combinazioni non includono elementi che sono il duplicato di altri elementi in ordine differente. Quindi <code>itertools.permutations('ABC', 2)</code> restituirà sia <code>('A', 'B')</code> and <code>('B', 'A')</code> (tra le altre), ma <code>itertools.combinations('ABC', 2)</code> non restituirà <code>('B', 'A')</code> perché è il duplicato di <code>('A', 'B')</code> con un differente ordine degli elementi.
</ol>

<p class=d>[<a href=esempi/favorite-people.txt>scarica <code>favorite-people.txt</code></a>]
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>names = list(open('esempi/favorite-people.txt'))</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>names</kbd>
<samp>['Dora\n', 'Ethan\n', 'Wesley\n', 'John\n', 'Anne\n',
'Mike\n', 'Chris\n', 'Sarah\n', 'Alex\n', 'Lizzie\n']</samp>
<a><samp class=p>>>> </samp><kbd>names = [name.rstrip() for name in names]</kbd>           <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>names</kbd>
<samp>['Dora', 'Ethan', 'Wesley', 'John', 'Anne',
'Mike', 'Chris', 'Sarah', 'Alex', 'Lizzie']</samp>
<a><samp class=p>>>> </samp><kbd>names = sorted(names)</kbd>                               <span>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>names</kbd>
<samp>['Alex', 'Anne', 'Chris', 'Dora', 'Ethan',
'John', 'Lizzie', 'Mike', 'Sarah', 'Wesley']</samp>
<a><samp class=p>>>> </samp><kbd>names = sorted(names, key=len)</kbd>                      <span>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd>names</kbd>
<samp>['Alex', 'Anne', 'Dora', 'John', 'Mike',
'Chris', 'Ethan', 'Sarah', 'Lizzie', 'Wesley']</samp></pre>
<ol>
<li>Questo idioma restituisce una lista delle righe in un file di testo.
<li>Sfortunatamente (per questo esempio), l'idioma <code>list(open(<var>filename</var>))</code> include anche i ritorni a capo alla fine di ogni riga. Questa descrizione di lista usa il metodo <code>rstrip()</code> delle stringhe per togliere lo spazio bianco in coda ad ogni riga.
<li>La funzione <code>sorted()</code> prende una lista e la restituisce ordinata. Di default, l'ordine è alfabetico.
<li>Ma la funzione <code>sorted()</code> può anche prendere una funzione come parametro <var>key</var>, e ordinare in base ad essa. In questo caso, la funzione di ordinamento è <code>len()</code>, quindi questa invocazione ordina sulla base della lunghezza di ogni elemento, calcolando <code>len(<var>each_item</var>)</code>. I nomi più corti vengono prima, poi quelli più lunghi, poi quelli ancora più lunghi.
</ol>

<p>Che cos'ha a che fare tutto questo con il modulo <code>itertools</code>? Sono contento che lo abbiate chiesto.

<pre class=screen>
<p>&hellip;continuando dalla shell interattiva precedente&hellip;
<samp class=p>>>> </samp><kbd>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd>groups = itertools.groupby(names, len)</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>groups</kbd>
<samp>&lt;itertools.groupby object at 0x00BB20C0></samp>
<samp class=p>>>> </samp><kbd>list(groups)</kbd>
<samp>[(4, &lt;itertools._grouper object at 0x00BA8BF0>),
 (5, &lt;itertools._grouper object at 0x00BB4050>),
 (6, &lt;itertools._grouper object at 0x00BB4030>)]</samp>
<samp class=p>>>> </samp><kbd>groups = itertools.groupby(names, len)</kbd>
<a><samp class=p>>>> </samp><kbd>for name_length, name_iter in groups:</kbd>    <span>&#x2461;</span></a>
<samp class=p>... </samp><kbd>    print('Nomi con {0:d} lettere:'.format(name_length))</kbd>
<samp class=p>... </samp><kbd>    for name in name_iter:</kbd>
<samp class=p>... </samp><kbd>        print(name)</kbd>
<samp class=p>... </samp>
<samp>Nomi con 4 lettere:
Alex
Anne
Dora
John
Mike
Nomi con 5 lettere:
Chris
Ethan
Sarah
Nomi con 6 lettere:
Lizzie
Wesley</samp></pre>
<ol>
<li>La funzione <code>itertools.groupby()</code> prende una sequenza e una funzione chiave, e restituisce un iteratore che genera coppie. Ogni coppia è composta dal risultato dell'applicazione della funzione chiave a ogni elemento (<code>key_function(<var>each_item</var>)</code>) e da un altro iteratore che contiene tutti gli elementi che condividono quel risultato.
<li>In questo esempio, data una lista di nomi ordinata per lunghezza, <code>itertools.groupby(names, len)</code> metterà tutti i nomi di 4 lettere in un iteratore, tutti i nomi di 5 lettere in un altro iteratore, e così via. La funzione <code>groupby()</code> è completamente generica; potrebbe raggruppare stringhe sulla base della prima lettera, numeri sulla base del loro numero di fattori, oppure utilizzando qualsiasi altra funzione chiave che vi possa venire in mente.
</ol>
<!-- YO DAWG, WE HEARD YOU LIKE LOOPING, SO WE PUT AN ITERATOR IN YOUR ITERATOR SO YOU CAN LOOP WHILE YOU LOOP. -->
<p>State guardando da vicino?
<pre class=screen>
<samp class=p>>>> </samp><kbd>list(range(0, 3))</kbd>
<samp>[0, 1, 2]</samp>
<samp class=p>>>> </samp><kbd>list(range(10, 13))</kbd>
<samp>[10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd>list(itertools.chain(range(0, 3), range(10, 13)))</kbd>        <span>&#x2460;</span></a>
<samp>[0, 1, 2, 10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd>list(zip(range(0, 3), range(10, 13)))</kbd>                    <span>&#x2461;</span></a>
<samp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd>list(zip(range(0, 3), range(10, 14)))</kbd>                    <span>&#x2462;</span></a>
<samp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd>list(itertools.zip_longest(range(0, 3), range(10, 14)))</kbd>  <span>&#x2463;</span></a>
<samp>[(0, 10), (1, 11), (2, 12), (None, 13)]</samp></pre>
<ol>
<li>La funzione <code>itertools.chain()</code> prende due iteratori e restituisce un iteratore che contiene tutti gli elementi del primo iteratore seguiti da tutti gli elementi del secondo iteratore. (In realtà, può prendere un numero qualsiasi di iteratori, e concatenarli tutti nell'ordine in cui sono stati passati alla funzione.)
<li>La funzione <code>zip()</code> fa qualcosa di prosaico che si rivela estremamente utile: prende un numero qualsiasi di sequenze e restituisce un iteratore col primo elemento di ogni sequenza, poi il secondo elemento di ognuna, poi il terzo, e così via.
<li>La funzione <code>zip()</code> si ferma alla fine della sequenza più corta. <code>range(10, 14)</code> contiene 4 elementi (10, 11, 12, e 13), ma <code>range(0, 3)</code> ne contiene solo 3, quindi la funzione <code>zip()</code> restituisce un iteratore di 3 elementi.
<li>D'altra parte, la funzione <code>itertools.zip_longest()</code> si ferma alla fine della sequenza <em>più lunga</em>, inserendo il valore <code>None</code> per elementi oltre la fine delle sequenze più corte.
</ol>

<p id=dict-zip>OK, tutto questo è stato molto interessante, ma come si collega al risolutore di alfametica? Ecco come:

<pre class=screen>
<samp class=p>>>> </samp><kbd>characters = ('S', 'M', 'E', 'D', 'O', 'N', 'R', 'Y')</kbd>
<samp class=p>>>> </samp><kbd>guess = ('1', '2', '0', '3', '4', '5', '6', '7')</kbd>
<a><samp class=p>>>> </samp><kbd>tuple(zip(characters, guess))</kbd>  <span>&#x2460;</span></a>
<samp>(('S', '1'), ('M', '2'), ('E', '0'), ('D', '3'),
 ('O', '4'), ('N', '5'), ('R', '6'), ('Y', '7'))</samp>
<a><samp class=p>>>> </samp><kbd>dict(zip(characters, guess))</kbd>   <span>&#x2461;</span></a>
<samp>{'E': '0', 'D': '3', 'M': '2', 'O': '4',
 'N': '5', 'S': '1', 'R': '6', 'Y': '7'}</samp></pre>
<ol>
<li>Data una lista di lettere e una lista di cifre (ognuna rappresentata qui come una stringa di 1 carattere), la funzione <code>zip()</code> creerà coppie di lettere e cifre, in ordine.
<li>Perché è così figo? Perché si dà il caso che la struttura dati sia esattamente la struttura giusta da passare alla funzione <code>dict()</code> per creare un dizionario che usi le lettere come chiavi e le cifre ad esse associate come valori. Sebbene la rappresentazione stampata del dizionario elenchi le coppie in ordine differente (i dizionari non hanno alcun &#8220;ordine&#8221; di per sé), potete vedere che ogni lettera è associata con una cifra sulla base dell'ordinamento delle sequenze <var>characters</var> e <var>guess</var> originali.
</ol>

<p id=guess>Il risolutore di alfametica usa questa tecnica per creare un dizionario che mette in corrispondenza le lettere nel rompicampo con le cifre nella soluzione, per ogni possibile soluzione.

<pre><code>characters = tuple(ord(c) for c in sorted_characters)
digits = tuple(ord(c) for c in '0123456789')
...
for guess in itertools.permutations(digits, len(characters)):
    ...
<mark>    equation = puzzle.translate(dict(zip(characters, guess)))</mark></code></pre>

<p>Ma cos'è questo metodo <code>translate()</code>? Ah, ora state arrivando alla parte <em>davvero</em> divertente.

<h2 id=string-translate>Un nuovo tipo di manipolazione di stringhe</h2>

<p>Le stringhe Python hanno molti metodi. Avete imparato alcuni di quei metodi nel <a href=stringhe.html>capitolo sulle stringhe</a>: <code>lower()</code>, <code>count()</code>, e <code>format()</code>. Ora voglio introdurvi a una tecnica di manipolazione di stringhe molto potente ma poco conosciuta: il metodo <code>translate()</code>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>translation_table = {ord("A"): ord("O")}</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>translation_table</kbd>                         <span>&#x2461;</span></a>
<samp>{65: 79}</samp>
<a><samp class=p>>>> </samp><kbd>'MARK'.translate(translation_table)</kbd>       <span>&#x2462;</span></a>
<samp>'MORK'</samp></pre>
<ol>
<li>Le traduzioni di stringa cominciano con una tabella di traduzione, che è solo un dizionario che mette in corrispondenza un carattere con un altro. In realtà &#8220;carattere&#8221; non è il termine giusto &mdash; in realtà la tabella di traduzione mette in corrispondenza un <em>byte</em> con un altro.
<li>Ricordate, i byte in Python 3 sono interi. La funzione <code>ord()</code> restituisce il valore <abbr>ASCII</abbr> di un carattere, che nel caso delle lettere A&ndash;Z è sempre un byte da 65 a 90.
<li>Il metodo <code>translate()</code> fa scorrere una stringa attraverso la tabella di traduzione passata come argomento, sostituendo tutte le occorrenze delle chiavi della tabella con i valori corrispondenti. In questo caso, &#8220;traducendo&#8221; <code>MARK</code> in <code>MORK</code>.
</ol>

<p>Che cos'ha a che fare questo con la soluzione dei rompicapi alfametici? A quanto pare, tutto.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>characters = tuple(ord(c) for c in 'SMEDONRY')</kbd>       <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>characters</kbd>
<samp>(83, 77, 69, 68, 79, 78, 82, 89)</samp>
<a><samp class=p>>>> </samp><kbd>guess = tuple(ord(c) for c in '91570682')</kbd>            <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>guess</kbd>
<samp>(57, 49, 53, 55, 48, 54, 56, 50)</samp>
<a><samp class=p>>>> </samp><kbd>translation_table = dict(zip(characters, guess))</kbd>     <span>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>translation_table</kbd>
<samp>{68: 55, 69: 53, 77: 49, 78: 54, 79: 48, 82: 56, 83: 57, 89: 50}</samp>
<a><samp class=p>>>> </samp><kbd>"SEND + MORE == MONEY".translate(translation_table)</kbd>  <span>&#x2463;</span></a>
<samp>'9567 + 1085 == 10652'</samp></pre>
<ol>
<li>Usando una <a href=#generator-expressions>espressione generatore</a>, calcoliamo velocemente i valori in byte per ogni carattere in una stringa. <var>characters</var> è un esempio dei valori di <var>sorted_characters</var> nella funzione <code>alphametics.solve()</code>.
<li>Usando un'altra espressione generatore, calcoliamo velocemente i valori in byte per ogni cifra in quella stringa. Il risultato, <var>guess</var>, è nella forma <a href=#guess>restituita dalla funzione <code>itertools.permutations()</code></a> nella funzione <code>alphametics.solve()</code>.
<li>Questa tabella di traduzione è generata <a href=#dict-zip>invocando <code>zip()</code> su <var>characters</var> e <var>guess</var></a> e costruendo un dizionario a partire dalla sequenza di coppie risultante. Questo è esattamente quello che la funzione <code>alphametics.solve()</code> fa all'interno del ciclo <code>for</code>.
<li>Infine, passiamo la tabella di traduzione al metodo <code>translate()</code> della stringa del rompicapo originale. Questa operazione converte ogni lettera nella stringa alla cifra corrispondente (sulla base delle lettere in <var>characters</var> e delle cifre in <var>guess</var>). Il risultato è una espressione Python valida, sotto forma di stringa.
</ol>

<p>Piuttosto impressionante. Ma cosa potete fare con una stringa che casualmente rappresenta una espressione Python valida?

<h2 id=eval>Valutare stringhe arbitrarie come espressioni Python</h2>

<p>Questo è l'ultimo pezzo del puzzle (o piuttosto, l'ultimo pezzo del risolutore di puzzle). Dopo tutta quella sofisticata manipolazione di stringhe, non ci rimane altro che una stringa come <code>'9567 + 1085 == 10652'</code>. Ma quella è appunto solo una stringa, e a cosa può servirci una stringa? Entra <code>eval()</code>, lo strumento universale di valutazione in Python.

<pre class=screen>
<samp class=p>>>> </samp><kbd>eval('1 + 1 == 2')</kbd>
<samp>True</samp>
<samp class=p>>>> </samp><kbd>eval('1 + 1 == 3')</kbd>
<samp>False</samp>
<samp class=p>>>> </samp><kbd>eval('9567 + 1085 == 10652')</kbd>
<samp>True</samp></pre>

<p>Ma aspettate, c'è di più! La funzione <code>eval()</code> non si limita alle espressioni logiche. Può gestire <em>qualsiasi</em> espressione Python e restituire <em>qualsiasi</em> tipo di dato.

<pre class=screen>
<samp class=p>>>> </samp><kbd>eval('"A" + "B"')</kbd>
<samp>'AB'</samp>
<samp class=p>>>> </samp><Kbd>eval('"MARK".translate({65: 79})')</kbd>
<samp>'MORK'</samp>
<samp class=p>>>> </samp><kbd>eval('"AAAAA".count("A")')</kbd>
<samp>5</samp>
<samp class=p>>>> </samp><kbd>eval('["*"] * 5')</kbd>
<samp>['*', '*', '*', '*', '*']</samp></pre>

<p>Ma aspettate, non è tutto!

<pre class=screen>
<samp class=p>>>> </samp><kbd>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd>eval("x * 5")</kbd>         <span>&#x2460;</span></a>
<samp>25</samp>
<a><samp class=p>>>> </samp><kbd>eval("pow(x, 2)")</kbd>     <span>&#x2461;</span></a>
<samp>25</samp>
<samp class=p>>>> </samp><kbd>import math</kbd>
<a><samp class=p>>>> </samp><kbd>eval("math.sqrt(x)")</kbd>  <span>&#x2462;</span></a>
<samp>2.2360679774997898</samp></pre>
<ol>
<li>L'espressione che <code>eval()</code> accetta può fare riferimento a variabili globali definite al di fuori di <code>eval()</code>. Se chiamata all'interno di una funzione, può anche fare riferimento a variabili locali.
<li>E a funzioni.
<li>E a moduli.
</ol>

<p>Hey, aspettate un momento&hellip;

<pre class=screen>
<samp class=p>>>> </samp><kbd>import subprocess</kbd>
<a><samp class=p>>>> </samp><kbd>eval("subprocess.getoutput('ls ~')")</kbd>      <span>&#x2460;</span></a>
<samp>'Desktop         Library         Pictures \
 Documents       Movies          Public   \
 Music           Sites'</samp>
<a><samp class=p>>>> </samp><kbd>eval("subprocess.getoutput('rm -rf /')")</kbd>  <span>&#x2461;</span></a></pre>
<ol>
<li>Il modulo <code>subprocess</code> vi permette di lanciare comandi di shell arbitrari e ottenerne il risultato sotto forma di stringa Python.
<li>Non fatelo.
</ol>

<p>&Egrave; anche peggio di così, perché esiste una funzione globale chiamata <code>__import__()</code> che prende il nome di un modulo sotto forma di stringa, importa il modulo, e restituisce un riferimento ad esso. Combinandola con la potenza di <code>eval()</code>, potete costruire una singola espressione che cancellerà tutti i vostri file:

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>eval("__import__('subprocess').getoutput('rm -rf /')")</kbd>  <span>&#x2460;</span></a></pre>
<ol>
<li>Non fate nemmeno questo.
</ol>

<p class=c style="font-size:1000%;font-weight:bold;line-height:1;margin:0.7em 0">eval() è MALVAGIA

<p>Be', la parte malvagia è la valutazione di espressioni arbitrarie provenienti da sorgenti non affidabili. Dovreste usare <code>eval()</code> solo su ingressi affidabili. Naturalmente, il trucco è scoprire cos'è &#8220;affidabile.&#8221 Ma ecco qualcosa che so di sicuro: <b>NON</b> dovreste prendere questo risolutore di alfametica e metterlo su Internet come un piccolo servizio web divertente. Non fate l'errore di pensare &#8220;Gosh, la funzione effettua un sacco di manipolazioni di stringhe prima di ottenere una stringa da valutare; <em>non riesco a immaginare</em> come qualcuno potrebbe servirsene.&#8221; Qualcuno <b>SCOPRIR&Agrave;</b> come infilare codice eseguibile pericoloso attraverso tutte quelle manipolazioni di stringhe (<a href=http://www.matasano.com/log/1032/this-new-vulnerability-dowds-inhuman-flash-exploit/>sono accadute cose anche più strane</a>), e poi potrete dare al vostro server il bacio d'addio.

<p>Ma sicuramente ci sarà <em>qualche</em> modo per valutare espressioni in sicurezza? Mettere <code>eval()</code> in un ambiente controllato dove non possa accedere o danneggiare il mondo esterno? Be', sì, ma è complicato.

<pre class=screen>
<samp class=p>>>> </samp><kbd>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd>eval("x * 5", {}, {})</kbd>               <span>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'x' is not defined</samp>
<a><samp class=p>>>> </samp><kbd>eval("x * 5", {"x": x}, {})</kbd>         <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>import math</kbd>
<a><samp class=p>>>> </samp><kbd>eval("math.sqrt(x)", {"x": x}, {})</kbd>  <span>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'math' is not defined</samp></pre>
<ol>
<li>Il secondo e terzo parametro passati alla funzione <code>eval()</code> agiscono come spazi di nomi globali e locali in cui valutare l'espressione. In questo caso, sono entrambi vuoti, così quando la stringa <code>"x * 5"</code> viene valutata non esiste alcun riferimento a <var>x</var> né nello spazio di nomi globale né in quello locale, quindi <code>eval()</code> solleva una eccezione.
<li>Potete selettivamente includere specifici valori nello spazio di nomi globale elencandoli individualmente. Poi quelle variabili &mdash; e solo quelle &mdash; saranno disponibili durante la valutazione.
<li>Anche se avete appena importato il modulo <code>math</code>, non lo avete incluso nello spazio di nomi passato alla funzione <code>eval()</code>, così la valutazione è fallita.
</ol>

<p>Perbacco, è stato facile. Lasciatemi fare quel servizio web di alfametica ora!

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>eval("pow(5, 2)", {}, {})</kbd>                   <span>&#x2460;</span></a>
<samp>25</samp>
<a><samp class=p>>>> </samp><kbd>eval("__import__('math').sqrt(5)", {}, {})</kbd>  <span>&#x2461;</span></a>
<samp>2.2360679774997898</samp></pre>
<ol>
<li>Anche se avete passato dizionari vuoti per gli spazi di nomi globali e locali, tutte le funzioni built-in di Python sono ancora disponibili durante la valutazione. Quindi <code>pow(5, 2)</code> funziona, perché <code>5</code> e <code>2</code> sono letterali, e <code>pow()</code> è una funzione built-in.
<li>Sfortunatamente (e se non vedete perché è una sfortuna, continuate a leggere), anche la funzione <code>__import__()</code> è una funzione built-in, quindi anch'essa è disponibile.
</ol>

<p>Sì, questo significa che potete ancora fare cose pericolose, anche se avete esplicitamente impostato gli spazi di nomi globali e locali a dizionari vuoti quando avete chiamato <code>eval()</code>:

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>eval("__import__('subprocess').getoutput('rm -rf /')", {}, {})</kbd>  <span>&#x2460;</span></a></pre>
<ol>
<li>Per favore non fatelo.
</ol>

<p>Oops. Sono contento di non aver fatto quel servizio web di alfametica. C'è un modo <em>qualsiasi</em> di utilizzare <code>eval()</code> in sicurezza?

<pre class=screen>
<samp class=p>>>> </samp><kbd>eval("__import__('math').sqrt(5)",</kbd>
<a><samp class=p>... </samp><kbd>    {"__builtins__":None}, {})</kbd>          <span>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp>
<samp class=p>>>> </samp><kbd>eval("__import__('subprocess').getoutput('rm -rf /')",</kbd>
<a><samp class=p>... </samp><kbd>    {"__builtins__":None}, {})</kbd>          <span>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
NameError: name '__import__' is not defined</samp></pre>
<ol>
<li>Per valutare espressioni non affidabili in maniera sicura, avete bisogno di definire nello spazio di nomi globale un dizionario che faccia corrispondere <code>"__builtins__"</code> a <code>None</code>, il valore nullo di Python. Internamente, le funzioni &#8220;built-in&#8221; sono contenute in uno pseudo-modulo chiamato <code>"__builtins__"</code>. Questo pseudo-modulo (<i>i.e.</i> l'insieme delle funzioni built-in) viene reso disponibile alle espressioni valutate a meno che non lo rimpiazziate esplicitamente.
<li>Potete fare questo, ma state molto, molto attenti a non fare errori di ortografia. In particolare, assicuratevi di aver rimpiazzato <code>__builtins__</code> e non <code>__builtin__</code> o <code>__built-ins__</code> o qualche altra variazione.
</ol>

<p>Quindi, alla fine, <em>è</em> possibile valutare in sicurezza espressioni Python non affidabili. Passare <code>{"__builtins__": None}</code> come secondo parametro alla funzione <code>eval()</code> non è intuitivo (e non è il comportamento di default) ma funziona. Se capite <em>perché</em> funziona, sarà meno probabile che usiate <code>eval()</code> in maniera scorretta, in un modo che funziona con ingressi affidabili ma che ha conseguenze potenzialmente devastanti con ingressi non affidabili.

<h2 id=alphametics-finale class=wtf>Putting It All Together</h2>

<p>Ricapitolando: questo programma risolve rompicapi alfametici utilizzando la forza bruta, <i>i.e.</i> attraverso una ricerca completa di tutte le possibili soluzioni. Per fare questo, il programma&hellip;

<ol>
<li><a href=#re-findall>Trova tutte le lettere nel rompicapo</a> con la funzione <code>re.findall()</code>
<li><a href=#unique-items>Trova tutte le lettere <em>uniche</em> nel rompicapo</a> con le descrizioni di insieme
<li><a href=#assert>Controlla se ci sono più di 10 lettere uniche</a> (cioè se il rompicapo è assolutamente irrisolvibile) con una istruzione <code>assert</code>
<li><a href=#generator-objects>Converte le lettere ai loro equivalenti <abbr>ASCII</abbr></a> con un oggetto generatore
<li><a href=#permutations>Calcola tutte le possibili soluzioni</a> con la funzione <code>itertools.permutations()</code>
<li><a href=#string-translate>Converte ogni possibile soluzione in una espressione Python</a> con il metodo <code>translate()</code> delle stringhe
<li><a href=#eval>Verifica ogni possibile soluzione valutando l'espressione Python</a> con la funzione <code>eval()</code>
<li>Restituisce la prima soluzione che viene valutata a <code>True</code>
</ol>

<p>&hellip;in sole 14 righe di codice.

<h2 id=furtherreading>Letture di approfondimento</h2>

<ul>
<li>Guardate Raymond Hettiger presentare <a href="http://blip.tv/file/1947373/">"Easy AI with Python"</a> a PyCon 2009
<li><a href="http://code.activestate.com/recipes/576615/">Recipe 576615: Alphametics solver</a>, il risolutore di alfametica originale scritto da Raymond Hettinger per Python 2
<li><a href="http://code.activestate.com/recipes/users/178123/">Altre ricette di Raymond Hettinger</a> nel <span class=wtf>repository</span> di codice di ActiveState
<li><a href="http://en.wikipedia.org/wiki/Verbal_arithmetic">Alfametica su Wikipedia</a>
<li><a href="http://www.tkcs-collins.com/truman/alphamet/index.shtml">Indice dell'alfametica</a>, compresi <a href="http://www.tkcs-collins.com/truman/alphamet/alphamet.shtml">un sacco di rompicapi</a> e <a href="http://www.tkcs-collins.com/truman/alphamet/alpha_gen.shtml">un generatore per farne dei vostri</a>
</ul>

<p>Molti, moltissimi ringraziamenti a Raymond Hettinger per aver accettato di ridistribuire il suo codice con una licenza diversa in modo che io potessi convertirlo verso Python 3 e usarlo come base per questo capitolo.

<p class=nav><a rel=prev href=iteratori.html title="indietro a &#8220;Iteratori&#8221;"><span>&#x261C;</span></a> <a rel=next href=test-di-unità.html title="avanti a &#8220;Test di unità&#8221;"><span>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;9 <a href=informazioni-sul-libro.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
