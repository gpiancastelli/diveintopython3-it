<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Stringhe - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
body{counter-reset:h1 3}
.s{text-decoration:line-through}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#strings>Dive Into Python 3</a> <span>&#8227;</span>
<h1>Stringhe</h1>
<blockquote class=q>
<p><span>&#x275D;</span> I&#8217;m telling you this &#8217;cause you&#8217;re one of my friends.<br>
My alphabet starts where your alphabet ends! <span>&#x275E;</span><br>&mdash; Dr. Seuss, On Beyond Zebra!
</blockquote>
<p id=toc>&nbsp;
<h2 id=boring-stuff>Alcune cose noiose che avete bisogno di capire prima di potervi immergere</h2>
<p class=f>Sapevate che la gente di <a href="http://en.wikipedia.org/wiki/Bougainville_Province">Bougainville</a> ha il più piccolo alfabeto del mondo? Il loro <a href="http://en.wikipedia.org/wiki/Rotokas_alphabet">alfabeto Rotokas</a> è composto da sole 12 lettere: A, E, G, I, K, O, P, R, S, T, U, e V. Dall'altro lato dello spettro, lingue come il cinese, il giapponese e il coreano hanno migliaia di caratteri. L'inglese, ovviamente, ha 26 lettere &mdash; 52 se contate le maiuscole e le minuscole separatamente &mdash; più una manciata di <i class=baa>!@#$%&</i> simboli di punteggiatura.

<p>Quando la gente parla di &#8220;testo,&#8221; sta pensando a &#8220;caratteri e simboli su uno schermo di computer.&#8221; Ma i computer non hanno a che fare con caratteri e simboli; i computer maneggiano bit e byte. Ogni frammento di testo che avete mai visto sullo schermo di un computer si trova in realtà memorizzato in una particolare <i>codifica di carattere</i>. Parlando per sommi capi, la codifica di carattere fornisce una corrispondenza tra quello che vedete sul vostro schermo e quello che il vostro computer mantiene effettivamente in memoria e su disco. Ci sono molte codifiche di carattere diverse, alcune ottimizzate per particolari lingue come il russo o il cinese o l'inglese, e altre che possono essere usate per più di una lingua.

<p>In realtà, le cose sono molto più complicate di così. Molti caratteri sono comuni a più di una codifica, ma ogni codifica può usare una sequenza differente di byte per archiviare effettivamente quei caratteri in memoria o su disco. Quindi potete pensare alla codifica di carattere come a una sorta di chiave di decrittazione. Ogni volta che qualcuno vi dà una sequenza di byte &mdash; un file, una pagina web, qualsiasi cosa &mdash; e afferma che si tratta di &#8220;testo&#8221; avete bisogno di sapere quale codifica di carattere è stata usata in modo da poter decodificare i byte in caratteri. Se vi viene data la chiave sbagliata, o addirittura nessuna chiave, vi ritrovate con il non invidiabile compito di scoprire il codice da soli. Le probabilità sono che lo sbaglierete, e il risultato sarà spazzatura. 

<aside>Tutto quello che pensavate di sapere sulle stringhe è sbagliato.</aside>

<p>Sicuramente avrete visto pagine web con strani caratteri simili a punti interrogativi in posti dove dovrebbero trovarsi gli apostrofi. Solitamente questo significa che l'autore della pagina non ha dichiarato correttamente la codifica dei caratteri, il vostro browser non ha potuto fare altro che tirare a indovinare, e il risultato è stato un misto di caratteri attesi e inattesi. In inglese è solo un fastidio; in altre lingue il risultato potrebbe essere completamente illeggibile.

<p>Esistono codifiche di carattere per tutte le lingue più diffuse al mondo. Dato che ogni lingua è differente, e che la memoria e lo spazio su disco sono stati storicamente costosi, ogni codifica di carattere è ottimizzata per una particolare lingua. Con questo, voglio dire che ogni codifica usa gli stessi numeri (0&ndash;255) per rappresentare i caratteri di quella lingua. Per esempio, avrete probabilmente familiarità con la codifica <abbr>ASCII</abbr>, che memorizza i caratteri inglesi come numeri da 0 a 127. (65 è la &#8220;A&#8221; maiuscola, 97 è la &#8220;a&#8221; minuscola, <i class=baa>&amp;</i>c.) L'inglese ha un alfabeto molto semplice, quindi può essere completamente espresso in meno di 128 numeri. Per quelli di voi che sanno contare in base 2, questo significa utilizzare 7 degli 8 bit contenuti in un byte.

<p>Le lingue dell'Europa Occidentale come il francese, lo spagnolo e il tedesco hanno più lettere dell'inglese. O, più precisamente, hanno lettere combinate con vari segni diacritici, come il carattere <code>&ntilde;</code> in spagnolo. La codifica più comune per queste lingue è la CP-1252, anche chiamata &#8220;windows-1252&#8221; perché viene largamente utilizzata sotto Microsoft Windows. La codifica CP-1252 condivide caratteri con la codifica <abbr>ASCII</abbr> nell'intervallo 0&ndash;127, ma poi si espande nell'intervallo 128&ndash;255 per caratteri come la n-con-sopra-una-tilde (241), la u-con-sopra-due-punti (252), <i class=baa>&amp;</i>c. Questa è ancora una codifica a singolo byte, comunque; il numero più elevato, 255, sta ancora in un byte.

<p>Poi ci sono lingue come il cinese, il giapponese e il coreano che hanno talmente tanti caratteri da richiedere un insieme di caratteri a byte multipli. Cioè, ogni &#8220;carattere&#8221; è rappresentato da un numero a 2 byte tra 0 e 65535. Ma codifiche multi-byte differenti hanno gli stessi problemi di codifiche a singolo byte differenti, e cioè che ognuna usa gli stessi numeri per significare cose diverse. &Egrave; solo che l'intervallo dei numeri è più ampio, perché ci sono molti più caratteri da rappresentare.

<p>Questo andava quasi bene in un mondo senza reti, dove il &#8220;testo&#8221; era qualcosa che scrivevate voi stessi e stampavate occasionalmente. Non c'era molto &#8220;testo semplice&#8221;. Il codice sorgente era in <abbr>ASCII</abbr>, e tutti gli altri usavano i word processor, ognuno dei quali definiva il proprio formato (non di testo) che teneva traccia delle informazioni sulla codifica di carattere insieme agli stili, <i class=baa>&amp;</i>c. Le persone leggevano questi documenti con gli stessi programmi di word processing dell'autore orginale, così ogni cosa funzionava, più o meno.

<p>Considerate ora l'avvento di reti globali come l'email e il web. Un sacco di &#8220;testo semplice&#8221; svolazzante per il globo, scritto su un computer, trasmesso attraverso un secondo computer, e ricevuto e visualizzato da un terzo computer. I computer possono vedere solo numeri, ma i numeri potrebbero significare cose diverse. Oh no! Cosa fare? I sistemi dovettero essere progettati per trasportare le informazioni di codifica insieme a ogni frammento di &#8220;testo semplice.&#8221; Ricordate, è la chiave di decrittazione che fa corrispondere i numeri leggibili dal computer ai caratteri leggibili dalle persone. Una chiave di decrittazione mancante significa testo rovinato, spazzatura, o peggio.

<p>Considerate ora il tentativo di memorizzare molti frammenti di testo nello stesso luogo, come nella stessa tabella di un database che mantiene tutte le email che avete mai ricevuto. Avete ancora bisogno di archiviare la codifica di carattere insieme a ogni frammento di testo in modo da poterlo visualizzare correttamente. Pensate sia difficile? Provate a fare una ricerca nel vostro database di posta elettronica, il che significa effettuare conversioni tra codifiche multiple al volo. Non suona divertente?

<p>Ora considerate la possibilità di documenti scritti in più lingue, dove i caratteri presi da diverse lingue sono uno a fianco dell'altro nello stesso documento. (Suggerimento: i programmi che provavano a farlo tipicamente usavano codici di escape per passare da una &#8220;modalità&#8221; all'altra. Poof, eccovi in modalità russa koi8-r, quindi 241 rappresenta questo carattere; poof, ora siete in modalità Mac Greek, quindi 241 rappresenta un qualche altro carattere.) E naturalmente vorrete effettuare ricerche anche su <em>quei</em> documenti.

<p>E ora piangete pure, perché tutto quello che pensavate di sapere sulle stringhe è sbagliato, e non esiste alcuna cosa come il &#8220;testo semplice.&#8221;

<h2 id=one-ring-to-rule-them-all>Unicode</h2>

<p><i>Entra Unicode.</i>

<p>Unicode è un sistema progettato per rappresentare <em>qualsiasi</em> carattere da <em>qualsiasi</em> lingua. Unicode rappresenta ogni lettera, carattere, o ideogramma come un numero di 4 byte, da 0 a 4294967295. (Quest'ultimo è il valore di 2<sup>32</sup>&minus;1.) Ogni numero di 4 byte rappresenta un carattere unico usato in almeno una delle lingue del mondo. Non tutti i numeri sono utilizzati, ma più di 65535 lo sono, quindi 2 byte non sarebbero stati sufficienti. I caratteri che sono usati in più di una lingua hanno generalmente lo stesso numero, a meno che non ci sia una buona ragione etimologica per non farlo. In ogni caso, c'è esattamente 1 numero per carattere, ed esattamente 1 carattere per numero. Ogni numero significa sempre solo una cosa; non ci sono &#8220;modalità&#8221; di cui tenere traccia. <code>U+0041</code> è sempre <code>'A'</code>, anche se la vostra lingua non possiede alcuna <code>'A'</code>.

<p>A prima vista, sembra una grande idea. Una codifica per governarle tutte. Lingue multiple per documento. Niente più &#8220;passaggi di modalità&#8221; per cambiare una codifica a metà del testo. Ma immediatamente l'ovvia domanda dovrebbe saltarvi alla mente. Quattro byte? Per ogni singolo carattere<span title="interrobang!">&#8253;</span> Sembra uno spreco orrendo, specialmente per lingue come l'inglese e lo spagnolo, che necessitano di meno di un byte (256 numeri) per esprimere ogni possibile carattere. In effetti, è uno spreco persino per lingue basate su ideogrammi (come il cinese) che non hanno mai bisogno di più di due byte per carattere.

<p>C'è una codifica Unicode che usa quattro byte per carattere. &Egrave; chiamata UTF-32, perché 32 bit = 4 byte. UTF-32 è la codifica più semplice; prende ogni carattere Unicode (un numero di 4 byte) e rappresenta il carattere con quello stesso numero. Questo ha alcuni vantaggi, di cui il più importante è la possibilità di accedere al carattere di posizione <var>N</var> in una stringa in tempo costante, perché il carattere in posizione <var>N</var> comincia al byte di posizione <var>4&times;N</var>. Ha anche diversi svantaggi, tra i quali il più ovvio è la necessità di quattro maledetti byte per memorizzare ogni maledetto carattere.

<p>Anche se ci sono un sacco di caratteri Unicode, viene fuori che la maggior parte delle persone non ne userà nessuno al di là dei primi 65535. Quindi, esiste un'altra codifica Unicode, chiamata UTF-16 (perché 16 bit = 2 byte). UTF-16 codifica ogni carattere tra 0 e 65535 come due byte, e poi usa un qualche sporco trucco se dovete effettivamente rappresentare i caratteri Unicode rari che si trovano nel &#8220;piano astrale&#8221; al di là di 65535. Il vantaggio più ovvio: UTF-16 ha una efficienza in spazio che è il doppio rispetto a UTF-32, perché ogni carattere richiede solo due byte da memorizzare invece di quattro byte (a parte quelli per cui non è così). E potete ancora accedere facilmente al carattere di posizione <var>N</var> in una stringa in tempo costante, se assumete che la stringa non include alcun carattere dal piano astrale, che è una buona assunzione fino al momento in cui non lo è più.

<p>Ma ci sono anche altri svantaggi non banali sia di UTF-32 che di UTF-16. Sistemi computerizzati differenti memorizzano i singoli byte in modi differenti. Questo significa che il carattere <code>U+4E2D</code> potrebbe essere memorizzato in UTF-16 come <code>4E 2D</code> oppure <code>2D 4E</code>, a seconda che il sistema sia di tipo big-endian o little-endian. (Per UTF-32 ci sono ancora più ordinamenti di byte possibili.) Fino a quando i vostri documenti non lasciano mai il vostro computer, siete al sicuro &mdash; applicazioni differenti sullo stesso computer utilizzeranno sempre lo stesso ordine dei byte. Ma nel momento in cui volete trasferire documenti tra sistemi, forse su un qualche tipo di world wide web, avrete bisogno di un modo per indicare in quale ordine i vostri byte sono memorizzati. Altrimenti, il sistema ricevente non ha alcun modo di sapere se la sequenza di due byte <code>4E 2D</code> rappresenta <code>U+4E2D</code> oppure <code>U+2D4E</code>.

<p>Per risolvere <em>questo</em> problema, le codifiche Unicode multi-byte definiscono un &#8220;Byte Order Mark,&#8221; che uno speciale carattere non stampabile che potete includere all'inizio del vostro documento per indicare in quale ordine sono i vostri byte. Per UTF-16, il Byte Order Mark è <code>U+FEFF</code>. Se ricevete un documento UTF-16 che comincia con i byte <code>FF FE</code>, sapete che l'ordine dei byte va in una certa direzione; se comincia con <code>FE FF</code>, sapete che l'ordine dei byte è quello inverso.

<p>Tuttavia, UTF-16 non è esattamente l'ideale, specialmente se avete a che fare con un sacco di caratteri <abbr>ASCII</abbr>. Se ci pensate, persino una pagina web cinese conterrà un sacco di caratteri <abbr>ASCII</abbr> &mdash; tutti gli elementi e gli attributi che circondano i caratteri stampabili cinesi. Essere in grado di accedere al carattere di posizione <var>N</var> in tempo O(1) è carino, ma rimane ancora l'irritante problema di quei caratteri del piano astrale, il che significa che non potete <em>garantire</em> che ogni carattere sia esattamente due byte, e quindi non potete <em>davvero</em> accedere al carattere di posizione <var>N</var> in tempo O(1) a meno che non manteniate un indice separato. E ragazzi, c'è sicuramente un sacco di testo <abbr>ASCII</abbr> nel mondo&hellip;

<p>Altre persone hanno ponderato queste domande, e sono venuti fuori con una soluzione:

<p class=c style="font-size:1000%;font-weight:bold;line-height:1;margin:0.7em 0">UTF-8

<p>UTF-8 è un sistema di codifica Unicode a <em>lunghezza variabile</em>. Cioè, caratteri differenti occupano un numero differente di byte. Per i caratteri <abbr>ASCII</abbr> (A-Z, <i class=baa>&amp;</i>c.) UTF-8 usa solo un byte per carattere. In effetti, usa gli stessi identici byte; i primi 128 caratteri (0&ndash;127) in UTF-8 sono indistinguibili da quelli <abbr>ASCII</abbr>. I caratteri &#8220;Extended Latin&#8221; come &ntilde; e &ouml; finiscono per prendere due byte. (I byte non sono semplicemente dei &#8220;code point&#8221; Unicode come sarebbero in UTF-16; c'è qualche serio giochetto con i bit coinvolto.) Caratteri cinesi come &#x4E2D; finiscono per prendere tre byte. I caratteri raramente usati del &#8220;piano astrale&#8221; prendono quattro byte.

<p>Svantaggi: dato che ogni carattere può prendere un numero differente di byte, accedere al carattere di posizione <var>N</var> è una operazione da O(N). In più, c'è qualche giochetto con i bit da fare per codificare i caratteri in byte e decodificare i byte in caratteri.

<p>Vantaggi: la codifica dei caratteri <abbr>ASCII</abbr> comuni è super-efficiente. Per i caratteri Extended Latin non è peggiore rispetto alla codifica UTF-16, e per i caratteri cinesi è migliore rispetto a UTF-32. In più (e dovete fidarvi di me su questo, perché non vi mostrerò i calcoli), grazie alla natura esatta dei giochetti con i bit, non ci sono problemi di ordinamento dei byte. Un documento codificato in UTF-8 usa esattamente lo stesso flusso di byte su qualsiasi computer.

<h2 id=divingin>Immersione!</h2>

<p>In Python 3, tutte le stringhe sono sequenze di caratteri Unicode. Non c'è nulla come una stringa Python codificata in UTF-8, o una stringa Python codificata in CP-1252. "Questa stringa è in UTF-8?" è una domanda non valida. UTF-8 è il modo di codificare caratteri come sequenze di byte. Se volete prendere una stringa e trasformarla in una sequenza di byte in una particolare codifica di carattere, Python 3 vi può aiutare con quello. Se volete prendere una sequenza di byte e trasformarla in una stringa, Python 3 può aiutarvi anche con quello. I byte non sono caratteri; i byte sono byte. I caratteri sono una astrazione. Una stringa è una sequenza di quelle astrazioni.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>s = '深入 Python'</kbd>    <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>len(s)</kbd>               <span>&#x2461;</span></a>
<samp>9</samp>
<a><samp class=p>>>> </samp><kbd>s[0]</kbd>                 <span>&#x2462;</span></a>
<samp>'深'</samp>
<a><samp class=p>>>> </samp><kbd>s + ' 3'</kbd>             <span>&#x2463;</span></a>
<samp>'深入 Python 3'</samp></pre>
<ol>
<li>Per creare una stringa, racchiudetela tra virgolette. Le stringhe Python possono essere definite con apici (<code>'</code>) o con virgolette (<code>"</code>).<!--"-->
<li>La funzione built-in <code>len()</code> restituisce la lunghezza della stringa, <i>i.e.</i> il numero di caratteri. Questa è la stessa funzione che utilizzate per <a href=tipi-di-dato-nativi.html#extendinglists>trovare la lunghezza di una lista</a>. Una stringa è come una lista di caratteri.
<li>Esattamente come ottenere singoli elementi da una lista, potete ottenere singoli caratteri da una stringa usando la notazione a indice.
<li>Esattamente come con le liste, potete concatenare le stringhe utilizzando l'operatore <code>+</code>.
</ol>

<h2 id=formatting-strings>Formattare le stringhe</h2>

<aside>Le stringhe possono essere definite con apici o con virgolette.</aside>
<p>Diamo un'altra occhiata a <a href=il-vostro-primo-programma-python.html#divingin><code>humansize.py</code></a>:

<p class=d>[<a href=esempi/humansize.py>scarica <code>humansize.py</code></a>]
<pre><code>
<a>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],         <span>&#x2460;</span></a>
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}

def approximate_size(size, a_kilobyte_is_1024_bytes=True):
<a>    """Convert a file size to human-readable form.                          <span>&#x2461;</span></a>

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

<a>    """                                                                     <span>&#x2462;</span></a>
    if size &lt; 0:
<a>        raise ValueError('number must be non-negative')                     <span>&#x2463;</span></a>

    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size &lt; multiple:
<a>            return "{0:.1f} {1}".format(size, suffix)                       <span>&#x2464;</span></a>

    raise ValueError('number too large')</code></pre>
<ol>
<li><code>'KB'</code>, <code>'MB'</code>, <code>'GB'</code>&hellip; ognuna di quelle è una stringa.
<li>Le docstring di una funzione sono stringhe. Questa docstring si estende su più righe, e quindi usa tre virgolette consecutive all'inizio e alla fine della stringa.
<li>Queste tre virgolette consecutive concludono la docstring.
<li>C'è un'altra stringa, passata alla eccezione come un messaggio di errore.
<li>C'è una&hellip; whoa, che diavolo è quello?
</ol>

<p>Python 3 supporta la formattazione di valori in stringhe. Sebbene questo possa includere espressioni molto complicate, l'uso più basilare consiste nell'inserire un valore in una stringa con un singolo segnaposto.

<pre class=screen>
<samp class=p>>>> </samp><kbd>username = "mark"</kbd>
<a><samp class=p>>>> </samp><kbd>password = "PapayaWhip"</kbd>                             <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>"{0}'s password is {1}".format(username, password)</kbd>  <span>&#x2461;</span></a>
<samp>"mark's password is PapayaWhip"</samp></pre>
<ol>
<li>No, la mia password non è davvero <kbd>PapayaWhip</kbd>.
<li>C'è un sacco che sta succedendo qui. Per prima cosa, c'è una chiamata di metodo su un letterale stringa. <em>Le stringhe sono oggetti</em>, e gli oggetti hanno metodi. Secondo, l'intera espressione viene valutata come una stringa. Terzo, <code>{0}</code> e <code>{1}</code> sono <i>campi di sostituzione</i>, che vengono rimpiazzati dagli argomenti passati al metodo <code>format()</code>.
</ol>

<h3 id=compound-field-names>Nomi di campo composti</h3>

<p>L'esempio precedente mostra il caso più semplice, dove i campi di sostituzione sono semplicemente interi. I campi di sostituzione interi sono trattati come indici della posizione nella lista di argomenti del metodo <code>format()</code>. Questo significa che <code>{0}</code> è rimpiazzato dal primo argomento (<var>username</var> in questo caso), <code>{1}</code> è rimpiazzato dal secondo argomento (<var>password</var>) <i class=baa>&amp;</i>c. Potete avere tanti indici posizionali quanti sono gli argomenti, e potete avere tanti argomenti quanti ne volete. Ma i campi di sostituzione sono molto più potenti di così.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd>si_suffixes = humansize.SUFFIXES[1000]</kbd>      <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>si_suffixes</kbd>
<samp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd>"1000{0[0]} = 1{0[1]}".format(si_suffixes)</kbd>  <span>&#x2461;</span></a>
<samp>'1000KB = 1MB'</samp>
</pre>
<ol>
<li>Invece di chiamare una funzione qualsiasi nel modulo <code>humansize</code>, state recuperando una delle strutture dati che il modulo definisce: la lista dei suffissi "SI" (potenze-di-1000).
<li>Questo sembra complicato, ma non lo è. <code>{0}</code> si riferirebbe al primo argomento passato al metodo <code>format()</code>, <var>si_suffixes</var>. Ma <var>si_suffixes</var> è una lista. Così <code>{0[0]}</code> si riferisce al primo elemento della lista che è il primo argomento passato al metodo <code>format()</code>: <code>'KB'</code>. Nel frattempo, <code>{0[1]}</code> si riferisce al secondo elemento della stessa lista: <code>'MB'</code>. Ogni cosa fuori dalle parentesi graffe &mdash; compreso <code>1000</code>, il segno di uguale, e gli spazi &mdash; non viene toccato. Il risultato finale è la stringa <code>'1000KB = 1MB'</code>.
</ol>

<aside>{0} è sostituito dal 1° argomento di format(). {1} è sostituito dal 2°.</aside>
<p>Questo esempio mostra che <em>gli specificatori di formato possono accedere elementi e proprietà di una struttura dati usando (quasi) la stessa sintassi di Python</em>. Questo si chiama <i>nomi di campo composti</i>. I seguenti nomi di campo composti funzionano:

<ul>
<li>Passare una lista, e accedere a un elemento della lista tramite indice (come nell'esempio precedente)
<li>Passare un dizionario, e accedere a un valore del dizionario tramite chiave
<li>Passare un modulo, e accedere alle sue variabili e funzioni tramite nome
<li>Passare una istanza di una classe, e accedere alle sue proprietà e metodi tramite nome
<li><em>Una qualsiasi combinazione dei nomi precedenti</em>
</ul>

<p>Giusto per farvi uscire di testa, eccovi un esempio che combina tutti i nomi appena visti:

<pre class=screen>
<samp class=p>>>> </samp><kbd>import humansize</kbd>
<samp class=p>>>> </samp><kbd>import sys</kbd>
<samp class=p>>>> </samp><kbd>"1MB = 1000{0.modules[humansize].SUFFIXES[1000][0]}".format(sys)</kbd>
<samp>'1MB = 1000KB'</samp></pre>

<p>Funziona in questo modo:

<ul>
<li>Il modulo <code>sys</code> mantiene informazioni sulla istanza di Python attualmente in esecuzione. Visto che lo avete importato, potete passare il modulo <code>sys</code> stesso come un argomento al metodo <code>format()</code>. Quindi il campo di sostituzione <code>{0}</code> si riferisce al modulo <code>sys</code>.
<li><code>sys.modules</code> è un dizionario di tutti i moduli che sono stati importati in questa istanza di Python. Le chiavi sono i nomi dei moduli sotto forma di stringhe; i valori sono gli oggetti modulo stessi. Quindi il campo di sostituzione <code>{0.modules}</code> si riferisce al dizionario dei moduli importati.
<li><code>sys.modules["humansize"]</code> è il modulo <code>humansize</code> che avete appena importato. Il campo di sostituzione <code>{0.modules[humansize]}</code> si riferisce al modulo <code>humansize</code>. Notate la leggera differenza nella sintassi. In vero codice Python, le chiavi del dizionario <code>sys.modules</code> sono stringhe; per riferirsi ad esse, avete bisogno di mettere le virgolette attorno al nome del modulo (<i>e.g.</i> <code>"humansize"</code>). Ma nell'ambito di un campo di sostituzione tralasciate le virgolette attorno al nome della chiave del dizionario (<i>e.g.</i> <code>humansize</code>).
<li><code>sys.modules["humansize"].SUFFIXES</code> è il dizionario definito all'inizio del modulo <code>humansize</code>. Il campo di sostituzione <code>{0.modules[humansize].SUFFIXES}</code> si riferisce a quel dizionario.
<li><code>sys.modules["humansize"].SUFFIXES[1000]</code> è una lista di suffissi <abbr>SI</abbr>: <code>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</code>. Quindi il campo di sostituzione <code>{0.modules[humansize].SUFFIXES[1000]}</code> si riferisce a quella lista.
<lI><code>sys.modules["humansize"].SUFFIXES[1000][0]</code> è il primo elemento nella lista dei suffissi <abbr>SI</abbr>: <code>'KB'</code>. Quindi, il campo di sostituzione completo <code>{0.modules[humansize].SUFFIXES[1000][0]}</code> è rimpiazzato dalla stringa di due caratteri <code>KB</code>.
</ul>

<h3 id=format-specifiers>Specificatori di formato</h3>

<p>Ma aspettate! C'è di più! Diamo un'altra occhiata a quella strana linea di codice in <code>humansize.py</code>:

<pre><code>if size &lt; multiple:
    return "{0:.1f} {1}".format(size, suffix)</code></pre>

<p><code>{1}</code> viene rimpiazzato dal secondo argomento passato al metodo <code>format()</code>, che è <var>suffix</var>. Ma che cos'è <code>{0:.1f}</code>? &Egrave; due cose: <code>{0}</code>, che riconoscerete, e <code>:.1f</code>, che non riconoscerete. La seconda metà (dai due punti in poi compresi) definisce uno <i>specificatore di formato</i>, che raffina ulteriormente il modo in cui la variabile rimpiazzata dovrà essere formattata.

<blockquote class="note compare clang">
<p><span>&#x261E;</span>Gli specificatori di formato vi permettono di manipolare il testo di sostituzione in una varietà di modi utili, come la funzione <code>printf</code> in C. Potete aggiungere blocchi di zeri o spazi, allineare stringhe, controllare la precisione dei decimali, e persino convertire numeri in esadecimali.
</blockquote>

<p>Nell'ambito di un campo di sostituzione, i due punti (<code>:</code>) segnano l'inizio dello specificatore di formato. Lo specificatore di formato &#8220;<code>.1</code>&#8221; significa &#8220;arrotonda al decimale più vicino&#8221; (<i>i.e.</i> mostra solo una cifra dopo il punto decimale). Lo specificatore di formato &#8220;<code>f</code>&#8221; significa &#8220;numero in virgola fissa&#8221; (al contrario della notazione esponenziale o di qualche altra rappresentazione decimale). Quindi, data una dimensione <var>size</var> di <code>698.25</code> e un suffisso <var>suffix</var> di <code>'GB'</code>, la stringa formattata diventerà <code>'698.3 GB'</code>, perché <code>698.25</code> viene arrotondato alla prima cifra decimale, e il suffisso è appeso dopo il numero.

<pre class=screen>
<samp class=p>>>> </samp><kbd>"{0:.1f} {1}".format(698.25, 'GB')</kbd>
<samp>'698.3 GB'</samp></pre>

<p>Per tutti i dettagli cruenti sugli specificatori di formato, consultate la sezione <a href="http://docs.python.org/3.0/library/string.html#format-specification-mini-language">Format Specification Mini-Language</a> nella documentazione ufficiale di Python.

<h2 id=common-string-methods>Altri metodi di uso comune per le stringhe</h2>

<p>Oltre alla formattazione, le stringhe possono fare un numero di altri utili trucchi.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>s = """Finished files are the re-</kbd>  <span>&#x2460;</span></a>
<samp class=p>... </samp><kbd>sult of years of scientif-</kbd>
<samp class=p>... </samp><kbd>ic study combined with the</kbd>
<samp class=p>... </samp><kbd>experience of years."""</kbd>
<a><samp class=p>>>> </samp><kbd>s.splitlines()</kbd>                     <span>&#x2461;</span></a>
<samp>['Finished files are the re-',
 'sult of years of scientif-',
 'ic study combined with the',
 'experience of years.']</samp>
<a><samp class=p>>>> </samp><kbd>print(s.lower())</kbd>                   <span>&#x2462;</span></a>
<samp>finished files are the re-
sult of years of scientif-
ic study combined with the
experience of years.</samp>
<a><samp class=p>>>> </samp><kbd>s.lower().count("f")</kbd>               <span>&#x2463;</span></a>
<samp>6</samp></pre>
<ol>
<li>Potete introdurre stringhe su più righe nella shell interattiva di Python. Una volta che avete cominciato una stringa su più righe con le triple virgolette, vi basta premere <kbd>ENTER</kbd> e la shell interattiva vi permetterà di continuare la stringa. Scrivere le triple virgolette di chiusura termina la stringa, e il successivo <kbd>ENTER</kbd> eseguirà il comando (in questo caso, l'assegnamento della stringa a <var>s</var>).
<li>Il metodo <code>splitlines()</code> prende una stringa multi-riga e restituisce una lista di stringhe, una per ogni riga di quella originale. Notate che i caratteri di a capo alla fine di ogni linea non sono inclusi.
<li>Il metodo <code>lower()</code> converte l'intera stringa in minuscolo. (Similmente, il metodo <code>upper()</code> converte una stringa in maiuscolo.) 
<li>Il metodo <code>count()</code> conta il numero di occorrenze di una sottostringa. Sì, ci sono davvero sei &#8220;f&#8221; in quella frase!
</ol>

<p>Ecco un altro caso comune. Diciamo che avete una lista di coppie chiavi-valori nella forma <code><var>key1</var>=<var>value1</var>&amp;<var>key2</var>=<var>value2</var></code>, e volete separarle e creare un dizionario della forma <code>{key1: value1, key2: value2}</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd>query = 'user=pilgrim&amp;database=master&amp;password=PapayaWhip'</kbd>
<a><samp class=p>>>> </samp><kbd>a_list = query.split('&amp;')</kbd>                            <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp>['user=pilgrim', 'database=master', 'password=PapayaWhip']</samp>
<a><samp class=p>>>> </samp><kbd>a_list_of_lists = [v.split('=', 1) for v in a_list]</kbd>  <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>a_list_of_lists</kbd>
<samp>[['user', 'pilgrim'], ['database', 'master'], ['password', 'PapayaWhip']]</samp>
<a><samp class=p>>>> </samp><kbd>a_dict = dict(a_list_of_lists)</kbd>                       <span>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>a_dict</kbd>
<samp>{'password': 'PapayaWhip', 'user': 'pilgrim', 'database': 'master'}</samp></pre>

<ol>
<li>Il metodo <code>split()</code> per le stringhe prende un argomento, un delimitatore, e separa la stringa in una lista di stringhe basandosi sul delimitatore. In questo caso, il delimitatore è un carattere di ampersand, ma potrebbe essere qualsiasi cosa.
<li>Ora che abbiamo una lista di stringhe, ognuna con una chiave, seguita da un segno di uguale, seguito da un valore. Vogliamo iterare sull'intera lista e seprarare ogni stringa in due stringhe basandoci sul primo segno di uguale. (In teoria, anche un valore potrebbe contenere un segno di uguale. Se avessimo usato <code>'key=value=foo'.split('=')</code>, avremmo ottenuto una lista di tre elementi, <code>['key', 'value', 'foo']</code>.)
<li>Infine, Python può trasformare quella lista-di-liste in un dizionario semplicemente passandola alla funzione <code>dict()</code>.
</ol>

<h2 id=byte-arrays>Stringhe vs. byte</h2>

<p>I byte sono byte; i caratteri sono una astrazione. Una sequenza immutabile di caratteri Unicode è chiamata una <i>stringa</i>. Una sequenza immutabile di numeri-tra-0-e-255 è chiamata un oggetto di classe <i>bytes</i>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>by = b'abcd\x65'</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>by</kbd>
<samp>b'abcde'</samp>
<a><samp class=p>>>> </samp><kbd>type(by)</kbd>          <span>&#x2461;</span></a>
<samp>&lt;class 'bytes'></samp>
<a><samp class=p>>>> </samp><kbd>len(by)</kbd>           <span>&#x2462;</span></a>
<samp>5</samp>
<a><samp class=p>>>> </samp><kbd>by += b'\xff'</kbd>     <span>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd>by</kbd>
<samp>b'abcde\xff'</samp>
<a><samp class=p>>>> </samp><kbd>len(by)</kbd>           <span>&#x2464;</span></a>
<samp>6</samp>
<a><samp class=p>>>> </samp><kbd>by[0]</kbd>             <span>&#x2465;</span></a>
<samp>97</samp>
<a><samp class=p>>>> </samp><kbd>by[0] = 102</kbd>       <span>&#x2466;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'bytes' object does not support item assignment</samp></pre>
<ol>
<li>Per definire un oggetto <code>bytes</code>, usate la sintassi <code>b''</code> per i &#8220;letterali byte&#8221;. Ogni byte nel letterale byte può essere un carattere <abbr>ASCII</abbr> o un numero esadecimale codificato da <code>\x00</code> a <code>\xff</code> (0&ndash;255).
<li>Il tipo di un oggetto <code>bytes</code> è <code>bytes</code>.
<li>Esattamente come le liste e le stringhe, potete ottenere la lunghezza di un oggetto <code>bytes</code> con la funzione built-in <code>len()</code>.
<li>Esattamente come le liste e le stringhe, potete usare l'operatore <code>+</code> per concatenare oggetti <code>bytes</code>. Il risultato è un nuovo oggetto <code>bytes</code>.
<li>Concatenare un oggetto <code>bytes</code> di 5 byte e un oggetto <code>bytes</code> di 1 byte ha come risultato un oggetto <code>bytes</code> di 6 byte.
<li>Esattamente come le liste e le stringhe, potete usare la notazione a indici per ottenere i singoli byte in un oggetto <code>bytes</code>. Gli elementi di una stringa sono stringhe; gli elementi di un oggetto <code>bytes</code> sono interi. Nello specifico, interi tra 0 e 255.
<li>Un oggetto <code>bytes</code> è immutabile; non potete assegnare singoli byte. Se avete bisogno di cambiare i singoli byte, potete usare i metodi per affettare (che funzionano allo stesso modo delle stringhe) e gli operatori di concatenazione (che funzionano anche loro allo stesso modo delle stringhe), oppure potete convertire l'oggetto <code>byte</code> in un oggetto <code>bytearray</code>.
</ol>

<pre class=screen>
<samp class=p>>>> </samp><kbd>by = b'abcd\x65'</kbd>
<a><samp class=p>>>> </samp><kbd>barr = bytearray(by)</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>barr</kbd>
<samp>bytearray(b'abcde')</samp>
<a><samp class=p>>>> </samp><kbd>len(barr)</kbd>             <span>&#x2461;</span></a>
<samp>5</samp>
<a><samp class=p>>>> </samp><kbd>barr[0] = 102</kbd>         <span>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>barr</kbd>
<samp>bytearray(b'fbcde')</samp></pre>
<ol>
<li>Per convertire un oggetto <code>bytes</code> in un oggetto <code>bytearray</code> modificabile, usate la funzione built-in <code>bytearray()</code>.
<li>Tutti i metodi e le operazioni che si possono eseguire su un oggetto <code>bytes</code>, si possono eseguire anche su un oggetto <code>bytearray</code>.
<li>L'unica differenza è che, con un oggetto <code>bytearray</code>, potete assegnare i singoli byte utilizzando la notazione a indici. Il valore assegnato deve essere un intero tra 0 e 255.
</ol>

<p>L'unica cosa che <em>non potete mai fare</em> è mescolare stringhe e byte.

<pre class=screen>
<samp class=p>>>> </samp><kbd>by = b'd'</kbd>
<samp class=p>>>> </samp><kbd>s = 'abcde'</kbd>
<a><samp class=p>>>> </samp><kbd>by + s</kbd>                       <span>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: can't concat bytes to str</samp>
<a><samp class=p>>>> </samp><kbd>s.count(by)</kbd>                  <span>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: Can't convert 'bytes' object to str implicitly</samp>
<a><samp class=p>>>> </samp><kbd>s.count(by.decode('ascii'))</kbd>  <span>&#x2462;</span></a>
<samp>1</samp></pre>
<ol>
<li>Non potete concatenare stringhe e byte. Sono due tipi di dati differenti.
<li>Non potete contare le occorrenze di byte in una stringa, perché non c'è alcun byte in una stringa. Una stringa è una sequenza di caratteri. Forse intendevate &#8220;conta le occorrenze della stringa che si otterrebbe dopo aver decodificato questa sequenza di byte in una particolare codifica di caratteri&#8221;? Ebbene, allora, dovete dirlo esplicitamente. Python 3 non convertirà implicitamente byte in stringhe o stringhe in byte.
<li>Per una sorprendente coincidenza, questa riga di codice dice &#8220;conta le occorrenze della stringa che si otterrebbe dopo aver decodificato questa sequenza di byte in una particolare codifica di caratteri.&#8221;
</ol>

<p>Ed ecco il collegamento tra stringhe e byte: gli oggetti <code>bytes</code> hanno un metodo <code>decode()</code> che prende una codifica di caratteri e restituisce una stringa, e le stringhe hanno un metodo <code>encode()</code> che prende una codifica di caratteri e restituisce un oggetto <code>bytes</code>. Nell'esempio precedente, la decodifica era relativamente semplice &mdash; convertire una sequenza di byte in codifica <abbr>ASCII</abbr> in una stringa di caratteri. Ma lo stesso processo funziona con qualsiasi codifica che supporti i caratteri della stringa &mdash; persino codifiche legacy (non Unicode).

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>a_string = '深入 Python'</kbd>         <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>len(a_string)</kbd>
<samp>9</samp>
<a><samp class=p>>>> </samp><kbd>by = a_string.encode('utf-8')</kbd>    <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>by</kbd>
<samp>b'\xe6\xb7\xb1\xe5\x85\xa5 Python'</samp>
<samp class=p>>>> </samp><kbd>len(by)</kbd>
<samp>13</samp>
<a><samp class=p>>>> </samp><kbd>by = a_string.encode('gb18030')</kbd>  <span>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>by</kbd>
<samp>b'\xc9\xee\xc8\xeb Python'</samp>
<samp class=p>>>> </samp><kbd>len(by)</kbd>
<samp>11</samp>
<a><samp class=p>>>> </samp><kbd>by = a_string.encode('big5')</kbd>     <span>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd>by</kbd>
<samp>b'\xb2`\xa4J Python'</samp>
<samp class=p>>>> </samp><kbd>len(by)</kbd>
<samp>11</samp>
<a><samp class=p>>>> </samp><kbd>roundtrip = by.decode('big5')</kbd>    <span>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd>roundtrip</kbd>
<samp>'深入 Python'</samp>
<samp class=p>>>> </samp><kbd>a_string == roundtrip</kbd>
<samp>True</samp></pre>
<ol>
<li>Questa è una stringa. Ha nove caratteri.
<li>Questo è un oggetto <code>bytes</code>. Ha 13 byte. &Egrave; la sequenza di byte che si ottiene codificando <var>a_string</var> in UTF-8.
<li>Questo è un oggetto <code>bytes</code>. Ha 11 byte. &Egrave; la sequenza di byte che si ottiene codificando <var>a_string</var> in GB18030.
<li>Questo è un oggetto <code>bytes</code>. Ha 11 byte. &Egrave; una <em>sequenza completamente diversa di byte</em> che si ottiene codificando <var>a_string</var> con l'algoritmo di codifica Big5.
<li>Questa è una stringa. Ha nove caratteri. &Egrave; la sequenza di caratteri che si ottiene decodificando <var>by</var> con l'algoritmo di codifica Big5. &Egrave; identica alla stringa originale.
</ol>

<!--
FIXME: move this to the intro of the upcoming files chapter?
<p>OK, so a string is a sequence of Unicode characters. But a file on disk is not a sequence of Unicode characters; a file on disk is a sequence of bytes. So if you read a &#8220;text file&#8221; from disk, how does Python convert that sequence of bytes into a sequence of characters? The answer is that it decodes the bytes according to a specific character encoding algorithm, and returns a sequence of Unicode characters, otherwise known as a string.
-->

<h2 id=py-encoding>Post Scriptum: codifica di caratteri per il codice sorgente Python</h2>

<p>Python 3 assume che il vostro codice sorgente &mdash; <i>i.e.</i> ogni file <code>.py</code> &mdash; sia codificato in UTF-8.

<blockquote class="note compare python2">
<p><span>&#x261E;</span>In Python 2, la codifica di default per i file <code>.py</code> era <abbr>ASCII</abbr>. In Python 3, <a href="http://www.python.org/dev/peps/pep-3120/">la codifica di default è UTF-8</a>.
</blockquote>

<p>Se volete usare una codifica differente nel vostro codice Python, potete inserire una dichiarazione di codifica nella prima riga di ogni file. Questa dichiarazione dichiara essere windows-1252 la codifica di un file <code>.py</code>

<pre><code># -*- coding: windows-1252 -*-</code></pre>

<p>Tecnicamente, la modifica della codifica di carattere si può trovare anche sulla seconda riga, se la prima riga è un comando hash-bang di tipo <abbr>UNIX</abbr>.

<pre><code>#!/usr/bin/python3
# -*- coding: windows-1252 -*-</code></pre>

<p>Per maggiori informazioni, si consulti <a href="http://www.python.org/dev/peps/pep-0263/"><abbr>PEP</abbr> 263: Defining Python Source Code Encodings</a>.

<h2 id=furtherreading>Letture di approfondimento</h2>

<p>Su Unicode in Python:

<ul>
<li><a href="http://docs.python.org/3.0/howto/unicode.html">Python Unicode HOWTO</a>
<li><a href="http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit">What's New In Python 3: Text vs. Data Instead Of Unicode vs. 8-bit</a>
</ul>

<p>Su Unicode in generale:

<ul>
<li><a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a>
<li><a href="http://www.tbray.org/ongoing/When/200x/2003/04/06/Unicode">On the Goodness of Unicode</a>
<li><a href="http://www.tbray.org/ongoing/When/200x/2003/04/13/Strings">On Character Strings</a>
<li><a href="http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF">Characters vs. Bytes</a>
</ul>

<p>Sulle codifiche di carattere in altri formati:

<ul>
<li><a href="http://feedparser.org/docs/character-encoding.html">Character encoding in XML</a>
<li><a href="http://blog.whatwg.org/the-road-to-html-5-character-encoding">Character encoding in HTML</a>
</ul>

<p>Sulle stringhe e sulla formattazione di stringhe:

<ul>
<li><a href="http://docs.python.org/3.0/library/string.html"><code>string</code> &mdash; Common string operations</a>
<li><a href="http://docs.python.org/3.0/library/string.html#formatstrings">Format String Syntax</a>
<li><a href="http://docs.python.org/3.0/library/string.html#format-specification-mini-language">Format Specification Mini-Language</a>
<li><a href="http://www.python.org/dev/peps/pep-3101/"><abbr>PEP</abbr> 3101: Advanced String Formatting</a>
</ul>

<p class=nav><a rel=prev href=tipi-di-dato-nativi.html title="Vai indietro a &#8220;Tipi di dato nativi&#8221;"><span>&#x261C;</a> <a rel=next href=espressioni-regolari.html title="Vai avanti a &#8220;Espressioni regolari&#8221;"><span>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;9 <a href=about.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
