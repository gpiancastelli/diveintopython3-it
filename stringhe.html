<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Stringhe - Dive into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<link rel=stylesheet href=dip3-it.css>
<style>
body{counter-reset:h1 3}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#strings>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>Livello di difficoltà: <span class=u title=intermedio>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Stringhe</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Ti dico questo in nome della nostra amicizia.<br>
Il tuo alfabeto termina dove il mio inizia! <span class=u>&#x275E;</span><br>&mdash; Dr. Seuss, On Beyond Zebra!
</blockquote>
<p id=toc>&nbsp;
<h2 id=boring-stuff>Alcune cose noiose che avete bisogno di sapere prima di potervi immergere</h2>
<p class=f>Sapevate che la popolazione di <a href=http://en.wikipedia.org/wiki/Bougainville_Province>Bougainville</a> ha il più piccolo alfabeto del mondo? Il loro <a href=http://en.wikipedia.org/wiki/Rotokas_alphabet>alfabeto Rotokas</a> è composto da sole 12 lettere: A, E, G, I, K, O, P, R, S, T, U, e V. All'altra estremità dello spettro, lingue come il cinese, il giapponese e il coreano hanno migliaia di caratteri. L'inglese, ovviamente, ha 26 lettere&nbsp;&mdash;&nbsp;52 se contate le maiuscole e le minuscole separatamente&nbsp;&mdash;&nbsp;più una manciata di <i class=baa>!@#$%&</i> simboli di punteggiatura.

<p>Quando alcune persone parlano di &#8220;testo,&#8221; stanno pensando a &#8220;caratteri e simboli su uno schermo di computer.&#8221; Ma i computer non si occupano di caratteri e simboli; i computer maneggiano bit e byte. Ogni frammento di testo che avete mai visto sullo schermo di un computer si trova in realtà memorizzato in una particolare <i>codifica di carattere</i>. Parlando per sommi capi, la codifica di carattere fornisce una corrispondenza tra quello che vedete sul vostro schermo e quello che il vostro computer mantiene effettivamente in memoria e su disco. Ci sono molte codifiche di carattere diverse, alcune ottimizzate per particolari lingue come il russo o il cinese o l'inglese, e altre che possono essere usate per più di una lingua.

<p>In realtà, le cose sono molto più complicate di così. Molti caratteri sono comuni a più di una codifica, ma ogni codifica può usare una sequenza differente di byte per archiviare effettivamente quei caratteri in memoria o su disco. Quindi potete pensare alla codifica di carattere come a una sorta di chiave di decrittazione. Ogni volta che qualcuno vi dà una sequenza di byte&nbsp;&mdash;&nbsp;un file, una pagina web, qualsiasi cosa&nbsp;&mdash;&nbsp;e afferma che si tratta di &#8220;testo,&#8221; avete bisogno di sapere quale codifica di carattere è stata usata in modo da poter decodificare i byte in caratteri. Se vi viene data la chiave sbagliata, o addirittura nessuna chiave, vi ritrovate con il non invidiabile compito di scoprire il codice da soli. &Egrave; probabile che lo sbaglierete, e il risultato non sarà intelleggibile.

<aside>Tutto quello che pensavate di sapere sulle stringhe è sbagliato.</aside>

<p>Sicuramente avrete visto pagine web con strani caratteri simili a punti interrogativi in posti dove dovrebbero trovarsi gli apostrofi. Solitamente questo significa che l'autore della pagina non ha dichiarato correttamente la codifica dei caratteri, il vostro browser non ha potuto fare altro che tirare a indovinare, e il risultato è stato un misto di caratteri attesi e inattesi. In inglese è solo un fastidio; in altre lingue il risultato potrebbe essere completamente illeggibile.

<p>Esistono codifiche di carattere per tutte le lingue più diffuse al mondo. Dato che ogni lingua è differente, e che la memoria e lo spazio su disco sono stati storicamente costosi, ogni codifica di carattere è ottimizzata per una particolare lingua. Con questo voglio dire che ogni codifica usa gli stessi numeri (0&ndash;255) per rappresentare i caratteri di quella lingua. Per esempio, avrete probabilmente familiarità con la codifica <abbr>ASCII</abbr>, che memorizza i caratteri inglesi come numeri da 0 a 127. (65 è la &#8220;A&#8221; maiuscola, 97 è la &#8220;a&#8221; minuscola, <i class=baa>&amp;</i>c.) L'inglese ha un alfabeto molto semplice, quindi può essere completamente espresso in meno di 128 numeri. Per quelli di voi che sanno contare in base 2, questo significa utilizzare 7 degli 8 bit contenuti in un byte.

<p>Le lingue dell'Europa Occidentale come il francese, lo spagnolo e il tedesco hanno più lettere dell'inglese. O, più precisamente, hanno lettere combinate con vari segni diacritici, come il carattere <code>&ntilde;</code> in spagnolo. La codifica più comune per queste lingue è la CP-1252, anche chiamata &#8220;windows-1252&#8221; perché viene largamente utilizzata sotto Microsoft Windows. La codifica CP-1252 condivide caratteri con la codifica <abbr>ASCII</abbr> nell'intervallo 0&ndash;127, ma poi si espande nell'intervallo 128&ndash;255 per caratteri come la n-con-sopra-una-tilde (241), la u-con-sopra-due-punti (252), <i class=baa>&amp;</i>c. Questa è ancora una codifica a singolo byte, comunque; il numero più elevato, 255, sta ancora in un byte.

<p>Poi ci sono lingue come il cinese, il giapponese e il coreano che hanno talmente tanti caratteri da richiedere un insieme di caratteri a byte multipli. Cioè, ogni &#8220;carattere&#8221; è rappresentato da un numero a 2 byte tra 0 e 65535. Ma codifiche multi-byte differenti hanno gli stessi problemi di codifiche a singolo byte differenti, e cioè che ognuna usa gli stessi numeri per indicare cose diverse. &Egrave; solo che l'intervallo dei numeri è più ampio, perché ci sono molti più caratteri da rappresentare.

<p>Questo andava quasi bene in un mondo senza reti, dove il &#8220;testo&#8221; era qualcosa che scrivevate voi stessi e di cui occasionalmente stampavate qualche copia. Non c'era molto &#8220;testo semplice.&#8221; I programmatori scrivevano il codice sorgente in <abbr>ASCII</abbr>, e tutti gli altri usavano i word processor, ognuno dei quali definiva il proprio formato (non di testo) che teneva traccia delle informazioni sulla codifica di carattere insieme agli stili, <i class=baa>&amp;</i>c. Le persone leggevano questi documenti con gli stessi programmi di word processing dell'autore originale, così ogni cosa funzionava, più o meno.

<p>Considerate ora l'avvento di reti globali come l'email e il web. Un sacco di &#8220;testo semplice&#8221; svolazzante per il globo, scritto su un computer, trasmesso attraverso un secondo computer, e ricevuto e visualizzato da un terzo computer. I computer possono vedere solo numeri, ma i numeri potrebbero rappresentare cose diverse. Oh no! Cosa fare? I sistemi dovettero essere progettati per trasportare le informazioni di codifica insieme a ogni frammento di &#8220;testo semplice.&#8221; Ricordate, è la chiave di decrittazione che fa corrispondere i numeri leggibili dal computer ai caratteri leggibili dalle persone. Una chiave di decrittazione mancante significa testo alterato, inintelleggibile, o peggio.

<p>Considerate ora il tentativo di memorizzare molti frammenti di testo nello stesso posto, come nella stessa tabella di un database che contiene tutte le email che avete mai ricevuto. Avete ancora bisogno di archiviare la codifica di carattere insieme a ogni frammento di testo in modo da poterlo visualizzare correttamente. Pensate sia difficile? Provate a fare una ricerca nel vostro database di posta elettronica, il che significa effettuare al volo conversioni tra codifiche multiple. Non vi sembra divertente?

<p>Ora considerate la possibilità di documenti scritti in più lingue, dove i caratteri presi da diverse lingue sono uno a fianco dell'altro nello stesso documento. (Suggerimento: i programmi che provavano a farlo tipicamente usavano codici di escape per passare da una &#8220;modalità&#8221; all'altra. Poof, eccovi in modalità russa koi8-r, quindi 241 rappresenta Я; poof, ora siete in modalità Mac Greek, quindi 241 rappresenta ώ.) E naturalmente vorrete effettuare ricerche anche su <em>quei</em> documenti.

<p>E ora piangete pure, perché tutto quello che pensavate di sapere sulle stringhe è sbagliato, e il &#8220;testo semplice&#8221; non esiste.

<p class=a>&#x2042;

<h2 id=one-ring-to-rule-them-all>Unicode</h2>

<p><i>Entra <dfn>Unicode</dfn>.</i>

<p>Unicode è un sistema progettato per rappresentare <em>qualsiasi</em> carattere proveniente da <em>qualsiasi</em> lingua. Unicode rappresenta ogni lettera, carattere, o ideogramma come un numero di 4 byte. Ogni numero rappresenta un unico carattere usato in almeno una delle lingue del mondo. (Non tutti i numeri sono utilizzati, ma più di 65535 lo sono, quindi 2 byte non sarebbero stati sufficienti.) I caratteri che sono usati in più di una lingua corrispondono generalmente allo stesso numero, a meno che non ci sia una buona ragione etimologica per non farlo. In ogni caso, c'è esattamente 1 numero per carattere, ed esattamente 1 carattere per numero. Ogni numero rappresenta sempre solo un carattere; non ci sono &#8220;modalità&#8221; di cui tenere traccia. <code>U+0041</code> è sempre <code>'A'</code>, anche se la vostra lingua non possiede alcuna <code>'A'</code>.

<p>A prima vista, sembra una grande idea. Una codifica per governarle tutte. Lingue multiple per documento. Niente più &#8220;passaggi di modalità&#8221; per cambiare codifica a metà del testo. Ma l'ovvia domanda dovrebbe subito saltarvi in mente. Quattro byte? Per ogni singolo carattere<span class=u title='interrobang!'>&#8253;</span> Sembra uno spreco orrendo, specialmente per lingue come l'inglese e lo spagnolo, che necessitano di meno di un byte (256 numeri) per esprimere ogni possibile carattere. In effetti, è uno spreco persino per lingue basate su ideogrammi (come il cinese) che non hanno mai bisogno di più di due byte per carattere.

<p>Esiste una codifica Unicode che usa quattro byte per carattere. &Egrave; chiamata UTF-32, perché 32 bit = 4 byte. UTF-32 è la codifica più semplice; prende ogni carattere Unicode (un numero di 4 byte) e rappresenta il carattere con quello stesso numero. Questo ha alcuni vantaggi, tra cui il più importante è la possibilità di accedere al carattere di posizione <var>N</var> in una stringa in tempo costante, perché il carattere in posizione <var>N</var> comincia al byte di posizione <var>4&times;N</var>. Ha anche diversi svantaggi, tra cui il più ovvio è la necessità di quattro maledetti byte per memorizzare ogni maledetto carattere.

<p>Anche se ci sono un sacco di caratteri Unicode, a quanto pare la maggior parte delle persone non ne userà nessuno al di là dei primi 65535. Quindi, esiste un'altra codifica Unicode, chiamata UTF-16 (perché 16 bit = 2 byte). UTF-16 codifica ogni carattere tra 0 e 65535 come due byte, e poi usa un qualche sporco trucco nel caso dobbiate effettivamente rappresentare i rari caratteri Unicode che si trovano nel &#8220;piano astrale&#8221; al di là di 65535. Il vantaggio più ovvio: UTF-16 è due volte più efficiente in termini di spazio rispetto a UTF-32, perché ogni carattere richiede solo due byte da memorizzare invece di quattro byte (a parte quelli per cui non è così). E potete ancora facilmente accedere al carattere di posizione <var>N</var> in una stringa in tempo costante, se ipotizzate che la stringa non includa alcun carattere del piano astrale, che è una buona ipotesi fino a quando non lo è più.

<p>Ma sia UTF-32 che UTF-16 presentano anche altri svantaggi non banali. Sistemi computerizzati differenti memorizzano i singoli byte in modi differenti. Questo significa che il carattere <code>U+4E2D</code> potrebbe essere memorizzato in UTF-16 come <code>4E 2D</code> oppure <code>2D 4E</code>, a seconda che il sistema sia di tipo big-endian o little-endian. (Per UTF-32 ci sono ancora più ordinamenti di byte possibili.) Fino a quando i vostri documenti non lasciano mai il vostro computer, siete al sicuro&nbsp;&mdash;&nbsp;applicazioni differenti sullo stesso computer utilizzeranno sempre lo stesso ordine dei byte. Ma nel momento in cui volete trasferire documenti tra sistemi, forse su una qualche sorta di world wide web, avrete bisogno di un modo per indicare in quale ordine sono memorizzati i vostri byte. Altrimenti, il sistema ricevente non ha alcun modo di sapere se la sequenza di due byte <code>4E 2D</code> rappresenta <code>U+4E2D</code> oppure <code>U+2D4E</code>.

<p>Per risolvere <em>questo</em> problema, le codifiche Unicode multi-byte definiscono un &#8220;Byte Order Mark,&#8221; uno speciale carattere non stampabile che potete includere all'inizio del vostro documento per indicare in quale ordine sono memorizzati i vostri byte. Per UTF-16, il Byte Order Mark è <code>U+FEFF</code>. Se ricevete un documento UTF-16 che comincia con i byte <code>FF FE</code>, sapete che l'ordine dei byte va in una certa direzione; se comincia con <code>FE FF</code>, sapete che l'ordine dei byte è quello inverso.

<p>Tuttavia, UTF-16 non è esattamente l'ideale, specialmente se avete a che fare con un sacco di caratteri <abbr>ASCII</abbr>. Se ci pensate, persino una pagina web in cinese conterrà un sacco di caratteri <abbr>ASCII</abbr>&nbsp;&mdash;&nbsp;tutti gli elementi e gli attributi che circondano i caratteri stampabili cinesi. Essere in grado di accedere al carattere di posizione <var>N</var> in tempo costante è carino, ma rimane ancora l'irritante problema di quei caratteri del piano astrale, il che significa che non potete <em>garantire</em> che ogni carattere sia esattamente due byte, e quindi non potete <em>davvero</em> accedere al carattere di posizione <var>N</var> in tempo costante a meno che non manteniate un indice separato. E ragazzi, c'è sicuramente un sacco di testo <abbr>ASCII</abbr> nel mondo&hellip;

<p>Altre persone hanno ponderato a lungo su questi problemi, e hanno trovato una soluzione:

<p class=c style='font-size:1000%;font-weight:bold;line-height:1;margin:0.7em 0'>UTF-8

<p>UTF-8 è un sistema di codifica Unicode a <em>lunghezza variabile</em>. Cioè, caratteri differenti occupano un numero differente di byte. Per i caratteri <abbr>ASCII</abbr> (A-Z, <i class=baa>&amp;</i>c.) UTF-8 usa solo un byte per carattere. In effetti, usa gli stessi identici byte; i primi 128 caratteri (0&ndash;127) in UTF-8 sono indistinguibili da quelli <abbr>ASCII</abbr>. I caratteri &#8220;Extended Latin&#8221; come &ntilde; e &ouml; finiscono per occupare due byte. (I byte non sono semplicemente dei &#8220;code point&#8221; Unicode come sarebbero in UTF-16; i bit vengono pesantemente manipolati in qualche modo.) Caratteri cinesi come &#x4E2D; finiscono per occupare tre byte. I caratteri raramente usati del &#8220;piano astrale&#8221; occupano quattro byte.

<p>Svantaggi: dato che ogni carattere può occupare un numero differente di byte, accedere al carattere di posizione <var>N</var> è una operazione da O(N)&nbsp;&mdash;&nbsp;cioè, più lunga è la stringa, più tempo ci vuole per trovare uno specifico carattere. In più, i bit devono essere manipolati per codificare i caratteri in byte e decodificare i byte in caratteri.

<p>Vantaggi: la codifica dei caratteri <abbr>ASCII</abbr> comuni è super-efficiente. Per i caratteri Extended Latin non è peggiore rispetto alla codifica UTF-16, e per i caratteri cinesi è migliore rispetto a UTF-32. In più (e dovete fidarvi di me su questo, perché non vi mostrerò i calcoli), grazie alla natura esatta delle manipolazioni sui bit, non ci sono problemi di ordinamento dei byte. Un documento codificato in UTF-8 usa esattamente lo stesso flusso di byte su qualsiasi computer.

<p class=a>&#x2042;

<h2 id=divingin>Immersione!</h2>

<p>In Python 3, tutte le stringhe sono sequenze di caratteri Unicode. Non esistono stringhe Python codificate in UTF-8, o stringhe Python codificate in CP-1252. &#8220;Questa stringa è in UTF-8?&#8221; è una domanda non valida. UTF-8 è un modo di codificare caratteri come sequenze di byte. Se volete prendere una stringa e trasformarla in una sequenza di byte attraverso una particolare codifica di carattere, Python 3 vi può aiutare. Se volete prendere una sequenza di byte e trasformarla in una stringa, Python 3 può aiutarvi anche in questo caso. I byte non sono caratteri; i byte sono byte. I caratteri sono un'astrazione. Una stringa è una sequenza di quelle astrazioni.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>s = '深入 Python'</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>len(s)</kbd>               <span class=u>&#x2461;</span></a>
<samp class=pp>9</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[0]</kbd>                 <span class=u>&#x2462;</span></a>
<samp class=pp>'深'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s + ' 3'</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>'深入 Python 3'</samp></pre>
<ol>
<li>Per creare una stringa, racchiudetela tra virgolette. Le stringhe Python possono essere definite utilizzando apici (<code>'</code>) oppure virgolette (<code>"</code>).<!--"-->
<li>La funzione built-in <code><dfn>len</dfn>()</code> restituisce la lunghezza della stringa, <i>i.e.</i> il numero di caratteri. Questa è la stessa funzione che utilizzate per <a href=tipi-di-dato-nativi.html#extendinglists>trovare la lunghezza di una lista</a>. Una stringa è come una lista di caratteri.
<li>Esattamente come ottenete singoli elementi da una lista, potete ottenere singoli caratteri da una stringa usando la notazione a indice.
<li>Esattamente come con le liste, potete <dfn>concatenare</dfn> le stringhe utilizzando l'operatore <code>+</code>.
</ol>

<p class=a>&#x2042;

<h2 id=formatting-strings>Formattare le stringhe</h2>

<aside>Le stringhe possono essere definite utilizzando apici oppure virgolette.</aside>
<p>Diamo un'altra occhiata a <a href=il-vostro-primo-programma-python.html#divingin><code>humansize.py</code></a>:

<p class=d>[<a href=esempi/humansize.py>scarica <code>humansize.py</code></a>]
<pre><code class=pp><a>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],         <span class=u>&#x2460;</span></a>
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}

def approximate_size(size, a_kilobyte_is_1024_bytes=True):
<a>    '''Convert a file size to human-readable form.                          <span class=u>&#x2461;</span></a>

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

<a>    '''                                                                     <span class=u>&#x2462;</span></a>
    if size &lt; 0:
<a>        raise ValueError('number must be non-negative')                     <span class=u>&#x2463;</span></a>

    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size &lt; multiple:
<a>            return '{0:.1f} {1}'.format(size, suffix)                       <span class=u>&#x2464;</span></a>

    raise ValueError('number too large')</code></pre>
<ol>
<li><code>'KB'</code>, <code>'MB'</code>, <code>'GB'</code>&hellip; ognuna di quelle è una stringa.
<li>Le docstring di una funzione sono stringhe. Questa docstring si estende su più righe, e quindi usa tre virgolette consecutive all'inizio e alla fine della stringa.
<li>Queste tre virgolette consecutive concludono la docstring.
<li>C'è un'altra stringa, passata alla eccezione come un messaggio di errore.
<li>C'è una&hellip; whoa, che diavolo è quello?
</ol>

<p>Python 3 supporta la <dfn>formattazione</dfn> di valori in stringhe. Sebbene questo possa includere espressioni molto complicate, l'uso più basilare consiste nell'inserire un valore in una stringa con un singolo segnaposto.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>username = 'mark'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>password = 'PapayaWhip'</kbd>                             <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>"{0}'s password is {1}".format(username, password)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>"mark's password is PapayaWhip"</samp></pre>
<ol>
<li>No, la mia password non è davvero <kbd>PapayaWhip</kbd>.
<li>Ci sono un sacco di cose che stanno succedendo qui. Prima di tutto, c'è una chiamata di metodo su un letterale stringa. <em>Le stringhe sono oggetti</em>, e gli oggetti hanno metodi. Secondo, l'intera espressione viene valutata come una stringa. Terzo, <code>{0}</code> e <code>{1}</code> sono <i>campi di sostituzione</i>, che vengono rimpiazzati dagli argomenti passati al metodo <code><dfn>format</dfn>()</code>.
</ol>

<h3 id=compound-field-names>Nomi di campo composti</h3>

<p>L'esempio precedente mostra il caso più semplice, dove i campi di sostituzione sono semplicemente interi. I campi di sostituzione interi sono trattati come indici di posizione nella lista di argomenti del metodo <code>format()</code>. Questo significa che <code>{0}</code> è rimpiazzato dal primo argomento (<var>username</var> in questo caso), <code>{1}</code> è rimpiazzato dal secondo argomento (<var>password</var>), <i class=baa>&amp;</i>c. Potete avere tanti indici di posizione quanti sono gli argomenti, e potete avere tanti argomenti quanti ne volete. Ma i campi di sostituzione sono molto più potenti di così.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>si_suffixes = humansize.SUFFIXES[1000]</kbd>      <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>si_suffixes</kbd>
<samp class=pp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'1000{0[0]} = 1{0[1]}'.format(si_suffixes)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'1000KB = 1MB'</samp>
</pre>
<ol>
<li>Invece di chiamare una funzione qualsiasi nel modulo <code>humansize</code>, state recuperando una delle strutture dati che il modulo definisce: la lista dei suffissi (potenze-di-1000) del Sistema internazionale di unità di misura (&#8220;SI&#8221;).
<li>Questo sembra complicato, ma non lo è. <code>{0}</code> si riferirebbe al primo argomento passato al metodo <code>format()</code>, <var>si_suffixes</var>. Ma <var>si_suffixes</var> è una lista. Così <code>{0[0]}</code> si riferisce al primo elemento della lista che è il primo argomento passato al metodo <code>format()</code>: <code>'KB'</code>. Similmente, <code>{0[1]}</code> si riferisce al secondo elemento della stessa lista: <code>'MB'</code>. Ogni cosa fuori dalle parentesi graffe&nbsp;&mdash;&nbsp;compreso <code>1000</code>, il segno di uguale, e gli spazi&nbsp;&mdash;&nbsp;non viene toccata. Il risultato finale è la stringa <code>'1000KB = 1MB'</code>.
</ol>

<aside>{0} è sostituito dal 1° argomento di format(). {1} è sostituito dal 2°.</aside>
<p>Questo esempio mostra che <em>i campi di sostituzione possono accedere a elementi e proprietà di una struttura dati usando (quasi) la stessa sintassi di Python</em>. Quelli che abbiamo appena visto si chiamano <i>nomi di campo composti</i>. I seguenti nomi di campo composti sono validi:

<ul>
<li>Passare una lista, e accedere a un elemento della lista tramite indice (come nell'esempio precedente)
<li>Passare un dizionario, e accedere a un valore del dizionario tramite chiave
<li>Passare un modulo, e accedere alle sue variabili e funzioni tramite nome
<li>Passare una istanza di una classe, e accedere alle sue proprietà e metodi tramite nome
<li><em>Una qualsiasi combinazione dei nomi precedenti</em>
</ul>

<p>Giusto per impressionarvi, eccovi un esempio che combina tutti i nomi appena visti:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<samp class=p>>>> </samp><kbd class=pp>import sys</kbd>
<samp class=p>>>> </samp><kbd class=pp>'1MB = 1000{0.modules[humansize].SUFFIXES[1000][0]}'.format(sys)</kbd>
<samp class=pp>'1MB = 1000KB'</samp></pre>

<p>Funziona in questo modo:

<ul>
<li>Il modulo <code>sys</code> mantiene informazioni sull'istanza dell'interprete Python attualmente in esecuzione. Visto che lo avete appena importato, potete passare il modulo <code>sys</code> stesso come argomento al metodo <code>format()</code>. Quindi il campo di sostituzione <code>{0}</code> si riferisce al modulo <code>sys</code>.
<li><code>sys.modules</code> è un dizionario di tutti i moduli che sono stati importati in questa istanza dell'interprete Python. Le chiavi sono i nomi dei moduli sotto forma di stringhe; i valori sono gli oggetti modulo stessi. Quindi il campo di sostituzione <code>{0.modules}</code> si riferisce al dizionario dei moduli importati.
<li><code>sys.modules['humansize']</code> è il modulo <code>humansize</code> che avete appena importato. Il campo di sostituzione <code>{0.modules[humansize]}</code> si riferisce al modulo <code>humansize</code>. Notate la leggera differenza nella sintassi. In vero codice Python, le chiavi del dizionario <code>sys.modules</code> sono stringhe; per riferirsi ad esse, avete bisogno di mettere le virgolette attorno al nome del modulo (<i>e.g.</i> <code>'humansize'</code>). Ma nell'ambito di un campo di sostituzione le virgolette attorno al nome della chiave del dizionario vanno omesse (<i>e.g.</i> <code>humansize</code>). Per citare la <a href=http://www.python.org/dev/peps/pep-3101/>PEP 3101: Formattazione avanzata delle stringhe</a>, &#8220;Le regole per riconoscere la chiave di un elemento sono molto semplici. Se comincia con una cifra, allora viene trattato come un numero, altrimenti viene usato come una stringa.&#8221;
<li><code>sys.modules['humansize'].SUFFIXES</code> è il dizionario definito all'inizio del modulo <code>humansize</code>. Il campo di sostituzione <code>{0.modules[humansize].SUFFIXES}</code> si riferisce a quel dizionario.
<li><code>sys.modules['humansize'].SUFFIXES[1000]</code> è una lista di suffissi <abbr>SI</abbr>: <code>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</code>. Quindi il campo di sostituzione <code>{0.modules[humansize].SUFFIXES[1000]}</code> si riferisce a quella lista.
<lI><code>sys.modules['humansize'].SUFFIXES[1000][0]</code> è il primo elemento nella lista dei suffissi <abbr>SI</abbr>: <code>'KB'</code>. Quindi, il campo di sostituzione completo <code>{0.modules[humansize].SUFFIXES[1000][0]}</code> è rimpiazzato dalla stringa di due caratteri <code>KB</code>.
</ul>

<h3 id=format-specifiers>Specifiche di formato</h3>

<p>Ma aspettate! C'è di più! Diamo un'altra occhiata a quella strana linea di codice in <code>humansize.py</code>:

<pre><code class=pp>if size &lt; multiple:
    return '{0:.1f} {1}'.format(size, suffix)</code></pre>

<p><code>{1}</code> viene rimpiazzato dal secondo argomento passato al metodo <code>format()</code>, che è <var>suffix</var>. Ma che cos'è <code>{0:.1f}</code>? &Egrave; due cose: <code>{0}</code>, che riconoscerete, e <code>:.1f</code>, che non riconoscerete. La seconda metà (dai due punti in poi compresi) definisce una <i>specifica di formato</i>, che raffina ulteriormente il modo in cui la variabile rimpiazzata dovrà essere formattata.

<blockquote class='note compare clang'>
<p><span class=u>&#x261E;</span>Le specifiche di formato vi permettono di manipolare il testo di sostituzione in una varietà di modi utili, come la funzione <code><dfn>printf</dfn>()</code> in C. Potete aggiungere blocchi di zeri o spazi, allineare stringhe, controllare la precisione dei decimali, e persino convertire numeri in esadecimali.
</blockquote>

<p>Nell'ambito di un campo di sostituzione, i due punti (<code>:</code>) segnano l'inizio della specifica di formato. La specifica di formato &#8220;<code>.1</code>&#8221; significa &#8220;arrotonda al decimale più vicino&#8221; (<i>i.e.</i> mostra solo una cifra dopo il punto decimale). La specifica di formato &#8220;<code>f</code>&#8221; significa &#8220;numero in virgola fissa&#8221; (al contrario della notazione esponenziale o di qualche altra rappresentazione decimale). Quindi, data una dimensione <var>size</var> di <code>698.25</code> e un suffisso <var>suffix</var> di <code>'GB'</code>, la stringa formattata diventerà <code>'698.3 GB'</code>, perché <code>698.25</code> viene arrotondato alla prima cifra decimale, e il suffisso è aggiunto dopo il numero.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>'{0:.1f} {1}'.format(698.25, 'GB')</kbd>
<samp class=pp>'698.3 GB'</samp></pre>

<p>Per tutti i dettagli più intricati sulle specifiche di formato, consultate la sezione <a href=http://docs.python.org/3.0/library/string.html#format-specification-mini-language>Format Specification Mini-Language</a> nella documentazione ufficiale di Python.

<p class=a>&#x2042;

<h2 id=common-string-methods>Altri metodi di uso comune per le stringhe</h2>

<p>Oltre alla formattazione, le stringhe possono effettuare un numero di altre operazioni utili.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>s = '''Finished files are the re-</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd>sult of years of scientif-</kbd>
<samp class=p>... </samp><kbd>ic study combined with the</kbd>
<samp class=p>... </samp><kbd>experience of years.'''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.splitlines()</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>['Finished files are the re-',
 'sult of years of scientif-',
 'ic study combined with the',
 'experience of years.']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(s.lower())</kbd>                   <span class=u>&#x2462;</span></a>
<samp>finished files are the re-
sult of years of scientif-
ic study combined with the
experience of years.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.lower().count('f')</kbd>               <span class=u>&#x2463;</span></a>
<samp class=pp>6</samp></pre>
<ol>
<li>Potete introdurre stringhe <dfn>multiriga</dfn> nella shell interattiva di Python. Una volta che avete cominciato una stringa su più righe con le triple virgolette, vi basta premere <kbd>ENTER</kbd> e la shell interattiva vi permetterà di continuare la stringa. Digitare le triple virgolette di chiusura termina la stringa, e il successivo <kbd>ENTER</kbd> eseguirà il comando (in questo caso, l'assegnamento della stringa a <var>s</var>).
<li>Il metodo <code><dfn>splitlines</dfn>()</code> prende una stringa multiriga e restituisce una lista di stringhe, una per ogni riga di quella originale. Notate che i caratteri di a capo alla fine di ogni linea non sono inclusi.
<li>Il metodo <code>lower()</code> converte l'intera stringa in minuscolo. (Similmente, il metodo <code>upper()</code> converte una stringa in maiuscolo.) 
<li>Il metodo <code>count()</code> conta il numero di occorrenze di una sottostringa. Sì, ci sono davvero sei &#8220;f&#8221; in quella frase!
</ol>

<p>Ecco un altro caso comune. Diciamo che avete una lista di coppie chiavi-valori nella forma <code><var>key1</var>=<var>value1</var>&amp;<var>key2</var>=<var>value2</var></code>, e volete separarle e creare un dizionario della forma <code>{key1: value1, key2: value2}</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>query = 'user=pilgrim&amp;database=master&amp;password=PapayaWhip'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = query.split('&amp;')</kbd>                            <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['user=pilgrim', 'database=master', 'password=PapayaWhip']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list_of_lists = [v.split('=', 1) for v in a_list]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list_of_lists</kbd>
<samp class=pp>[['user', 'pilgrim'], ['database', 'master'], ['password', 'PapayaWhip']]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict = dict(a_list_of_lists)</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'password': 'PapayaWhip', 'user': 'pilgrim', 'database': 'master'}</samp></pre>

<ol>
<li>Il metodo <code><dfn>split</dfn>()</code> delle stringhe prende un argomento, un delimitatore, e divide la stringa in una lista di stringhe in corrispondenza del delimitatore. In questo caso, il delimitatore è un carattere di E commerciale, ma potrebbe essere qualsiasi cosa.
<li>Ora abbiamo una lista di stringhe, ognuna con una chiave, seguita da un segno di uguale, seguito da un valore. Vogliamo iterare sull'intera lista e dividere ogni stringa in due stringhe in corrispondenza del primo segno di uguale. (In teoria, anche un valore potrebbe contenere un segno di uguale. Se avessimo usato <code>'key=value=foo'.split('=')</code>, avremmo ottenuto una lista di tre elementi, <code>['key', 'value', 'foo']</code>.)
<li>Infine, Python può trasformare quella lista-di-liste in un dizionario semplicemente passandola alla funzione <code>dict()</code>.
</ol>

<p class=fixme>[FIXME - this is the first time we've seen a list comprehension. Add a forward or backward reference once we have a full section explaining them.]

<blockquote class=note>
<p><span class=u>&#x261E;</span>L'esempio precedente somiglia molto al riconoscimento dei parametri di richiesta in un <abbr>URL</abbr>, ma in effetti il riconoscimento degli <abbr>URL</abbr> nella vita reale è molto più complicato di così. Se avete a che fare con i parametri di richiesta in un <abbr>URL</abbr>, vi conviene utilizzare la funzione <a href=http://docs.python.org/3.1/library/urllib.parse.html#urllib.parse.parse_qs><code>urllib.parse.parse_qs()</code></a>, che è in grado di gestire alcuni casi limite non banali.
</blockquote>

<h3 id=slicingstrings>Affettare una stringa</h3>
<p>Una volta che avete definito una stringa, potete ottenerne una parte qualsiasi sotto forma di una nuova stringa. Questa operazione si chiama <i>affettare</i> la stringa. Affettare le stringhe funziona esattamente allo stesso modo di <a href=tipi-di-dato-nativi.html#slicinglists>affettare le liste</a>, cosa che ha senso perché le stringhe sono solo sequenze di caratteri.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'My alphabet starts where your alphabet ends.'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[3:11]</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>'alphabet'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[3:-3]</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>'alphabet starts where your alphabet en'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[0:2]</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>'My'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[:18]</kbd>            <span class=u>&#x2463;</span></a>
<samp class=pp>'My alphabet starts'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[18:]</kbd>            <span class=u>&#x2464;</span></a>
<samp class=pp>' where your alphabet ends.'</samp></pre>
<ol>
<li>Potete ottenere una parte di una stringa, chiamata &#8220;fetta&#8221;, specificando due indici. Il valore di ritorno è una nuova stringa che contiene tutti i caratteri della stringa, in ordine, a cominciare dal primo indice della fetta (in questo caso <code>a_string[0]</code>) fino al secondo indice della fetta escluso (in questo caso <code>a_string[2]</code>).
<li>Come nell'affettare liste, potete usare indici negativi per affettare le stringhe.
<li>L'indice delle stringhe comincia da zero, quindi <code>a_string[0:3]</code> restituisce i primi tre caratteri della stringa, cominciando da <code>a_string[0]</code> fino a <code>a_string[3]</code> escluso.
<li>Se l'indice sinistro della fetta è <code>0</code>, potete ometterlo, e <code>0</code> diventa implicito. Quindi <code>a_string[:18]</code> è la stessa cosa di <code>a_string[0:18]</code>, perché lo <code>0</code> iniziale è implicito.
<li>Similmente, se l'indice destro della fetta è la lunghezza della stringa, potete ometterlo. Quindi <code>a_string[18:]</code> è la stessa cosa di <code>a_string[18:44]</code>, perché questa stringa ha 44 caratteri. C'è una piacevole simmetria qui. In questa stringa di 44 caratteri, <code>a_string[:18]</code> restituisce sempre i primi 18 caratteri e <code>a_string[18:]</code> restituisce tutto tranne i primi 18 caratteri. In effetti, <code>a_string[:<var>n</var>]</code> restituirà sempre i primi <var>n</var> caratteri e <code>a_string[<var>n</var>:]</code> restituirà il resto, a prescindere dalla lunghezza della stringa.
</ol>

<p class=a>&#x2042;

<h2 id=byte-arrays>Stringhe vs. byte</h2>

<p>I <dfn>byte</dfn> sono byte; i caratteri sono un'astrazione. Una sequenza immutabile di caratteri Unicode si chiama <i>stringa</i>. Una sequenza immutabile di numeri-tra-0-e-255 si chiama oggetto <i>byte</i>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>by = b'abcd\x65'</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'abcde'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(by)</kbd>          <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'bytes'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>           <span class=u>&#x2462;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by += b'\xff'</kbd>     <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'abcde\xff'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>           <span class=u>&#x2464;</span></a>
<samp class=pp>6</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by[0]</kbd>             <span class=u>&#x2465;</span></a>
<samp class=pp>97</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by[0] = 102</kbd>       <span class=u>&#x2466;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'bytes' object does not support item assignment</samp></pre>
<ol>
<li>Per definire un oggetto <code><dfn>bytes</dfn></code>, usate la sintassi <code>b''</code> per i &#8220;letterali byte.&#8221; Ogni byte nel letterale byte può essere un carattere <abbr>ASCII</abbr> o un numero esadecimale codificato da <code>\x00</code> a <code>\xff</code> (0&ndash;255).
<li>Il tipo di un oggetto <code>bytes</code> è <code>bytes</code>.
<li>Esattamente come con le liste e le stringhe, potete ottenere la lunghezza di un oggetto <code>bytes</code> con la funzione built-in <code>len()</code>.
<li>Esattamente come con le liste e le stringhe, potete usare l'operatore <code>+</code> per concatenare oggetti <code>bytes</code>. Il risultato è un nuovo oggetto <code>bytes</code>.
<li>Concatenare un oggetto <code>bytes</code> di 5 byte e un oggetto <code>bytes</code> di 1 byte dà come risultato un oggetto <code>bytes</code> di 6 byte.
<li>Esattamente come con le liste e le stringhe, potete usare la notazione a indici per ottenere i singoli byte in un oggetto <code>bytes</code>. Gli elementi di una stringa sono stringhe; gli elementi di un oggetto <code>bytes</code> sono interi. Nello specifico, interi tra 0 e 255.
<li>Un oggetto <code>bytes</code> è immutabile; non potete assegnare singoli byte. Se avete bisogno di cambiare i singoli byte, potete usare i metodi per <a href=#slicingstrings>affettare le stringhe</a> e gli operatori di concatenazione (che funzionano allo stesso modo delle stringhe), oppure potete convertire l'oggetto <code>bytes</code> in un oggetto <code>bytearray</code>.
</ol>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>by = b'abcd\x65'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>barr = bytearray(by)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>barr</kbd>
<samp class=pp>bytearray(b'abcde')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(barr)</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>barr[0] = 102</kbd>         <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>barr</kbd>
<samp class=pp>bytearray(b'fbcde')</samp></pre>
<ol>
<li>Per convertire un oggetto <code>bytes</code> in un oggetto <code>bytearray</code> modificabile, usate la funzione built-in <code>bytearray()</code>.
<li>Tutti i metodi e le operazioni che si possono eseguire su un oggetto <code>bytes</code> si possono eseguire anche su un oggetto <code>bytearray</code>.
<li>L'unica differenza è che, con un oggetto <code>bytearray</code>, potete assegnare i singoli byte utilizzando la notazione a indici. Il valore assegnato deve essere un intero tra 0 e 255.
</ol>

<p>L'unica cosa che <em>non potete mai fare</em> è mescolare stringhe e byte.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>by = b'd'</kbd>
<samp class=p>>>> </samp><kbd class=pp>s = 'abcde'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>by + s</kbd>                       <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: can't concat bytes to str</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.count(by)</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: Can't convert 'bytes' object to str implicitly</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.count(by.decode('ascii'))</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>1</samp></pre>
<ol>
<li>Non potete concatenare stringhe e byte. Sono due tipi di dati differenti.
<li>Non potete contare le occorrenze di byte in una stringa, perché non c'è alcun byte in una stringa. Una stringa è una sequenza di caratteri. Forse intendevate &#8220;conta le occorrenze della stringa che si otterrebbe dopo aver decodificato questa sequenza di byte in una particolare codifica di caratteri&#8221;? Ebbene, allora, dovete dirlo esplicitamente. Python 3 non convertirà <dfn>implicitamente</dfn> byte in stringhe o stringhe in byte.
<li>Per una sorprendente coincidenza, questa riga di codice dice &#8220;conta le occorrenze della stringa che si otterrebbe dopo aver decodificato questa sequenza di byte in una particolare codifica di caratteri.&#8221;
</ol>

<p>Ed ecco il collegamento tra stringhe e byte: gli oggetti <code>bytes</code> hanno un metodo <code><dfn>decode</dfn>()</code> che prende una codifica di caratteri e restituisce una stringa, e le stringhe hanno un metodo <code><dfn>encode</dfn>()</code> che prende una codifica di caratteri e restituisce un oggetto <code>bytes</code>. Nell'esempio precedente, la decodifica era relativamente semplice&nbsp;&mdash;&nbsp;convertire una sequenza di byte in una stringa di caratteri attraverso la codifica <abbr>ASCII</abbr>. Ma lo stesso procedimento funziona con qualsiasi codifica che supporti i caratteri della stringa&nbsp;&mdash;&nbsp;persino codifiche legacy (non Unicode).

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_string = '深入 Python'</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>len(a_string)</kbd>
<samp class=pp>9</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('utf-8')</kbd>    <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xe6\xb7\xb1\xe5\x85\xa5 Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>13</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('gb18030')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xc9\xee\xc8\xeb Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>11</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('big5')</kbd>     <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xb2`\xa4J Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>11</samp>
<a><samp class=p>>>> </samp><kbd class=pp>roundtrip = by.decode('big5')</kbd>    <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>roundtrip</kbd>
<samp class=pp>'深入 Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string == roundtrip</kbd>
<samp class=pp>True</samp></pre>
<ol>
<li>Questa è una stringa. Ha nove caratteri.
<li>Questo è un oggetto <code>bytes</code>. Ha 13 byte. &Egrave; la sequenza di byte che si ottiene codificando <var>a_string</var> in UTF-8.
<li>Questo è un oggetto <code>bytes</code>. Ha 11 byte. &Egrave; la sequenza di byte che si ottiene codificando <var>a_string</var> in <a href=http://en.wikipedia.org/wiki/GB_18030>GB18030</a>.
<li>Questo è un oggetto <code>bytes</code>. Ha 11 byte. &Egrave; una <em>sequenza completamente diversa di byte</em> che si ottiene codificando <var>a_string</var> in <a href=http://en.wikipedia.org/wiki/Big5>Big5</a>.
<li>Questa è una stringa. Ha nove caratteri. &Egrave; la sequenza di caratteri che si ottiene decodificando <var>by</var> con l'algoritmo di codifica Big5. &Egrave; identica alla stringa originale.
</ol>

<p class=a>&#x2042;

<h2 id=py-encoding>Post Scriptum: codifica di caratteri per il codice sorgente Python</h2>

<p>Python 3 assume che il vostro codice sorgente&nbsp;&mdash;&nbsp;<i>i.e.</i> ogni file <code>.py</code>&nbsp;&mdash;&nbsp;sia codificato in UTF-8.

<blockquote class='note compare python2'>
<p><span class=u>&#x261E;</span>In Python 2, la codifica di <dfn>default</dfn> per i file <code>.py</code> era <abbr>ASCII</abbr>. In Python 3, <a href=http://www.python.org/dev/peps/pep-3120/>la codifica di default è UTF-8</a>.
</blockquote>

<p>Se volete usare una codifica differente nel vostro codice Python, potete inserire una dichiarazione di codifica nella prima riga di ogni file. Questa dichiarazione definisce windows-1252 come codifica di un file <code>.py</code>

<pre><code class=pp># -*- coding: windows-1252 -*-</code></pre>

<p>Tecnicamente, la dichiarazione per la nuova codifica di carattere si può trovare anche sulla seconda riga, se la prima riga contiene un comando hash-bang di tipo <abbr>UNIX</abbr>.

<pre><code class=pp>#!/usr/bin/python3
# -*- coding: windows-1252 -*-</code></pre>

<p>Per maggiori informazioni, consultate la <a href=http://www.python.org/dev/peps/pep-0263/><abbr>PEP</abbr> 263: Defining Python Source Code Encodings</a>.

<p class=a>&#x2042;

<h2 id=furtherreading>Letture di approfondimento</h2>

<p>Su Unicode in Python:

<ul>
<li><a href=http://docs.python.org/3.0/howto/unicode.html>Python Unicode HOWTO</a>
<li><a href=http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit>What&#8217;s New In Python 3: Text vs. Data Instead Of Unicode vs. 8-bit</a>
</ul>

<p>Su Unicode in generale:

<ul>
<li><a href=http://www.joelonsoftware.com/articles/Unicode.html>The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/06/Unicode>On the Goodness of Unicode</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/13/Strings>On Character Strings</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF>Characters vs. Bytes</a>
</ul>

<p>Sulle codifiche di carattere in altri formati:

<ul>
<li><a href=http://feedparser.org/docs/character-encoding.html>Character encoding in XML</a>
<li><a href=http://blog.whatwg.org/the-road-to-html-5-character-encoding>Character encoding in HTML</a>
</ul>

<p>Sulle stringhe e sulla formattazione di stringhe:

<ul>
<li><a href=http://docs.python.org/3.0/library/string.html><code>string</code>&nbsp;&mdash;&nbsp;Common string operations</a>
<li><a href=http://docs.python.org/3.0/library/string.html#formatstrings>Format String Syntax</a>
<li><a href=http://docs.python.org/3.0/library/string.html#format-specification-mini-language>Format Specification Mini-Language</a>
<li><a href=http://www.python.org/dev/peps/pep-3101/><abbr>PEP</abbr> 3101: Advanced String Formatting</a>
</ul>

<p class=nav><a rel=prev href=tipi-di-dato-nativi.html title='indietro a &#8220;Tipi di dato nativi&#8221;'><span class=u>&#x261C;</span></a> <a rel=next href=espressioni-regolari.html title='avanti a &#8220;Espressioni regolari&#8221;'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;9 <a href=informazioni-sul-libro.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
