<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Espressioni regolari - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
body{counter-reset:h1 4}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=root value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#regular-expressions>Dive Into Python 3</a> <span>&#8227;</span>
<p id=level>Livello di difficoltà: <span title=intermedio>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Espressioni regolari</h1>
<blockquote class=q>
<p><span>&#x275D;</span> Alcune persone, quando affrontano un problema, pensano &#8220;Ci sono, userò le espressioni regolari.&#8221; Ora hanno due problemi. <span>&#x275E;</span><br>&mdash; <a href=http://www.jwz.org/hacks/marginal.html>Jamie Zawinski</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>Ogni moderno linguaggio di programmazione include funzioni built-in per lavorare con le stringhe. In Python, le stringhe hanno metodi per effettuare ricerche e sostituzioni: <code>index()</code>, <code>find()</code>, <code>split()</code>, <code>count()</code>, <code>replace()</code>, <i class=baa>&amp;</i>c. Ma questi metodi sono limitati ai casi più semplici. Per esempio, il metodo <code>index()</code> cerca una singola, <span class=wtf>hard-coded</span> sottostringa, e la ricerca è sempre sensibile alle maiuscole. Per fare ricerche insensibili alle maiuscole di una stringa <var>s</var>, dovete chiamare <code>s.lower()</code> oppure <code>s.upper()</code> e assicurarvi che le vostre stringhe di ricerca contengano i caratteri appropriati per corrispondere. I metodi <code>replace()</code> e <code>split()</code> hanno le stesse limitazioni.
<p>Se il vostro obiettivo può essere raggiunto con i metodi delle stringhe, dovreste usarli. Sono veloci, semplici e facili da leggere, e c'è molto da dire a favore del codice veloce, semplice e leggibile. Ma se vi trovate a usare una grande quantità di funzioni differenti sulle stringhe insieme a istruzioni <code>if</code> per gestire casi particolari, o se state combinando tra loro chiamate a <code>split()</code> e <code>join()</code> per affettare e ricomporre le vostre stringhe, potreste aver bisogno di spostarvi verso le espressioni regolari.
<p>Le espressioni regolari sono un modo potente e (per la maggior parte) standard per cercare, sostituire, e riconoscere testo attraverso complessi pattern di caratteri. Sebbene la sintassi delle espressioni regolari sia ermetica e diversa dal normale codice, il risultato può finire per essere <em>più</em> leggibile di una soluzione manuale che usa una lunga catena di funzioni per le stringhe. Ci sono persino modi di includere commenti all'interno di espressioni regolari, così potete includere documentazione di grana fine al loro interno.
<blockquote class="note compare perl5">
<p><span>&#x261E;</span>Se avete usato le espressioni regolari in altri linguaggi (come Perl 5), la sintassi utilizzata da Python vi sarà molto familiare. Leggete il riepilogo della documentazione ufficiale sul <a href=http://docs.python.org/dev/library/re.html#module-contents>modulo <code>re</code></a> (in inglese) per avere una descrizione delle funzioni disponibili e dei loro argomenti.
</blockquote>
<h2 id=streetaddresses>Caso di studio: indirizzi delle vie</h2>
<p>Questa serie di esempi si ispira a un problema reale incontrato sul lavoro diversi anni fa, quando ho avuto bisogno di <span class=wtf>scrub</span> e uniformare gli indirizzi delle vie estratti da un sistema <span class=wtf>legacy</span> prima di inserirli in un sistema più nuovo. (Vedete, non mi invento questa roba sul momento; è realmente utile.) Questo esempio mostra come ho affrontato il problema.
<pre class=screen>
<samp class=p>>>> </samp><kbd>s = '100 NORTH MAIN ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd>s.replace('ROAD', 'RD.')</kbd>                <span>&#x2460;</span></a>
<samp>'100 NORTH MAIN RD.'</samp>
<samp class=p>>>> </samp><kbd>s = '100 NORTH BROAD ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd>s.replace('ROAD', 'RD.')</kbd>                <span>&#x2461;</span></a>
<samp>'100 NORTH BRD. RD.'</samp>
<a><samp class=p>>>> </samp><kbd>s[:-4] + s[-4:].replace('ROAD', 'RD.')</kbd>  <span>&#x2462;</span></a>
<samp>'100 NORTH BROAD RD.'</samp>
<a><samp class=p>>>> </samp><kbd>import re</kbd>                               <span>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd>re.sub('ROAD$', 'RD.', s)</kbd>               <span>&#x2464;</span></a>
<samp>'100 NORTH BROAD RD.'</samp></pre>
<ol>
<li>Il mio obiettivo è di standardizzare un indirizzo in modo che <code>'ROAD'</code> sia sempre abbreviato come <code>'RD.'</code>. Ad una prima occhiata, pensavo fosse una cosa abbastanza semplice da poter semplicemente usare il metodo <code>replace()</code> sulle stringhe. Dopo tutto, i dati erano già in maiuscolo, così eventuali corrispondenze mancate con caratteri minuscoli non sarebbero state un problema. E la stringa di ricerca, <code>'ROAD'</code>, era una costante. E in questo caso ingannevolmente semplice, <code>s.replace()</code> effettivamente funziona.
<li>La vita, sfortunatamente, è piena di controesempi, e ho scoperto velocemente questo. Il problema qui è che <code>'ROAD'</code> appare due volte nell'indirizzo, una volta come parte del nome della via <code>'BROAD'</code> e una volta come parola a sé. Il metodo <code>replace()</code> vede queste due occorrenze e le rimpiazza entrambe alla cieca; nel frattempo, io vedo i miei indirizzi che vengono distrutti.
<li>Per risolvere il problema degli indirizzi con più di una sottostringa <code>'ROAD'</code>, potreste ricorrere a qualcosa come questo: cercate e sostituite <code>'ROAD'</code> solo negli ultimi quattro caratteri dell'indirizzo (<code>s[-4:]</code>), e lasciate stare il resto della stringa (<code>s[:-4]</code>). Ma, come potete vedere, queste strategie stanno già cominciando a diventare poco pratiche. Per esempio, il pattern dipende dalla lunghezza della stringa che state sostituendo. (Se doveste sostituire <code>'STREET'</code> con <code>'ST.'</code>, dovreste usare <code>s[:-6]</code> e <code>s[-6:].replace(...)</code>.) Vorreste tornare indietro dopo sei mesi e correggere questo? Io so che non vorrei.
<li>&Egrave; il momento di spostarsi verso le espressioni regolari. In Python, tutte le funzionalità relative alle espressioni regolari sono contenute nel modulo <code>re</code>.
<li>Date un'occhiata al primo parametro: <code>'ROAD$'</code>. Questa è una semplice espressione regolare che corrisponde a <code>'ROAD'</code> solo quando si trova alla fine di una stringa. Il simbolo <code>$</code> significa &#8220;fine della stringa.&#8221; (C'è un carattere corrispondente, il caret <code>^</code>, che significa &#8220;inizio della stringa.&#8221;) Usando la funzione <code>re.sub()</code>, cercate l'espressione regolare <code>'ROAD$'</code> nella stringa <var>s</var> e la sostituite con <code>'RD.'</code>. La funzione trova una corrispondenza con <code>ROAD</code> alla fine della stringa <var>s</var>, ma <em>non</em> trova alcuna corrispondenza con la <code>ROAD</code> che è parte della parola <code>BROAD</code>, perché quella è nel mezzo di <var>s</var>.
</ol>
<aside>^ corrisponde all'inizio di una stringa. $ corrisponde alla fine di una stringa.</aside>
<p>Proseguendo la mia storia di <span class=wtf>scrubbing</span> indirizzi, ho presto scoperto che l'esempio precedente, trovare una corrispondenza con <code>'ROAD'</code> alla fine dell'indirizzo, non era abbastanza buono, perché non tutti gli indirizzi includono una designazione della via. Alcuni indirizzi semplicemente terminano con il nome della via. <span class=wtf>I got away with it</span> la maggior parte del tempo, ma se il nome della via fosse stato <code>'BROAD'</code>, allora l'espressione regolare avrebbe trovato una corrispondenza di <code>'ROAD'</code> alla fine della stringa come parte della parola <code>'BROAD'</code>, che non era ciò che volevo.
<pre class=screen>
<samp class=p>>>> </samp><kbd>s = '100 BROAD'</kbd>
<samp class=p>>>> </samp><kbd>re.sub('ROAD$', 'RD.', s)</kbd>
<samp>'100 BRD.'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub('\\bROAD$', 'RD.', s)</kbd>   <span>&#x2460;</span></a>
<samp>'100 BROAD'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span>&#x2461;</span></a>
<samp>'100 BROAD'</samp>
<samp class=p>>>> </samp><kbd>s = '100 BROAD ROAD APT. 3'</kbd>
<a><samp class=p>>>> </samp><kbd>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span>&#x2462;</span></a>
<samp>'100 BROAD ROAD APT. 3'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub(r'\bROAD\b', 'RD.', s)</kbd>  <span>&#x2463;</span></a>
<samp>'100 BROAD RD. APT 3'</samp></pre>
<ol>
<li>Quello che <em>realmente</em> volevo era trovare una corrispondenza con <code>'ROAD'</code> quando era al termine della stringa <em>ed</em> era una parola a sé (non parte di una parola più grande). Per esprimere questo in una espressione regolare, si usa <code>\b</code>, che significa &#8220;il limite di una parola deve trovarsi proprio qui.&#8221; In Python, questo uso è complicato dalla necessità di effettuare l'escape di ogni carattere <code>'\'</code> che si trova in una stringa. Questa viene solitamente chiamata la piaga del backslash, ed è una ragione per cui le espressioni regolari sono più semplici in Perl che in Python. <span class=wtf>On the down side</span>, Perl mescola le espressioni regolari con altra sintassi, quindi se avete un problema, potrebbe essere difficile capire se è un bug nella sintassi o è un bug nella vostra espressione regolare.
<li>Per evitare la piaga del backslash, potete usare quella che viene chiamata stringa <i>raw</i> <span class=fixme>[FIXME reference to strings chapter]</span>, aggiungendo alla stringa un prefisso con la lettera <code>r</code>. Questo prefisso dice a Python che non deve essere eseguito alcun escape sul contenuto di quella stringa; <code>'\t'</code> è un carattere di tabulazione, ma <code>r'\t'</code> è effettivamente il carattere di backslash <code>\</code> seguito dalla lettera <code>t</code>. Vi raccomando di usare sempre stringhe raw quando avete a che fare con espressioni regolari; altrimenti, le cose diventano troppo confuse troppo velocemente (e le espressioni regolari sono già abbastanza confuse per conto proprio).
<li><em>*sigh*</em> Sfortunatamente, ho presto trovato altri esempi che contraddicevano la mia logica. In questo caso, l'indirizzo conteneva la parola <code>'ROAD'</code> come parola intera, ma non era alla fine, perché l'indirizzo aveva un numero di appartamento dopo il nome della via. Dato che <code>'ROAD'</code> non è alla fine della stringa, non c'è alcuna corrispondenza, quindi l'intera chiamata a <code>re.sub()</code> finisce per non sostituire nulla, e ottenete come risultato la stringa originale, che non è ciò che volete.
<li>Per risolvere questo problema, ho rimosso il carattere <code>$</code> e ho aggiunto un altro <code>\b</code>. Ora l'espressione regolare dice &#8220;trova una corrispondenza con <code>'ROAD'</code> quando è una parola intera in qualsiasi punto della stringa,&#8221; che sia alla fine, all'inizio, o da qualche parte nel mezzo.
</ol>
<h2 id=romannumerals>Caso di studio: numeri romani</h2>
<p>Avrete probabilmente già incontrato i numeri romani, anche se non li avete riconosciuti. Potreste averli visti nei copyright di vecchi film e spettacoli televisivi (&#8220;Copyright <code>MCMXLVI</code>&#8221; invece di &#8220;Copyright <code>1946</code>&#8221;), oppure sulle iscrizioni murali per la fondazione di biblioteche o università (&#8220;established <code>MDCCCLXXXVIII</code>&#8221; invece di &#8220;established <code>1888</code>&#8221;). Potreste averli visti anche negli indici dei libri o nei riferimenti bibliografici. &Egrave; un sistema di rappresentazione numerica che risale all'antico Impero romano (da cui il nome).
<p>Nei numeri romani, ci sono sette caratteri che sono ripetuti e combinati in vari modi per rappresentare i numeri.
<ul>
<li><code>I = 1</code>
<li><code>V = 5</code>
<li><code>X = 10</code>
<li><code>L = 50</code>
<li><code>C = 100</code>
<li><code>D = 500</code>
<li><code>M = 1000</code>
</ul>
<p>Le seguenti sono alcune regole generali per costruire i numeri romani:
<ul>
<li>I caratteri sono additivi. <code>I</code> è <code>1</code>, <code>II</code> è <code>2</code>, e <code>III</code> è <code>3</code>. <code>VI</code> è <code>6</code> (letteralmente, &#8220;<code>5</code> e <code>1</code>&#8221;), <code>VII</code> è <code>7</code>, e <code>VIII</code> è <code>8</code>.
<li>I caratteri delle decine (<code>I</code>, <code>X</code>, <code>C</code>, e <code>M</code>) possono essere ripetuti fino a tre volte. A <code>4</code>, dovete sottrarre dal carattere della cinquina più alta successiva. Non potete rappresentare <code>4</code> come <code>IIII</code>; invece, va rappresentato come <code>IV</code> (&#8220;<code>1</code> meno di <code>5</code>&#8221;). Il numero <code>40</code> è scritto come <code>XL</code> (<code>10</code> meno di <code>50</code>), <code>41</code> come <code>XLI</code>, <code>42</code> come <code>XLII</code>, <code>43</code> come <code>XLIII</code>, e poi <code>44</code> come <code>XLIV</code> (<code>10</code> meno di <code>50</code>, poi <code>1</code> meno di <code>5</code>).
<li>Similmente, a <code>9</code>, dovete sottrarre dal carattere della decina più alta successiva: <code>8</code> è <code>VIII</code>, ma <code>9</code> è <code>IX</code> (<code>1</code> meno di <code>10</code>), non <code>VIIII</code> (dato che il carattere <code>I</code> non può essere ripetuto quattro volte). Il numero <code>90</code> è <code>XC</code>, <code>900</code> è <code>CM</code>.
<li>I caratteri delle cinquine non possono essere ripetuti. Il numero <code>10</code> è sempre rappresentato come <code>X</code>, mai come <code>VV</code>. Il numero <code>100</code> è sempre <code>C</code>, mai <code>LL</code>.
<li>I numeri romani sono sempre scritti dal più alto al più basso e letti da sinistra a destra, così l'ordine dei caratteri ha molta importanza. <code>DC</code> è <code>600</code>; <code>CD</code> è un numero completamente differente (<code>400</code>, <code>100</code> meno di <code>500</code>). <code>CI</code> è <code>101</code>; <code>IC</code> non è nemmeno un numero romano valido (perché non potete sottrarre <code>1</code> direttamente da <code>100</code>; dovreste scriverlo come <code>XCIX</code>, per <code>10</code> meno di <code>100</code>, poi <code>1</code> meno di <code>10</code>).
</ul>
<h3 id=thousands>Controllare le migliaia</h3>
<p>Cosa ci vorrebbe per verificare che una stringa arbitraria sia un numero romano valido? Prendiamo una cifra alla volta. Dato che i numeri roman sono sempre scritti dalla cifra più alta a quella più bassa, cominciamo con la più alta: le migliaia. Per i numeri da 1000 in su, le migliaia sono rappresentate da una serie di caratteri <code>M</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd>import re</kbd>
<a><samp class=p>>>> </samp><kbd>pattern = '^M?M?M?$'</kbd>        <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'M')</kbd>     <span>&#x2461;</span></a>
<samp>&lt;SRE_Match object at 0106FB58></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MM')</kbd>    <span>&#x2462;</span></a>
<samp>&lt;SRE_Match object at 0106C290></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMM')</kbd>   <span>&#x2463;</span></a>
<samp>&lt;SRE_Match object at 0106AA38></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMMM')</kbd>  <span>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, '')</kbd>      <span>&#x2465;</span></a>
<samp>&lt;SRE_Match object at 0106F4A8></samp></pre>
<ol>
<li>Questo pattern ha tre parti. <code>^</code> fa corrispondere quanto segue solo se è all'inizio della stringa. Se questo non fosse specificato, il pattern troverebbe una corrispondenza a prescindere dalla posizione dei caratteri  <code>M</code>, che non è ciò che volete. Voi volete essere sicuri che i caratteri <code>M</code>, se ce ne sono, siano all'inizio della stringa. <code>M?</code> rappresenta una corrispondenza opzionale con un singolo carattere <code>M</code>. Ripetuto tre volte, rappresenta una corrispondenza con una stringa che contiene da zero a tre caratteri <code>M</code> di seguito. E <code>$</code> corrisponde alla fine della stringa. Combinato con il carattere <code>^</code> all'inizio, questo significa che il pattern cerca una corrispondenza con l'intera stringa, senza nessun altro carattere prima o dopo i caratteri <code>M</code>.
<li>L'essenza del modulo <code>re</code> è la funzione <code>search()</code>, che prende una espressione regolare (<var>pattern</var>) e una stringa (<code>'M'</code>) per provare a trovarvi una corrispondenza con l'espressione regolare. Se viene trovata una corrispondenza, <code>search()</code> restituisce un oggetto che ha vari metodi per descriverla; se non c'è alcuna corrispondenza, <code>search()</code> restituisce <code>None</code>, il valore nullo di Python. Tutto quello che vi interessa al momento è se il pattern trova una corrispondenza, cosa che potete capire guardando solamente al valore restituito da <code>search()</code>. <code>'M'</code> corrisponde a questa espressione regolare, perché la prima <code>M</code> opzionale corrisponde e la seconda e terza <code>M</code> opzionali vengono ignorate.
<li><code>'MM'</code> corrisponde perché la prima e la seconda <code>M</code> opzionali corrispondono e la terza <code>M</code> viene ignorata.
<li><code>'MMM'</code> corrisponde perché tutti e tre i caratteri <code>M</code> corrispondono.
<li><code>'MMMM'</code> non corrisponde. Tutti e tre i caratteri <code>M</code> corrispondono, ma poi l'espressione regolare insiste sulla fine della stringa (a causa del carattere <code>$</code>), e la stringa non è ancora terminata (a causa della quarta <code>M</code>). Quindi <code>search()</code> restituisce <code>None</code>.
<li>In maniera interessante, una stringa vuota corrisponde a questa espressione regolare, perché tutti i caratteri <code>M</code> sono opzionali.
</ol>
<h3 id=hundreds>Controllare le centinaia</h3>
<aside>? rende un pattern opzionale.</aside>
<p>Le centinaia sono più difficili delle migliaia, perché ci sono diversi modi mutuamente esclusivi in cui possono essere espresse, a seconda del loro valore.
<ul>
<li><code>100 = C</code>
<li><code>200 = CC</code>
<li><code>300 = CCC</code>
<li><code>400 = CD</code>
<li><code>500 = D</code>
<li><code>600 = DC</code>
<li><code>700 = DCC</code>
<li><code>800 = DCCC</code>
<li><code>900 = CM</code>
</ul>
<p>Quindi ci sono quattro possibili pattern:
<ul>
<li><code>CM</code>
<li><code>CD</code>
<li>Da zero a tre caratteri <code>C</code> (zero se la cifra delle centinaia nel numero intero corrispondente è 0)
<li><code>D</code>, seguito da zero fino a tre caratteri <code>C</code>
</ul>
<p>Gli ultimi due pattern possono essere combinati:
<ul>
<li>una <code>D</code> opzionale, seguita da zero fino a tre caratteri <code>C</code>
</ul>
<p>Questo esempio mostra come validare le centinaia di un numero romano.
<pre class=screen>
<samp class=p>>>> </samp><kbd>import re</kbd>
<a><samp class=p>>>> </samp><kbd>pattern = '^M?M?M?(CM|CD|D?C?C?C?)$'</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MCM')</kbd>             <span>&#x2461;</span></a>
<samp>&lt;SRE_Match object at 01070390></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MD')</kbd>              <span>&#x2462;</span></a>
<samp>&lt;SRE_Match object at 01073A50></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMMCCC')</kbd>          <span>&#x2463;</span></a>
<samp>&lt;SRE_Match object at 010748A8></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MCMC')</kbd>            <span>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, '')</kbd>                <span>&#x2465;</span></a>
<samp>&lt;SRE_Match object at 01071D98></samp></pre>
<ol>
<li>Questo pattern comincia allo stesso modo del precedente, controllando l'inizio della stringa (<code>^</code>), poi le migliaia (<code>M?M?M?</code>). Dopo ha la nuova parte, tra parentesi, che definisce un insieme di tre pattern mutuamente esclusivi, separati da barre verticali: <code>CM</code>, <code>CD</code>, e <code>D?C?C?C?</code> (che contiene una <code>D</code> opzionale seguita da zero fino a tre caratteri <code>C</code> opzionali). Il riconoscitore di espressioni regolari controlla ognuno di questi pattern nell'ordine dato (da sinistra a destra), prende il primo che corrisponde, e ignora il resto.
<li><code>'MCM'</code> corrisponde perché la prima <code>M</code> corrisponde, il secondo e terzo carattere <code>M</code> sono ignorati, e <code>CM</code> corrisponde (quindi i pattern <code>CD</code> e <code>D?C?C?C?</code> non vengono mai considerati). <code>MCM</code> è la rappresentazione di <code>1900</code> come numero romano.
<li><code>'MD'</code> corrisponde perché la prima <code>M</code> corrisponde, il secondo e terzo carattere <code>M</code> sono ignorati, e il pattern <code>D?C?C?C?</code> corrisponde a <code>D</code> (ognuno dei tre caratteri <code>C</code> opzionali viene ignorato). <code>MD</code> è la rappresentazione di <code>1500</code> come numero romano.
<li><code>'MMMCCC'</code> corrisponde perché tutti e tre i caratteri <code>M</code> corrispondono, e il pattern <code>D?C?C?C?</code> corrisponde a <code>CCC</code> (la <code>D</code> è opzionale e viene ignorata). <code>MMMCCC</code> è la rappresentazione di <code>3300</code> come numero romano.
<li><code>'MCMC'</code> non corrisponde. La prima <code>M</code> corrisponde, il secondo e terzo carattere <code>M</code> sono ignorati, e <code>CM</code> corrisponde, ma poi <code>$</code> non corrisponde perché non siete ancora alla fine della stringa (avete ancora un carattere <code>C</code> non corrisposto). Il carattere <code>C</code> non corrisponde come parte del pattern <code>D?C?C?C?</code>, perché il pattern mutuamente esclusivo <code>CM</code> ha già trovato una corrispondenza.
<li>In maniera interessante, una stringa vuota corrisponde ancora a questo pattern, perché tutti i caratteri <code>M</code> sono opzionali e ignorati, e la stringa vuota corrisponde al pattern <code>D?C?C?C?</code> dove tutti i caratteri sono opzionali e ignorati.
</ol>
<p>Whew! Vedete quanto le espressioni regolari possono diventare brutte velocemente? E avete solo trattato le migliaia e le centinaia dei numeri romani. Se però siete riusciti a seguire tutto questo, le decine e le unità sono facili, perché seguono esattamente lo stesso schema. Ma diamo un'occhiata a un altro modo di esprimere il pattern.
<h2 id=nmsyntax>Usare la sintassi <code>{n,m}</code></h2>
<aside>{1,4} corrisponde da 1 fino a 4 occorrenze di un pattern.</aside>
<p>Nella sezione precedente, avevate a che fare con un pattern dove lo stesso carattere poteva essere ripetuto fino a tre volte. C'è un altro modo, che alcune persone trovano più leggibile, per esprimere questo pattern in una espressione regolare. Prima di tutto diamo una occhiata al metodo che abbiamo già usato nell'esempio precedente.
<pre class=screen>
<samp class=p>>>> </samp><kbd>import re</kbd>
<samp class=p>>>> </samp><kbd>pattern = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'M')</kbd>     <span>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<samp class=p>>>> </samp><kbd>pattern = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MM')</kbd>    <span>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<samp class=p>>>> </samp><kbd>pattern = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMM')</kbd>   <span>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMMM')</kbd>  <span>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Questo trova una corrispondenza con l'inizio della stringa, e poi con la prima <code>M</code> opzionale, ma non con la seconda e la terza <code>M</code> (ma questo è OK perché sono opzionali), e poi con la fine della stringa.
<li>Questo trova una corrispondenza con l'inizio della stringa, e poi con la prima e la seconda <code>M</code> opzionali, ma non con la terza <code>M</code> (ma questo è OK perché è opzionale), e poi con la fine della stringa.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi con tutte e tre le <code>M</code> opzionali, e poi con la fine della stringa.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi con tutte e tre le <code>M</code> opzionali, ma non con la fine della stringa (perché c'è ancora una <code>M</code> senza corrispondenza), quindi il pattern non corrisponde e la funzione restituisce <code>None</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>pattern = '^M{0,3}$'</kbd>        <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'M')</kbd>     <span>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MM')</kbd>    <span>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMM')</kbd>   <span>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEDA8></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMMM')</kbd>  <span>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Questo pattern dice: &#8220;Trova una corrispondenza con l'inizio della stringa, poi da zero a tre caratteri <code>M</code>, poi la fine della stringa.&#8221; Lo 0 e il 3 possono essere qualsiasi numero; se volete trovare una corrispondenza con almeno uno ma non più di tre caratteri <code>M</code>, potete usare <code>M{1,3}</code>.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi una di tre possibili <code>M</code>, poi la fine della stringa.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi due di tre possibili <code>M</code>, poi la fine della stringa.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi tre di tre possibili <code>M</code>, poi la fine della stringa.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi tre di tre possibili <code>M</code>, ma <em>non</em> con la fine della stringa. L'espressione regolare permette solo fino a tre caratteri <code>M</code> prima della fine della stringa, ma ne avete quattro, quindi il pattern non corrisponde e la funzione restituisce <code>None</code>.
</ol>
<h3 id=tensandones>Controllare le decine e le unità</h3>
<p>Ora espandiamo l'espressione regolare dei numeri romani per trattare le decine e le unità. Questo esempio mostra il controllo sulle decine.
<pre class=screen>
<samp class=p>>>> </samp><kbd>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$'</kbd>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MCMXL')</kbd>     <span>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MCML')</kbd>      <span>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MCMLX')</kbd>     <span>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MCMLXXX')</kbd>   <span>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MCMLXXXX')</kbd>  <span>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Questo trova una corrispondenza con l'inizio della stringa, poi la prima <code>M</code> opzionale, poi <code>CM</code>, poi <code>XL</code>, poi la fine della stringa. Ricordate, la sintassi <code>(A|B|C)</code> significa &#8220;trova una corrispondenza con esattamente uno solo tra A, B, o C&#8221;. Avete trovato una corrispondenza con <code>XL</code>, quindi ignorate le scelte <code>XC</code> e <code>L?X?X?X?</code>, e poi vi muovete alla fine della stringa. <code>MCML</code> è la rappresentazione di <code>1940</code> come numero romano.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi la prima <code>M</code> opzionale, poi <code>L?X?X?X?</code>. Di <code>L?X?X?X?</code>, trova una corrispondenza con <code>L</code> e salta i tre caratteri <code>X</code> opzionali. Poi vi muovete alla fine della stringa. <code>MCML</code> è la rappresentazione di <code>1950</code> come numero romano.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi la prima <code>M</code> opzionale, poi <code>CM</code>, poi la <code>L</code> opzionale e la prima <code>X</code> opzionale, salta la seconda e la terza <code>X</code> opzionali, poi arriva alla fine della stringa. <code>MCMLX</code> è la rappresentazione di <code>1960</code> come numero romano.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi la prima <code>M</code> opzionale, poi <code>CM</code>, poi la <code>L</code> opzionale e tutti e tre i caratteri <code>X</code> opzionali, poi la fine della stringa. <code>MCMLXXX</code> è la rappresentazione di <code>1980</code> come numero romano.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi la prima <code>M</code> opzionale, poi <code>CM</code>, poi la <code>L</code> opzionale e tutti e tre i caratteri <code>X</code> opzionali, ma poi <em>fallisce la corrispondenza</em> con la fine della stringa perché c'è ancora una <code>X</code> di cui dar conto. Quindi l'intero pattern non corrisponde, e la funzione restituisce <code>None</code>. <code>MCMLXXXX</code> non è un numero romano valido.
</ol>
<aside>(A|B) corrisponde al pattern A oppure al pattern B.</aside>
<p>L'espressione per le unità segue lo stesso schema. Vi risparmierò i dettagli e vi mostrerò il risultato finale.
<pre class=screen>
<samp class=p>>>> </samp><kbd>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$'</kbd>
</pre><p>Come apparirebbe se usassimo la sintassi sostitutiva <code>{n,m}</code>? Questo esempio mostra la nuova sintassi.
<pre class=screen>
<samp class=p>>>> </samp><kbd>pattern = '^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'</kbd>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MDLV')</kbd>              <span>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMDCLXVI')</kbd>          <span>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMMDCCCLXXXVIII')</kbd>  <span>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'I')</kbd>                 <span>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp></pre>
<ol>
<li>Questo trova una corrispondenza con l'inizio della stringa, poi uno di quattro possibili caratteri <code>M</code>, poi <code>D?C{0,3}</code>. Di questo, trova una corrispondenza con la <code>D</code> opzionale e zero di tre possibili caratteri <code>C</code>. Proseguendo, trova una corrispondenza con <code>L?X{0,3}</code> attraverso la <code>L</code> opzionale e zero di tre possibili caratteri <code>X</code>. Poi trova una corrispondenza con <code>V?I{0,3}</code> attraverso la <code>V</code> opzionale e zero di tre possibili caratteri <code>I</code>, e infine con il termine della stringa. <code>MDLV</code> è la rappresentazione di <code>1555</code> come numero romano.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi due di quattro possibili caratteri <code>M</code>, poi <code>D?C{0,3}</code> tramite una <code>D</code> e uno di tre possibili caratteri <code>C</code>; poi <code>L?X{0,3}</code> tramite una <code>L</code> e uno di tre possibili caratteri <code>X</code>; poi <code>V?I{0,3}</code> con una <code>V</code> e uno di tre possibili caratteri <code>I</code>; poi la fine della stringa. <code>MMDCLXVI</code> è la rappresentazione di <code>2666</code> come numero romano.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi tre su tre caratteri <code>M</code>, poi <code>D?C{0,3}</code> tramite una <code>D</code> e tre su tre caratteri <code>C</code>; poi <code>L?X{0,3}</code> tramite una <code>L</code> e tre su tre caratteri <code>X</code>; poi <code>V?I{0,3}</code> tramite una <code>V</code> e tre su tre caratteri <code>I</code>; poi la fine della stringa. <code>MMMDCCCLXXXVIII</code> è la rappresentazione di <code>3888</code> come numero romano, ed è il numero romano più lungo che potete scrivere senza la sintassi estesa.
<li>Guardate attentamente. (Mi sento come un mago. &#8220;Guardate attentamente, bambini. Sto per estrarre un coniglio dal mio cappello.&#8221;) Questo trova una corrispondenza con l'inizio della stringa, poi zero su quattro <code>M</code>, poi trova una corrispondenza con <code>D?C{0,3}</code> saltando la <code>D</code> opzionale e trovando zero su tre <code>C</code>, poi trova una corrispondenza con <code>L?X{0,3}</code> saltando la <code>L</code> opzionale e trovando zero su tre <code>X</code>, poi trova una corrispondenza con <code>V?I{0,3}</code> saltando la <code>V</code> opzionale e trovando una di tre <code>I</code>. Poi la fine della stringa. Whoa.
</ol>
<p>Se avete seguito tutto questo e lo avete capito alla prima lettura, state andando meglio di me. Ora immaginate di provare a capire l'espressione regolare di qualcun altro, in mezzo a una funzione critica di un lungo programma. O immaginate addirittura di tornare a una vostra espressione regolare qualche mese dopo averla scritta. Io l'ho fatto, e non è stata una bella esperienza.
<p>Ora esploriamo una sintassi alternativa che può aiutarvi a manutenere le vostre espressioni regolari.
<h2 id=verbosere>Espressioni regolari verbose</h2>
<p>Finora avete avuto a che fare solamente con quelle che chiamerò espressioni regolari &#8220;compatte&#8221;. Come avete visto, sono difficili da leggere, e anche se capite cosa fa una di esse, non c'è alcuna garanzia che sarete in grado di capirlo nuovamente sei mesi dopo. Quello di cui avete davvero bisogno è documentazione in linea.
<p>Python vi permette di ottenerla con qualcosa chiamato <i>espressioni regolari verbose</i>. Una espressione regolare verbosa è differente da una espressione regolare compatta sotto due aspetti:
<ul>
<li>Lo spazio bianco viene ignorato. Spazi, tabulazioni e ritorni a capo non corrispondono a spazi, tabulazioni e ritorni a capo. Non vengono mai utilizzati. (Se volete utilizzare uno spazio in una espressione regolare verbosa, dovete farne l'escape mettendogli davanti un backslash.)
<li>I commenti sono ignorati. Un commento in una espressione regolare verbosa è come un commento nel codice Python: comincia con un carattere <code>#</code> e prosegue fino alla fine della riga. In questo caso è un commento all'interno di una stringa su più righe invece che all'interno del vostro codice sorgente, ma funziona allo stesso modo.
</ul>
<p>Queste differenze diventeranno più chiare con un esempio. Rivediamo l'espressione regolare compatta con la quale stavate lavorando, e trasformiamola in una espressione regolare verbosa. Questo esempio mostra come fare.
<pre class=screen>
<samp class=p>>>> </samp><kbd>pattern = """
    ^                   # beginning of string
    M{0,3}              # thousands - 0 to 3 M's
    (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C's),
                        #            or 500-800 (D, followed by 0 to 3 C's)
    (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X's),
                        #        or 50-80 (L, followed by 0 to 3 X's)
    (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I's),
                        #        or 5-8 (V, followed by 0 to 3 I's)
    $                   # end of string
    """</kbd>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'M', re.VERBOSE)</kbd>                 <span>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MCMLXXXIX', re.VERBOSE)</kbd>         <span>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'MMMDCCCLXXXVIII', re.VERBOSE)</kbd>  <span>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd>re.search(pattern, 'M')</kbd>                             <span>&#x2463;</span></a></pre>
<ol>
<li>La cosa più importante da ricordare quando usate le espressioni regolari verbose è che avete bisogno di passare un argomento aggiuntivo quando lavorate con esse: <code>re.VERBOSE</code> è una costante definita nel modulo <code>re</code> usata per segnalare che il pattern dovrebbe essere trattato come una espressione regolare verbosa. Come potete vedere, questo pattern ha un bel po' di spazi bianchi (che vengono tutti ignorati) e diversi commenti (che vengono tutti ignorati). Una volta che ignorate gli spazi bianchi e i commenti, questa è esattamente la stessa espressione regolare che avete visto nella sezione precedente, ma è molto più leggibile.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi una di tre possibili <code>M</code>, poi <code>CM</code>, poi <code>L</code> e tre di tre possibili <code>X</code>, poi <code>IX</code>, poi la fine della stringa.
<li>Questo trova una corrispondenza con l'inizio della stringa, poi tre di tre possibili <code>M</code>, poi <code>D</code> e tre di tre possibili <code>C</code>, poi <code>L</code> e tre di tre possibili <code>X</code>, poi <code>V</code> e tre di tre possibili <code>I</code>, poi la fine della stringa.
<li>Questo non trova alcuna corrispondenza. Perché? Perché non ha il flag <code>re.VERBOSE</code>, quindi la funzione <code>re.search()</code> tratta il pattern come una espressione regolare compatta, dove gli spazi bianchi hanno significato e i simboli di hash sono letterali. Python non è in grado di scoprire da solo se una espressione regolare è verbosa oppure no. Python presume che ogni espressione regolare sia compatta a meno che non gli diciate esplicitamente che è verbosa.
</ol>
<h2 id=phonenumbers>Caso di studio: riconoscere i numeri di telefono</h2>
<aside>\d corrisponde a qualsiasi cifra numerica (0&ndash;9). \D corrisponde a qualsiasi cosa tranne le cifre.</aside>
<p>Finora vi siete concentrati a trovare corrispondenze con interi pattern. Un pattern corrisponde, oppure no. Ma le espressioni regolari sono molto più potenti di così. Quando una espressione regolare <em>trova</em> una corrispondenza, potete recuperarne dei pezzi specifici. Potete trovare cosa corrisponde dove.
<p>Questo esempio proviene da un altro problema reale, incontrato ancora una volta in un precedente lavoro. Il problema: riconoscere un numero telefonico americano. Il cliente voleva essere in grado di introdurre il numero senza alcun vincolo (in un singolo campo), ma poi voleva memorizzare separatamente il codice d'area, il prefisso, il numero e opzionalmente una estensione nel database della compagnia. Ho rovistato nel Web e trovato molti esempi di espressioni regolari che dichiaravano di fare proprio questo, ma nessuna era abbastanza permissiva.
<p>Ecco i numeri telefonici che avevo bisogno di essere in grado di accettare:
<ul>
<li><code>800-555-1212</code>
<li><code>800 555 1212</code>
<li><code>800.555.1212</code>
<li><code>(800) 555-1212</code>
<li><code>1-800-555-1212</code>
<li><code>800-555-1212-1234</code>
<li><code>800-555-1212x1234</code>
<li><code>800-555-1212 ext. 1234</code>
<li><code>work 1-(800) 555.1212 #1234</code>
</ul>
<p>Una gran varietà! In ognuno di questi casi, avevo bisogno di sapere che il codice d'area era <code>800</code>, il prefisso <code>555</code>, e il resto del numero telefonico <code>1212</code>. Per quelli con una estensione, avevo bisogno di sapere che quella estensione era <code>1234</code>.
<p>Lavoriamo per sviluppare una soluzione al riconoscimento dei numeri di telefono. Questo esempio mostra il primo passo.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})$')</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212').groups()</kbd>             <span>&#x2461;</span></a>
<samp>('800', '555', '1212')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212-1234')</kbd>                 <span>&#x2462;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Leggete sempre una espressione regolare da sinistra a destra. Questa trova una corrispondenza con l'inizio della stringa, e poi con <code>(\d{3})</code>. Cos'è <code>\d{3}</code>?  Be', <code>{3}</code> significa &#8220;trova una corrispondenza con esattamente tre cifre numeriche&#8221;; è una variazione della <a href="#re.nm" title="7.4. Using the {n,m} Syntax">sintassi <code>{n,m}</code></a> che avete visto prima. <code>\d</code> significa &#8220;qualsiasi cifra numerica&#8221; (da <code>0</code> fino a <code>9</code>). Metterlo tra parentesi significa &#8220;trova una corrispondenza con esattamente tre cifre numeriche, <em>e poi memorizzala come un gruppo che posso chiederti più tardi</em>&#8221;. L'espressione regolare trova quindi una corrispondenza con un trattino letterale. Poi trova una corrispondenza con un altro gruppo di esattamente tre cifre. Poi un altro trattino letterale. Poi un altro gruppo di esattamente quattro cifre. Poi trova una corrispondenza con la fine della stringa.
<li>Per avere accesso ai gruppi che il motore di espressioni regolari ha memorizzato durante il riconoscimento, usate il metodo <code>groups()</code> sull'oggetto che il metodo <code>search()</code> vi restituisce. Invocare <code>groups()</code> vi restituirà una tupla di tanti gruppi quanti ne avete definiti nella espressione regolare. In questo caso, avete definito tre gruppi, uno con tre cifre, uno con tre cifre, e uno con quattro cifre.
<li>Questa espressione regolare non è la risposta finale, perché non gestisce un numero telefonico con una estensione alla fine. Per questo, avrete bisogno di espandere l'espressione regolare.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})-(\d+)$')</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212-1234').groups()</kbd>              <span>&#x2461;</span></a>
<samp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800 555 1212 1234')</kbd>                       <span>&#x2462;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212')</kbd>                            <span>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Questa espressione regolare è quasi identica alla precedente. Esattamente come prima, trova una corrispondenza con l'inizio della stringa, poi con un gruppo di tre cifre da memorizzare, poi un trattino, poi un gruppo di tre cifre da memorizzare, poi un trattino, poi un gruppo di quattro cifre da memorizzare. Quello che c'è di nuovo è che poi trova una corrispondenza con un altro trattino, e un gruppo di una o più cifre da memorizzare, e poi la fine della stringa.
<li>Il metodo <code>groups()</code> ora restituisce una tupla di quattro elementi, dato che l'espressione regolare ora definisce quattro gruppi da memorizzare.
<li>Sfortunatamente, anche questa espressione regolare non è la risposta finale, perché presume che le differenti parti di un numero telefonico siano separate da trattini. E se invece fossero separate da spazi, o virgole, o punti? Avete bisogno di una soluzione più generale per trovare una corrispondenza con diversi tipi di separatori.
<li>Oops! Non solo questa espressione regolare non fa tutto quello che volete, ma in realtà è un passo indietro, perché ora non potete più riconoscere numeri telefonici <em>senza</em> una estensione. Questo non è per niente quello che volevate; se l'estensione c'è, volete sapere qual è, ma se non è presente, volete comunque sapere quali sono le diverse parti del numero principale.
</ol>
<p>L'esempio seguente mostra l'espressione regolare che gestisce i separatori tra le diverse parti del numero di telefono.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>phonePattern = re.compile(r'^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$')</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800 555 1212 1234').groups()</kbd>  <span>&#x2461;</span></a>
<samp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212-1234').groups()</kbd>  <span>&#x2462;</span></a>
<samp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('80055512121234')</kbd>              <span>&#x2463;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212')</kbd>                <span>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Tenetevi stretto il vostro cappello. State trovando una corrispondenza con l'inizio della stringa, poi un gruppo di tre cifre, poi <code>\D+</code>. Cosa diavolo è quello? Ebbene, <code>\D</code> corrisponde a qualsiasi carattere <em>tranne</em> una cifra numerica, e <code>+</code> significa &#8220;1 o più&#8221;. Così <code>\D+</code> corrisponde a uno o più caratteri che non sono cifre. Questo è quello che usate al posto di un trattino letterale, per provare a trovare una corrispondenza con separatori differenti.
<li>Usare <code>\D+</code> invece di <code>-</code> significa che ora potete trovre una corrispondenza con numeri le cui parti sono separate da spazi invece che trattini.
<li>Naturalmente, i numeri telefonici separati da trattini funzionano ancora.
<li>Sfortunatamente, questa non è ancora la risposta finale, perché presume che ci sia sempre un separatore. E se il numero telefonico fosse introdotto senza alcuno spazio o trattino?
<li>Oops! Questo non ha ancora risolto il problema della estensione obbligatoria. Ora avete due problemi, ma potete risolverli entrambi con la stessa tecnica.
</ol>
<p>Il prossimo esempio mostra l'espressione regolare per gestire numeri di telefono <em>senza</em> separatori.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>phonePattern = re.compile(r'^(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('80055512121234').groups()</kbd>      <span>&#x2461;</span></a>
<samp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800.555.1212 x1234').groups()</kbd>  <span>&#x2462;</span></a>
<samp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212').groups()</kbd>        <span>&#x2463;</span></a>
<samp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('(800)5551212 x1234')</kbd>           <span>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>L'unico cambiamento che avete fatto dall'ultimo passo è sostituire tutti i <code>+</code> con <code>*</code>. Invece di <code>\D+</code> tra le parti del numero telefonico, ora trovate una corrispondenza con <code>\D*</code>. Ricordate che <code>+</code> significa &#8220;1 o più&#8221;?  Ebbene, <code>*</code> significa &#8220;zero o più&#8221;. Così ora dovreste essere in grado di riconoscere i numeri telefonici anche quando non c'è alcun carattere di separazione.
<li>E guardate un po', effettivamente funziona. Perché? Trovate una corrispondenza con l'inizio della stringa, poi un gruppo di tre cifre da memorizzare (<code>800</code>), poi zero caratteri non numerici, poi un gruppo di tre cifre da memorizzare (<code>555</code>), poi zero caratteri non numerici, poi un gruppo di quattro cifre da memorizzare (<code>1212</code>), poi zero caratteri non numerici, poi un gruppo di un numero arbitrario di cifre da memorizzare (<code>1234</code>), poi la fine della stringa.
<li>Anche altre variazioni funzionano, adesso: punti invece di trattini, e sia uno spazio che una <code>x</code> prima della estensione.
<li>Infine, avete risolto l'altro annoso probelma: le estensioni sono di nuovo opzionali. Se nessuna estensione viene trovata, il metodo <code>group()</code> restituisce ancora una tupla di quattro elementi, ma il quarto elemento è solamente una stringa vuota.
<li>Odio portare cattive notizie, ma non avete ancora finito. Qual è il problema qui? C'è un carattere in più prima del codice d'area, ma l'espressione regolare presume che il codice d'area sia la prima cosa all'inizio della stringa. Nessun problema, potete usare la stessa tecnica degli &#8220;zero o più caratteri non numerici&#8221; per saltare i caratteri iniziali prima del codice d'area.
</ol>
<p>L'esempio seguente mostra come gestire i caratteri iniziali nei numeri di telefono.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>phonePattern = re.compile(r'^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('(800)5551212 ext. 1234').groups()</kbd>                  <span>&#x2461;</span></a>
<samp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212').groups()</kbd>                            <span>&#x2462;</span></a>
<samp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('work 1-(800) 555.1212 #1234')</kbd>                      <span>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Questo è lo stesso pattern dell'esempio precedente, a parte il fatto che ora state trovando una corrispondenza con <code>\D*</code>, zero o più caratteri non numerici, prima del primo gruppo da memorizzare (il codice d'area). Notate che non state memorizzando questi caratteri non numerici (non sono tra parentesi). Se li trovate, semplicemente li saltate e poi cominciate a memorizzare il codice d'area in qualsiasi punto si trovi.
<li>Potete riconoscere i numeri telefonici con successo anche con una parentesi aperta prima del codice d'area. (La parentesi chiusa dopo il codice d'area è già gestita; viene trattata come un separatore non numerico e corrisponde al <code>\D*</code> dopo il primo gruppo da memorizzare.)
<li>Giusto come <span class=wtf>sanity check</span> per assicurarvi di non aver rotto nulla che prima funzionava. Dato che i caratteri iniziali sono interamente opzionali, questo trova una corrispondenza con l'inizio della stringa, poi zero caratteri non numerici, poi un gruppo di tre cifre da memorizzare (<code>800</code>), poi un carattere non numerico (il trattino), poi un gruppo di tre cifre da memorizzare (<code>555</code>), poi un carattere non numerico (il trattino), poi un gruppo di quattro cifre da memorizzare (<code>1212</code>), poi zero caratteri non numerici, poi un gruppo di zero cifre da memorizzare, poi la fine della stringa.
<li>Qui è dove le espressioni regolari mi fanno venire voglia di cavarmi gli occhi con un oggetto spuntato. Perché questo numero di telefono non corrisponde? Perché c'è un <code>1</code> prima del codice d'area, ma avete supposto che tutti i caratteri prima del codice d'area fossero caratteri non numerici (<code>\D*</code>). Aargh.
</ol>
<p>Rivediamo il nostro lavoro per un secondo. Finora le espressioni regolari hanno tutte trovato una corrispondenza dall'inizio della stringa. Ma ora vedete che ci potrebbe essere una quantità indeterminata di caratteri all'inizio della stringa che volete ignorare. Piuttosto che provare a trovare una corrispondenza con tutta quella roba solo per scartarla, adottiamo un approccio differente: evitiamo di cercare esplicitamente una corrispondenza con l'inizio della stringa. Questo approccio è mostrato nel prossimo esempio.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>phonePattern = re.compile(r'(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>         <span>&#x2461;</span></a>
<samp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212')</kbd>                                 <span>&#x2462;</span></a>
<samp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('80055512121234')</kbd>                               <span>&#x2463;</span></a>
<samp>('800', '555', '1212', '1234')</samp></pre>
<ol>
<li>Notate la mancanza di <code>^</code> in questa espressione regolare. Non state più trovando una corrispondenza con l'inizio della stringa. Non c'è niente che dica che avete bisogno di trovare una corrispondenza tra l'intera stringa in ingresso e la vostra espressione regolare. Il riconoscitore di espressioni regolari farà il duro lavoro di capire quando la stringa in ingresso comincerà a corrispondere, e proseguirà da lì.
<li>Ora potete riconoscere con successo un numero telefonico che include caratteri iniziali e una cifra iniziale, più un qualsaisi numero di qualsiasi tipo di separatori attorno a ogni parte del numero telefonico.
<li><span class=wtf>Sanity check</span>. Questo funziona ancora.
<li>Anche questo funziona ancora.
</ol>
<p>Avete visto quanto velocemente una espressione regolare può finire fuori controllo? Date una rapida occhiata a una qualsiasi delle iterazioni precedenti. Potete dire la differenza tra quella e la successiva?
<p>Mentre avete ancora ben chiara la risposta finale (ed è la risposta finale; se avete scoperto un caso che non gestisce, non voglio saperlo) scriviamola come una espressione regolare verbosa, prima di dimenticare perché avete fatto le scelte che avete fatto.
<pre class=screen>
<samp class=p>>>> </samp><kbd>phonePattern = re.compile(r'''
                # don't match beginning of string, number can start anywhere
    (\d{3})     # area code is 3 digits (e.g. '800')
    \D*         # optional separator is any number of non-digits
    (\d{3})     # trunk is 3 digits (e.g. '555')
    \D*         # optional separator
    (\d{4})     # rest of number is 4 digits (e.g. '1212')
    \D*         # optional separator
    (\d*)       # extension is optional and can be any number of digits
    $           # end of string
    ''', re.VERBOSE)</kbd>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>  <span>&#x2460;</span></a>
<samp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd>phonePattern.search('800-555-1212')</kbd>                          <span>&#x2461;</span></a>
<samp>('800', '555', '1212', '')</samp></pre>
<ol>
<li>A parte il fatto di essere distribuita su più righe, questa è esattamente l'espressione regolare dell'ultimo passo, quindi non ci sorprende che riconosca gli stessi ingressi.
<li><span class=wtf>sanity check</span> finale. Sì, funziona ancora. Avete finito.
</ol>
<h2 id=summary>Riepilogo</h2>
<p>Questa è solo la più piccola cima dell'iceberg di quello che le espressioni regolari possono fare. In altre parole, anche se ora siete completamente sommersi da esse, credetemi, non avete ancora visto niente.
<p>Ora dovreste avere familiarità con le seguenti tecniche:
<ul>
<li><code>^</code> corrisponde all'inizio di una stringa.
<li><code>$</code> corrisponde alla fine di una stringa.
<li><code>\b</code> corrisponde a un limite di una parola.
<li><code>\d</code> corrisponde a qualsiasi cifra numerica.
<li><code>\D</code> corrisponde a qualsiasi carattere non numerico.
<li><code>x?</code> corrispondere a un carattere <code>x</code> opzionale (in altre parole, corrisponde a una <code>x</code> zero o una volta).
<li><code>x*</code> corrisponde a <code>x</code> zero o più volte.
<li><code>x+</code> corrisponde a <code>x</code> una o più volte.
<li><code>x{n,m}</code> corrisponde a un carattere <code>x</code> almeno <code>n</code> volte, ma non più di <code>m</code> volte.
<li><code>(a|b|c)</code> corrisponde ad <code>a</code> o <code>b</code> o <code>c</code>.
<li><code>(x)</code> in generale è un <em>gruppo di memorizzazione</em>. Potete ottenere il valore di ciò che vi corrisponde usando il metodo <code>groups()</code> dell'oggetto restituito da <code>re.search()</code>.
</ul>
<p>Le espressioni regolari sono estremamente potenti, ma non sono la soluzione corretta per tutti i problemi. Dovreste imparare abbastanza su di loro da sapere quando sono appropriate, quando risolveranno i vostri problemi, e quando causeranno più problemi di quelli che risolvono.
<p class=nav><a rel=prev href=stringhe.html title="indietro a &#8220;Stringhe&#8221;"><span>&#x261C;</a> <a rel=next href=generatori.html title="avanti a &#8220;Generatori&#8221;"><span>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;9 <a href=about.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=translation.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
