<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Il vostro primo programma Python - Dive into Python 3</title>
<!--[if IE]><script src=html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<link rel=stylesheet href=dip3-it.css>
<style>
body{counter-reset:h1 1}
table{border:1px solid #bbb;border-collapse:collapse;margin:auto}
td,th{border:1px solid #bbb;padding:0 1.75em}
th{text-align:left}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#il-vostro-primo-programma-python>Dive Into Python 3</a> <span>&#8227;</span>
<p id=level>Livello di difficoltà: <span title=novizio>&#x2666;&#x2662;&#x2662;&#x2662;&#x2662;</span>
<h1>Il vostro primo programma Python</h1>
<blockquote class=q>
<p><span>&#x275D;</span> Non nascondere le tue difficoltà dietro un silenzio da santo. Hai un problema? Ottimo. Rallegrati, immergiti e investiga. <span>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Buddhism>Ven. Henepola Gunaratana</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>Di solito, i libri di programmazione cominciano con una serie di capitoli noiosi sui fondamentali, e solo verso la fine arrivano a costruire qualcosa di utile. Noi ci risparmieremo questa attesa. Qui di seguito troverete subito un programma Python completo e funzionante. Probabilmente ora non ha alcun senso per voi, ma non preoccupatevi perché lo analizzerete riga per riga. Provate comunque a leggerlo, prima di tutto, per vedere se riuscite a ricavarne qualcosa.
<p class=d>[<a href=esempi/humansize.py>scarica <code>humansize.py</code></a>]
<pre><code>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}

def approximate_size(size, a_kilobyte_is_1024_bytes=True):
    """Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

    """
    if size &lt; 0:
        raise ValueError('number must be non-negative')

    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size &lt; multiple:
            return "{0:.1f} {1}".format(size, suffix)

    raise ValueError('number too large')

if __name__ == "__main__":
    print(approximate_size(1000000000000, False))
    print(approximate_size(1000000000000))</code></pre>
<p>Ora eseguiamo il programma dalla linea di comando. Sotto Windows, avremo qualcosa di simile a questo:
<pre class=screen>
<samp class=p>c:\home\diveintopython3> </samp><kbd>c:\python30\python.exe humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>
<p>Sotto Mac OS X o Linux, avremo qualcosa di simile a questo:
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>

<p>Che cos'è appena successo? Avete eseguito il vostro primo programma Python. Avete chiamato l'interprete Python dalla  linea di comando, e gli avete passato il nome dello script che volevate far eseguire all'interprete. Lo script definisce una singola funzione, la funzione <code>approximate_size()</code>, che prende una dimensione esatta di un file in byte e ne calcola una versione più &#8220;carina&#8221; (ma approssimata). (Lo avete probabilmente visto fare in Esplora risorse sotto Windows, o nel Finder di Mac OS X, o in Nautilus o Dolphin o Thunar sotto Linux. Se visualizzate una cartella di documenti come una lista a più colonne, il programma mostrerà una tabella con l'icona di ogni documento, il nome, la dimensione, il tipo, la data dell'ultima modifica, e così via. Se la cartella contiene un file di 1093 byte chiamato <code>TODO</code>, il vostro programma di gestione dei file non visualizzerà <code>TODO 1093 byte</code>; invece, vi mostrerà qualcosa di simile a <code>TODO 1 KB</code>. Questo è ciò che fa la funzione <code>approximate_size()</code>.)

<p>Guardate in fondo allo script e vedrete due chiamate a <code>print(approximate_size(<var>arguments</var>))</code>. Queste sono invocazioni di funzione &mdash; prima chiamano la funzione <code>approximate_size()</code> passandole un certo numero di argomenti, poi prendono il valore di ritorno e lo passano direttamente alla funzione <code>print()</code>. La funzione <code>print()</code> è predefinita; non ne vedrete mai la dichiarazione esplicita. Potete semplicemente usarla, sempre e dovunque. (Ci sono un sacco di funzioni predefinite, e un sacco di altre funzioni che sono suddivise in <i>moduli</i>. Pazienta, cavalletta.)

<p>Quindi perché l'esecuzione dello script dalla linea di comando vi restituisce ogni volta gli stessi risultati? Ci arriveremo. Prima di tutto, diamo un'occhiata alla funzione <code>approximate_size()</code>.

<h2 id=declaringfunctions>Dichiarare funzioni</h2>
<p>Python vi permette di definire funzioni come la maggior parte degli altri linguaggi, ma non utilizza file di intestazione separati come il <abbr>C++</abbr> o sezioni di <code>interface</code>/<code>implementation</code> come il Pascal. Quando avete bisogno di una funzione, vi basta dichiararla, in questo modo:  
<pre><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):</code></pre>
<aside>Quando avete bisogno di una funzione, vi basta dichiararla.</aside>
<p>La parola chiave <code>def</code> inizia la dichiarazione di funzione, seguita dal nome della funzione, seguito dagli argomenti della funzione racchiusi tra parentesi. Argomenti multipli sono separati da virgole.
<p>Notate anche che la funzione non definisce un tipo di dato di ritorno. Le funzioni Python non specificano il tipo di dato del loro valore di ritorno; non specificano nemmeno se restituiscono o no un valore. (In effetti, ogni funzione Python restituisce un valore; se la funzione esegue una istruzione di <code>return</code>, restituirà quel valore, altrimenti restituirà <code>None</code>, il valore nullo di Python.)
<blockquote class=note>
<p><span>&#x261E;</span>In alcuni linguaggi, le funzioni (che restituiscono un valore) cominciano con <code>function</code>, e le procedure (che non restituiscono un valore) cominciano con <code>sub</code>. Non ci sono procedure in Python. Ci sono solo funzioni, tutte le funzioni restituiscono un valore (anche se è <code>None</code>) e tutte le funzioni cominciano con <code>def</code>.
</blockquote>
<p>La funzione <code>approximate_size()</code> accetta due argomenti &mdash; <var>size</var> e <var>a_kilobyte_is_1024_bytes</var> &mdash; ma nessun argomento dichiara il proprio tipo. In Python, le variabili non sono mai esplicitamente tipate. L'interprete Python capisce da solo qual è il tipo di una variable e ne tiene traccia internamente.
<blockquote class="note compare java">
<p><span>&#x261E;</span>In Java e in altri linguaggi staticamente tipati, dovete dichiarare il tipo del valore di ritorno e di ogni argomento della funzione. In Python, i tipi non vengono mai dichiarati. Sulla base del valore che viene assegnato, Python tiene traccia del tipo di dato internamente.
</blockquote>

<h3 id=optional-arguments>Argomenti opzionali e con nome</h3>

<p>Python consente agli argomenti di funzione di avere valori di default; se una funzione viene chiamata senza un argomento, quell'argomento viene impostato al suo valore di default. In più, gli argomenti possono essere specificati in qualsiasi ordine utilizzando argomenti con nome.

<p>Diamo un'altra occhiata a quella dichiarazione della funzione <code>approximate_size()</code>:

<pre><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):</code></pre>

<p>Il secondo argomento, <var>a_kilobyte_is_1024_bytes</var>, specifica un valore di default pari a <code>True</code>. Questo significa che l'argomento è <i>opzionale</i>; potete invocare la funzione senza di esso, e Python agirà come se l'aveste invocata passando <code>True</code> come secondo parametro.

<p>Ora guardate in fondo allo script:

<pre><code>
if __name__ == "__main__":
<a>    print(approximate_size(1000000000000, False))  <span>&#x2460;</span></a>
<a>    print(approximate_size(1000000000000))         <span>&#x2461;</span></a></code></pre>
<ol>
<li>Questa riga invoca la funzione <code>approximate_size()</code> con due argomenti. All'interno della funzione <code>approximate_size()</code>, <var>a_kilobyte_is_1024_bytes</var> varrà <code>False</code>, dato che avete esplicitamente passato <code>False</code> come secondo argomento.
<li>Questa riga invoca la funzione <code>approximate_size()</code> con un solo argomento. Ma questo è OK, perché il secondo argomento è opzionale! Dato che il chiamante non lo specifica, il secondo argomento assumerà il proprio valore di default <code>True</code>, come definito nella dichiarazione di funzione.
</ol>

<p>I valori degli argomenti di una funzione possono anche essere passati per nome.

<pre class=screen>
<samp class=p>>>> </samp><kbd>from humansize import approximate_size</kbd>
<a><samp class=p>>>> </samp><kbd>approximate_size(4000, a_kilobyte_is_1024_bytes=False)</kbd>       <span>&#x2460;</span></a>
<samp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd>approximate_size(size=4000, a_kilobyte_is_1024_bytes=False)</kbd>  <span>&#x2461;</span></a>
<samp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd>approximate_size(a_kilobyte_is_1024_bytes=False, size=4000)</kbd>  <span>&#x2462;</span></a>
<samp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd>approximate_size(a_kilobyte_is_1024_bytes=False, 4000)</kbd>       <span>&#x2463;</span></a>
<samp class=traceback>  File "&lt;stdin>", line 1
SyntaxError: non-keyword arg after keyword arg</samp>
<a><samp class=p>>>> </samp><kbd>approximate_size(size=4000, False)</kbd>                           <span>&#x2464;</span></a>
<samp class=traceback>  File "&lt;stdin>", line 1
SyntaxError: non-keyword arg after keyword arg</samp></pre>
<ol>
<li>Questa è una invocazione della funzione <code>approximate_size()</code> con <code>4000</code> come valore per il primo argomento (<var>size</var>) e <code>False</code> come valore per il secondo argomento chiamato <var>a_kilobyte_is_1024_bytes</var>. (Si dà il caso che questo sia effettivamente il secondo argomento, ma la cosa non ha importanza, come vedrete fra un minuto.)
<li>Questa è una invocazione della funzione <code>approximate_size()</code> con <code>4000</code> come valore per l'argomento chiamato <var>size</var> e <code>False</code> come valore per l'argomento chiamato <var>a_kilobyte_is_1024_bytes</var>. (Si dà il caso che questi argomenti con nome siano nello stesso ordine in cui sono elencati gli argomenti nella dichiarazione di funzione, ma anche questo non ha importanza.)
<li>Questa è una invocazione della funzione <code>approximate_size()</code> con <code>False</code> come valore per l'argomento chiamato <var>a_kilobyte_is_1024_bytes</var> e <code>4000</code> come valore per l'argomento chiamato <var>size</var>. (Vedete? Vi avevo detto che l'ordine non ha importanza.)
<li>Questa invocazione fallisce, perché passate un argomento con nome seguito da un argomento (di tipo posizionale) senza nome, e questo non funziona mai. Leggendo la lista degli argomenti da sinistra a destra, una volta che utilizzate un singolo argomento con nome anche il resto degli argomenti deve essere dello stesso tipo.
<li>Anche questa invocazione fallisce, per lo stesso motivo della precedente. Vi sorprende? Dopo tutto, avete passato <code>4000</code> come valore per l'argomento chiamato <code>size</code>, poi &#8220;ovviamente&#8221; intendevate passare quel valore <code>False</code> all'argomento <var>a_kilobyte_is_1024_bytes</var>. Ma Python non funziona in questo modo. Appena utilizzate un argomento con nome, anche tutti gli argomenti alla destra di quell'argomento devono essere argomenti con nome.
</ol>

<h2 id=readability>Scrivere codice leggibile</h2>
<p>Non vi annoierò con una lunga predica sull'importanza di documentare il vostro codice. Vi basti sapere che il codice viene scritto una volta sola ma letto molte volte, e che i lettori più importanti del vostro codice siete voi stessi, sei mesi dopo averlo scritto (cioè dopo che vi siete dimenticati tutto ma avete bisogno di correggere qualcosa). Python facilita la scrittura di codice leggibile, perciò avantaggiatevene. Fra sei mesi mi ringrazierete.
<h3 id=docstrings>Stringhe di documentazione</h3>
<p>Potete documentare una funzione Python aggiungendole una stringa di documentazione (chiamata <code>docstring</code> per brevità). Nel nostro programma, la funzione <code>approximate_size</code> è stata dotata di una <code>docstring</code>:
<pre><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):
    """Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

    """</code></pre>
<aside>Ogni funzione merita una docstring decente.</aside>
<p>Le triple virgolette servono per rappresentare una stringa su più righe. Ogni cosa tra le virgolette di inizio e di fine è parte di una singola stringa, inclusi i ritorni a capo, gli spazi bianchi all'inizio di una riga, e altri caratteri di virgolette. Le triple virgolette si possono usare dovunque, ma le vedrete sfruttate soprattutto nella definizione di una <code>docstring</code>.
<blockquote class="note compare perl5">
<p><span>&#x261E;</span>Le triple virgolette sono anche un modo facile per definire una stringa che contiene sia apici che virgolette, come <code>qq/.../</code> in Perl 5.
</blockquote>
<p>Tutto quello che si trova tra le triple virgolette rappresenta la <code>docstring</code> della funzione, che documenta quello che la funzione fa. Una <code>docstring</code>, se esiste, deve essere la prima cosa definita in una funzione (cioè, nella riga subito dopo la dichiarazione di funzione). Non avete tecnicamente bisogno di dotare la vostra funzione di una <code>docstring</code>, ma dovreste sempre farlo. So che lo avete sentito in ogni corso di programmazione che avete seguito, ma Python vi dà un incentivo aggiuntivo: la <code>docstring</code> è disponibile a tempo di esecuzione sotto forma di proprietà della funzione.
<blockquote class=note>
<p><span>&#x261E;</span>Molti <abbr>IDE</abbr> per Python usano le <code>docstring</code> per fornire documentazione sensibile al contesto, in modo che quando scrivete il nome di una funzione la sua <code>docstring</code> appaia sotto forma di suggerimento. Questa caratteristica può essere incredibilmente utile, ma lo è solamente tanto quanto le <code>docstring</code> che scrivete.
</blockquote>
<h2 id=everythingisanobject>Ogni cosa è un oggetto</h2>
<p>Nel caso vi fosse sfuggito, ho appena detto che le funzioni Python hanno delle proprietà, e che quelle proprietà sono disponibili a tempo di esecuzione. Una funzione, come ogni altra cosa in Python, è un oggetto.
<p>Lanciate la shell interattiva di Python e seguitemi attraverso questa serie di istruzioni:
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>import humansize</kbd>                               <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>print(humansize.approximate_size(4096, True))</kbd>  <span>&#x2461;</span></a>
<samp>4.0 KiB</samp>
<a><samp class=p>>>> </samp><kbd>print(humansize.approximate_size.__doc__)</kbd>      <span>&#x2462;</span></a>
<samp>Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

</samp></pre>
<ol>
<li>La prima riga importa il programma <code>humansize</code> come un modulo &ndash; un pezzo di codice che potete usare interattivamente, o da un programma Python più grande. (Vedrete esempi di programmi Python distribuiti su più moduli in <span class=fixme>[FIXME xref]</span>.) Una volta importato un modulo, potete fare riferimento a ognuna delle sue funzioni, classi, o proprietà pubbliche. I moduli possono sfruttare questa loro caratteristica per accedere alle funzionalità di altri moduli, e voi potete farlo anche nella shell interattiva di Python. Questo è un concetto importante, e lo vedrete ribadito più volte nel seguito di questo libro.
<li>Quando volete usare funzioni definite in moduli importati, dovete includere il nome del modulo. Quindi non potete semplicemente dire <code>approximate_size</code>; deve essere <code>humansize.approximate_size</code>. Se avete usato le classi in Java, la sintassi dovrebbe risultarvi vagamente familiare.
<li>Invece di invocare la funzione, avete richiesto una delle sue proprietà, <code>__doc__</code>.
</ol>
<blockquote class="note compare perl5">
<p><span>&#x261E;</span><code>import</code> in Python è come <code>require</code> in Perl. Una volta che avete importato un modulo Python tramite <code>import</code>, potete accedere alle sue funzioni con la sintassi <code><var>modulo</var>.<var>funzione</var></code>; una volta che avete richiesto un modulo Perl tramite <code>require</code>, potete accedere alle sue funzioni con la sintassi <code><var>modulo</var>::<var>funzione</var></code>.
</blockquote>
<h3 id=importsearchpath>Il percorso di ricerca di <code>import</code></h3>
<p>Prima di proseguire, voglio menzionare brevemente il percorso di ricerca delle librerie. Python guarda in diversi posti quando provate a importare un modulo. Nello specifico, guarda in tutte le directory definite in <code>sys.path</code>. Questa proprietà è semplicemente una lista, e potete facilmente vederla o modificarla con i metodi standard per le liste. (Imparerete di più sulle liste nel capitolo sui <a href=tipi-di-dato-nativi.html>Tipi di dato nativi</a>.)
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>import sys</kbd>                           <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>sys.path</kbd>                             <span>&#x2461;</span></a>
<samp>['', 
 '/usr/lib/python30.zip', 
 '/usr/lib/python3.0',
 '/usr/lib/python3.0/plat-linux2@EXTRAMACHDEPPATH@', 
 '/usr/lib/python3.0/lib-dynload', 
 '/usr/lib/python3.0/dist-packages', 
 '/usr/local/lib/python3.0/dist-packages']</samp>
<a><samp class=p>>>> </samp><kbd>sys</kbd>                                  <span>&#x2462;</span></a>
<samp>&lt;module 'sys' (built-in)></samp>
<a><samp class=p>>>> </samp><kbd>sys.path.insert(0, '/home/mark/py')</kbd>  <span>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd>sys.path</kbd>                             <span>&#x2464;</span></a>
<samp>['/home/mark/py', 
 '', 
 '/usr/lib/python30.zip', 
 '/usr/lib/python3.0', 
 '/usr/lib/python3.0/plat-linux2@EXTRAMACHDEPPATH@', 
 '/usr/lib/python3.0/lib-dynload', 
 '/usr/lib/python3.0/dist-packages', 
 '/usr/local/lib/python3.0/dist-packages']</samp></pre>
<ol>
<li>Importare il modulo <code>sys</code> rende disponibili tutte le sue funzioni e proprietà.
<li><code>sys.path</code> è una lista di nomi di directory che costituiscono il percorso di ricerca corrente. (Il vostro apparirà diverso, a seconda del vostro sistema operativo, della versione di Python che state eseguendo e di dove è stata originariamente installata.) Python cercherà attraverso queste directory (in questo ordine) un file con estensione <code>.py</code> il cui nome corrisponda a quello che state tentando di importare.
<li>In realtà, ho mentito; la verità è più complicata di così, perché non tutti i moduli sono memorizzati come file <code>.py</code>. Alcuni, come il modulo <code>sys</code>, sono moduli &#8220;built-in&#8221;, integrati direttamente all'interno dell'interprete Python. I moduli built-in si comportano esattamente come gli altri moduli, ma il loro codice sorgente Python non è disponibile, perché non sono scritti in Python! (Il modulo <code>sys</code> è scritto in <abbr>C</abbr>.)
<li>Potete aggiungere a tempo di esecuzione una nuova directory al percorso di ricerca di Python aggiungendo il nome della directory a <code>sys.path</code>; successivamente, Python guarderà anche in quella directory ogni volta che provate a importare un modulo. L'effetto dura fino a quando l'interprete Python è in esecuzione.
<li>Usando <code>sys.path.insert(0, <var>new_path</var>)</code>, avete inserito una nuova directory come primo elemento della lista <code>sys.path</code>, quindi all'inizio del percorso di ricerca di Python. Questo è quasi sempre quello che volete. In caso di un conflitto di nomi (per esempio, nel caso l'interprete Python includa la versione 2 di una particolare libreria ma voi vogliate usarne la versione 3), questo vi assicura che saranno i vostri moduli a essere trovati e utilizzati invece dei moduli distribuiti insieme all'interprete Python.
</ol>
<h3 id=whatsanobject>Che cos'è un oggetto?</h3>
<p>Ogni cosa in Python è un oggetto, e ogni cosa può possedere proprietà e metodi. Tutte le funzioni hanno una proprietà built-in <code>__doc__</code>, che restituisce la <var>docstring</var> definita nel codice sorgente della funzione. Il modulo <code>sys</code> è un oggetto che ha (tra le altre cose) una proprietà chiamata <var>path</var>. E così via.
<p>Tuttavia, questo non risponde alla domanda fondamentale: che cos'è un oggetto? Linguaggi di programmazione differenti definiscono &#8220;oggetto&#8221; in modi differenti. In alcuni, significa che <em>tutti</em> gli oggetti <em>devono</em> avere proprietà e metodi; in altri, significa che tutti gli oggetti sono estendibili. In Python, la definizione è più lasca. Alcuni oggetti non hanno proprietà né metodi, <em>ma potrebbero averli</em>. Non tutti gli oggetti sono estendibili. Ma ogni cosa è un oggetto nel senso che può essere assegnata a una variabile o passata come argomento a una funzione.
<p>Potreste aver udito il termine &#8220;oggetto di prima classe&#8221; in altri contesti legati alla programmazione. In Python, le funzioni sono <i>oggetti di prima classe</i>. Potete passare una funzione come argomento a un'altra funzione. I moduli sono <i>oggetti di prima classe</i>. Potete passare un intero modulo come argomento a una funzione. Le classi sono oggetti di prima classe, e anche le singole istanze di una classe sono oggetti di prima classe.
<p>Questo concetto è importante, quindi lo ripeterò nel caso vi fosse sfuggito le prime volte: <em>ogni cosa in Python è un oggetto</em>. Le strighe sono oggetti. Le liste sono oggetti. Le funzioni sono oggetti. Le classi sono oggetti. Le istanze di una classe sono oggetti. Persino i moduli sono oggetti.
<h2 id=indentingcode>Indentare il codice</h2>
<p>Le funzioni Python non cominciano esplicitamente con <code>begin</code> né terminano con <code>end</code>, e non ci sono parentesi graffe a indicare dove il codice della funzione inizia e finisce. I due punti (<code>:</code>) e l'indentazione del codice stesso sono gli unici delimitatori.
<pre><code>
<a>def approximate_size(size, a_kilobyte_is_1024_bytes=True):  <span>&#x2460;</span></a>
<a>    if size &lt; 0:                                            <span>&#x2461;</span></a>
<a>        raise ValueError('number must be non-negative')     <span>&#x2462;</span></a>
<a>                                                            <span>&#x2463;</span></a>
    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
<a>    for suffix in SUFFIXES[multiple]:                       <span>&#x2464;</span></a>
        size /= multiple
        if size &lt; multiple:
            return "{0:.1f} {1}".format(size, suffix)

    raise ValueError('number too large')</code></pre>
<ol>
<li>I blocchi di codice sono definiti dalla loro indentazione. Per &#8220;blocco di codice&#8221; intendo funzioni, istruzioni <code>if</code>, cicli <code>for</code>, cicli <code>while</code>, e così via. La presenza di una indentazione comincia un blocco e la sua assenza lo termina. Non ci sono parentesi graffe, parentesi quadre, o parole chiave. Questo vuol dire che gli spazi bianchi hanno significato, e devono essere consistenti. In questo esempio, il codice della funzione è indentato di quattro spazi. Non è necessario che siano quattro spazi, c'è solo bisogno che l'indentazione sia consistente. La prima riga che non è indentata indica la fine della funzione.
<li>In Python, una istruzione <code>if</code> è seguita da un blocco di codice. Se l'espressione di <code>if</code> viene valutata come vera, il blocco indentato viene eseguito, altrimenti si ricade nel blocco di <code>else</code> (se esiste). (Notate la mancanza di parentesi attorno alla espressione.)
<li>Questa riga è dentro il blocco di codice dell'<code>if</code>. L'istruzione di <code>raise</code> solleverà una eccezione (di tipo <code>ValueError</code>), ma solo se <code>size &lt; 0</code>.
<li>Questa <em>non</em> è la fine della funzione. Le righe completamente vuote non vengono considerate. Possono rendere il codice più leggibile, ma non vengono usate per delimitare i blocchi. La funzione continua nella riga seguente.
<li>Anche il ciclo <code>for</code> segnala l'inizio di un blocco di codice. I blocchi di codice possono contenere più righe, fino a quando esse sono indentate della stessa quantità. Questo ciclo <code>for</code> contiene tre righe di codice. Non c'è nessun'altra sintassi speciale per blocchi di codice su più righe. Indentate e andate avanti con la vostra vita.
</ol>
<p>Dopo alcune proteste iniziali e diverse analogie maliziose al Fortran, vi riappacificherete con questa caratteristica di Python e comincerete a vederne i lati positivi. Uno dei maggiori benefici è che tutti i programmi Python appaiono simili, in quanto l'indentazione è un requisito del linguaggio e non una questione di stile. Questo rende più facile leggere e comprendere il codice Python scritto da altre persone.
<blockquote class="note compare java">
<p><span>&#x261E;</span>Python usa i ritorni a capo per separare le istruzioni e i due punti e l'indentazione per separare i blocchi di codice. <abbr>C++</abbr> e Java usano i punti e virgola per separare le istruzioni e le parentesi graffe per separare i blocchi di codice.
</blockquote>
<h2 id=runningscripts>Eseguire gli script</h2>
<aside>Ogni cosa in Python è un oggetto.</aside>
<p>I moduli Python sono oggetti e hanno diverse proprietà utili. Potete sfruttare questa caratteristica per collaudare facilmente i vostri moduli mentre li scrivete, includendo uno speciale blocco di codice che viene eseguito quando lanciate il file Python dalla linea di comando. Considerate le ultime righe di <code>humansize.py</code>:
<pre><code>
if __name__ == "__main__":
    print(approximate_size(1000000000000, False))
    print(approximate_size(1000000000000))</code></pre>
<blockquote class="note compare clang">
<p><span>&#x261E;</span>Come il <abbr>C</abbr>, Python usa <code>==</code> per il confronto e <code>=</code> per l'assegnamento. A differenza del <abbr>C</abbr>, Python non supporta l'assegnamento in linea, quindi non c'è alcuna possibilità di assegnare accidentalmente il valore che pensavate di stare confrontando.
</blockquote>
<p>Che cosa rende speciale questa istruzione <code>if</code>? Ebbene, i moduli sono oggetti, e tutti i moduli hanno la proprietà built-in <code>__name__</code>. Il valore della proprietà <code>__name__</code> di un modulo dipende da come state usando il modulo. Se importate un modulo, allora <code>__name__</code> sarà il nome del file del modulo, senza il percorso e l'estensione. 
<pre class=screen>
<samp class=p>>>> </samp><kbd>import humansize</kbd>
<samp class=p>>>> </samp><kbd>humansize.__name__</kbd>
<samp>'humansize'</samp></pre>
<p>Ma potete anche eseguire direttamente il modulo come un programma a sé, nel qual caso <code>__name__</code> sarà lo speciale valore di default <code>__main__</code>. Nel nostro esempio, Python valuterà l'istruzione <code>if</code>, troverà una espressione vera, ed eseguirà il blocco di codice corrispondente. In questo caso, per stampare due valori.
<pre class=screen>
<samp class=p>c:\home\diveintopython3> </samp><kbd>c:\python30\python.exe humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>
<p>E questo è il vostro primo programma Python!
<h2 id=furtherreading>Letture di approfondimento</h2>
<ul>
<li><a href=http://www.python.org/dev/peps/pep-0257/>PEP 257: Docstring Conventions</a> spiega cosa distingue una buona <code>docstring</code> da una <code>docstring</code> eccellente.
<li><a href=http://docs.python.org/3.0/tutorial/controlflow.html#documentation-strings>Python Tutorial: Documentation Strings</a> si occupa a sua volta dell'argomento.
<li><a href=http://www.python.org/dev/peps/pep-0008/>PEP 8: Style Guide for Python Code</a> descrive il buon stile di indentazione.
<li><a href=http://docs.python.org/3.0/reference/><cite>Python Reference Manual</cite></a> spiega cosa significa dire che <a href=http://docs.python.org/3.0/reference/datamodel.html#objects-values-and-types>ogni cosa in Python è un oggetto</a>, perché alcune persone sono <a href=http://www.douglasadams.com/dna/pedants.html>pedanti</a> e adorano discutere questo tipo di cose in lungo e in largo.
</ul>
<p class=nav><a rel=prev class=todo><span>&#x261C;</span></a> <a rel=next href=tipi-di-dato-nativi.html title="avanti a &#8220;Tipi di dato nativi&#8221;"><span>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;9 <a href=informazioni-sul-libro.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
