<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Tipi di dato nativi - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
body{counter-reset:h1 2}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=root value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#tipi-di-dato-nativi>Dive Into Python 3</a> <span>&#8227;</span>
<p id=level>Livello di difficoltà: <span title=principiante>&#x2666;&#x2666;&#x2662;&#x2662;&#x2662;</span>
<h1>Tipi di dato nativi</h1>
<blockquote class=q>
<p><span>&#x275D;</span> Wonder is the foundation of all philosophy, inquiry its progress, ignorance its end. <span>&#x275E;</span><br>&mdash; Michel de Montaigne
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>Mettete da parte <a href=il-vostro-primo-programma-python.html>il vostro primo programma Python</a> per un minuto, e parliamo di tipi di dato. In Python, <a href=il-vostro-primo-programma-python.html#datatypes>ogni variabile ha un tipo di dato</a>, ma non avete bisogno di dichiararlo esplicitamente. In base all'assegnamento originale di ogni variabile, Python capisce di quale tipo è e ne tiene traccia internamente.
<p>Python ha molti tipi di dato nativi. Questi sono quelli più importanti:
<ol>
<li><b>Booleani</b>: sono solamente <code>True</code> oppure <code>False</code>.
<li><b>Numeri</b>: possono essere interi (<code>1</code> e <code>2</code>), reali (<code>1.1</code> e <code>1.2</code>), frazioni (<code>1/2</code> e <code>2/3</code>), o persino numeri complessi (<code><var>i</var></code>, la radice quadrata di <code>-1</code>).
<li><b>Stringhe</b>: sono sequenze di caratteri Unicode, <i>e.g.</i> un documento <abbr>HTML</abbr>.
<li><b>Byte</b> e <b>byte array</b>: <i>e.g.</i> un file <abbr>JPEG</abbr> contenente una immagine.
<li><b>Liste</b>: sono sequenze ordinate di valori.
<li><b>Set</b>: sono insiemi di valori senza un ordine preciso.
<li><b>Dizionari</b>: sono insiemi di coppie chiave-valore senza un ordine preciso.
</ol>
<p>Naturalmente, ci sono molti più tipi di questi sette. <a href=il-vostro-primo-programma-python.html#everythingisanobject>Ogni cosa è un oggetto</a> in Python, quindi ci sono anche tipi come <i>modulo</i>, <i>funzione</i>, <i>classe</i>, <i>metodo</i>, <i>file</i>, e persino <i>codice compilato</i>. Ne avete già visti alcuni: <a href=il-vostro-primo-programma-python.html#runningscripts>i moduli hanno un nome</a>, <a href=il-vostro-primo-programma-python.html#docstrings>le funzioni posseggono una <code>docstring</code></a>, <i class=baa>&amp;</i>c. Imparerete cosa sono le classi in <span class=fixme>[FIXME xref]</span> e cosa sono i file in <span class=fixme>[FIXME xref]</span>.
<p>Stringhe e byte sono abbastanza importanti &mdash; e abbastanza complicati &mdash; da essere trattati in un capitolo a parte. Diamo un'occhiata agli altri per primi.
<h2 id=booleans>Booleani</h2>
<aside>Potete usare virtualmente qualsiasi espressione in un contesto logico.</aside>
<p>I dati di tipo booleano sono veri o falsi. Python ha due costanti, <code>True</code> e <code>False</code>, che possono essere usate per assegnare direttamente valori di tipo booleano. Anche le espressioni possono essere valutate come valori booleani. In certi posti (come le istruzioni <code>if</code>), Python si aspetta una espressione da valutare come un valore booleano. Questi posti sono chiamati <i>contesti logici</i>. Potete virtualmente usare qualsiasi espressione in un contesto logico, e Python proverà a determinarne il valore di verità. Tipi di dato differenti hanno regole differenti per decidere se un loro valore è vero o falso in un contesto logico. (Questa frase avrà più senso una volta che avrete visto alcuni esempi concreti più in là in questo capitolo.)
<p>Per esempio, considerate questo estratto da <a href=il-vostro-primo-programma-python.html#divingin><code>humansize.py</code></a>:
<pre><code>if size &lt; 0:
    raise ValueError('number must be non-negative')</code></pre>
<p><var>size</var> è un intero, <code>0</code> è un intero, e <code>&lt;</code> è un operatore numerico. Il risultato dell'espressione <code>size &lt; 0</code> è sempre un booleano. Potete verificarlo voi stessi nella shell interattiva di Python:
<pre class=screen>
<samp class=p>>>> </samp><kbd>size = 1</kbd>
<samp class=p>>>> </samp><kbd>size &lt; 0</kbd>
<samp>False</samp>
<samp class=p>>>> </samp><kbd>size = 0</kbd>
<samp class=p>>>> </samp><kbd>size &lt; 0</kbd>
<samp>False</samp>
<samp class=p>>>> </samp><kbd>size = -1</kbd>
<samp class=p>>>> </samp><kbd>size &lt; 0</kbd>
<samp>True</samp></pre>
<h2 id=numbers>Numeri</h2>
<p>I numeri sono impressionanti. Ce ne sono così tanti tra cui scegliere. Python supporta sia gli interi che i numeri in virgola mobile. Non c'è alcuna dichiarazione di tipo per distinguerli; Python è in grado di farlo grazie alla presenza o meno del punto decimale.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>type(1)</kbd>                 <span>&#x2460;</span></a>
<samp>&lt;class 'int'></samp>
<a><samp class=p>>>> </samp><kbd>1 + 1</kbd>                   <span>&#x2461;</span></a>
<samp>2</samp>
<a><samp class=p>>>> </samp><kbd>1 + 1.0</kbd>                 <span>&#x2462;</span></a>
<samp>2.0</samp>
<samp class=p>>>> </samp><kbd>type(2.0)</kbd>
<samp>&lt;class 'float'></samp></pre>
<ol>
<li>Potete usare la funzione <code>type()</code> per controllare il tipo di qualsiasi valore o variabile. Come vi sareste aspettati, <code>1</code> è un <code>int</code>.
<li>Aggiungere un <code>int</code> a un <code>int</code> dà come risultato un <code>int</code>.
<li>Aggiungere un <code>int</code> a un <code>float</code> dà come risultato un <code>float</code>. Python converte implicitamente l'<code>int</code> in un <code>float</code> per eseguire l'addizione, poi restituisce un <code>float</code> come risultato.
</ol>
<h3 id=number-coercion>Convertire interi a reali e viceversa</h3>
<p>Come avete appena visto, alcuni operatori (come l'addizione) convertono implicitamente gli interi in numeri in virgola mobile su necessità. Potete anche convertirli esplicitamente voi stessi.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>float(2)</kbd>                <span>&#x2460;</span></a>
<samp>2.0</samp>
<a><samp class=p>>>> </samp><kbd>int(2.0)</kbd>                <span>&#x2461;</span></a>
<samp>2</samp>
<a><samp class=p>>>> </samp><kbd>int(2.5)</kbd>                <span>&#x2462;</span></a>
<samp>2</samp>
<a><samp class=p>>>> </samp><kbd>int(-2.5)</kbd>               <span>&#x2463;</span></a>
<samp>-2</samp>
<a><samp class=p>>>> </samp><kbd>1.12345678901234567890</kbd>  <span>&#x2464;</span></a>
<samp>1.1234567890123457</samp>
<a><samp class=p>>>> </samp><kbd>type(1000000000000000)</kbd>  <span>&#x2465;</span></a>
<samp>&lt;class 'int'></samp></pre>
<ol>
<li>Potete convertire esplicitamente un <code>int</code> in un <code>float</code> chiamando la funzione <code>float()</code>.
<li>Naturalmente, potete anche convertire esplicitamente un <code>float</code> in un <code>int</code> chiamando <code>int()</code>.
<li>La funzione <code>int()</code> esegue un troncamento, non un arrotondamento.
<li>La funzione <code>int()</code> tronca i numeri negativi verso lo <code>0</code>. &Egrave; una vera funzione di troncamento, non una funzione di appiattimento.
<li>I numeri in virgola mobile sono accurati fino a 15 decimali.
<li>Gli interi possono essere arbitrariamente grandi.
</ol>
<blockquote class="note compare python2">
<p><span>&#x261E;</span>Python 2 aveva tipi separati per <code>int</code> e <code>long</code>. Il tipo di dato <code>int</code> era limitato da <code>sys.maxint</code>, che variava a seconda della piattaforma ma normalmente valeva <code>2<sup>32</sup>-1</code>. Python 3 ha un solo tipo per i numeri interi, che si comporta per la maggior parte come il vecchio tipo <code>long</code> di Python 2. Si veda la <a href=http://www.python.org/dev/peps/pep-0237><abbr>PEP</abbr> 237</a> per i dettagli.
</blockquote>
<h3 id=common-numerical-operations>Operazioni numeriche comuni</h3>
<p>Potete fare ogni tipo di operazioni con i numeri.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>11 / 2</kbd>      <span>&#x2460;</span></a>
<samp>5.5</samp>
<a><samp class=p>>>> </samp><kbd>11 // 2</kbd>     <span>&#x2461;</span></a>
<samp>5</samp>
<a><samp class=p>>>> </samp><kbd>&minus;11 // 2</kbd>    <span>&#x2462;</span></a>
<samp>&minus;6</samp>
<a><samp class=p>>>> </samp><kbd>11.0 // 2</kbd>   <span>&#x2463;</span></a>
<samp>5.0</samp>
<a><samp class=p>>>> </samp><kbd>11 ** 2</kbd>     <span>&#x2464;</span></a>
<samp>121</samp>
<a><samp class=p>>>> </samp><kbd>11 % 2</kbd>      <span>&#x2465;</span></a>
<samp>1</samp>
</pre>
<ol>
<li>L'operatore <code>/</code> esegue la divisione in virgola mobile. Restituisce un <code>float</code> anche se sia il numeratore che il denominatore sono numeri di tipo <code>int</code>.
<li>L'operatore <code>//</code> esegue un tipo strambo di divisione tra interi. Quando il risultato è positivo, potete immaginarla come un troncamento (non un arrotondamento) a <code>0</code> decimali, ma fate attenzione.
<li>Quando eseguite la divisione intera tra numeri negativi, l'operatore <code>//</code> arrotonda &#8220;per eccesso&#8221; verso l'intero più vicino. Matematicamente parlando, l'arrotondamento è &#8220;per difetto&#8221;, dato che <code>&minus;6</code> è inferiore a <code>&minus;5</code>, ma potrebbe indurvi a un errore se vi aspettaste un troncamento a <code>&minus;5</code>.
<li>L'operatore <code>//</code> non restituisce sempre un intero. Se il numeratore o il denominatore sono di tipo <code>float</code>, effettuerà un arrontondamento all'intero più vicino, ma l'effettivo valore di ritorno sarà un <code>float</code>.
<li>L'operatore <code>**</code> significa &#8220;elevato alla potenza di.&#8221;  <code>11<sup>2</sup></code> vale <code>121</code>.
<li>L'operatore <code>%</code> dà il resto dopo aver effettuato una divisione di tipo intero. <code>11</code> diviso per <code>2</code> vale <code>5</code> con il resto di <code>1</code>, quindi il risultato in questo caso è <code>1</code>.
</ol>
<blockquote class="note compare python2">
<p><span>&#x261E;</span>In Python 2, l'operatore <code>/</code> normalmente effettuava una divisione di tipo intero, ma avreste potuto farlo comportare come la divisione in virgola mobile includendo una speciale direttiva nel vostro codice. In Python 3, l'operatore <code>/</code> effettua sempre una divisione in virgola mobile. Si veda la <a href=http://www.python.org/dev/peps/pep-0238/><abbr>PEP</abbr> 238</a> per i dettagli.
</blockquote>
<h3 id=fractions>Frazioni</h3>
<p>Python non si limita agli interi e ai numeri in virgola mobile. Può anche fare tutta quella matematica elaborata che avete imparato al liceo e poi prontamente dimenticato.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>import fractions</kbd>              <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>x = fractions.Fraction(1, 3)</kbd>  <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>x</kbd>
<samp>Fraction(1, 3)</samp>
<a><samp class=p>>>> </samp><kbd>x * 2</kbd>                         <span>&#x2462;</span></a>
<samp>Fraction(2, 3)</samp>
<a><samp class=p>>>> </samp><kbd>fractions.Fraction(6, 4)</kbd>      <span>&#x2463;</span></a>
<samp>Fraction(3, 2)</samp></pre>
<ol>
<li>Per cominciare a usare le frazioni, importate il modulo <code>fractions</code>.
<li>Per definire una frazione, create un oggetto <code>Fraction</code> e passategli il numeratore e il denominatore.
<li>Potete eseguire tutte le solite operazioni matematiche con le frazioni. Le operazioni restituiscono un nuovo oggetto <code>Fraction</code>. <code>2 * (1/3) = (2/3)</code>
<li>L'oggetto <code>Fraction</code> semplificherà le frazioni automaticamente. <code>(6/4) = (3/2)</code>
</ol>
<h3 id=trig>Trigonometria</h3>
<p>Potete anche operare con la trigonometria di base in Python.
<pre class=screen>
<samp class=p>>>> </samp><kbd>import math</kbd>
<a><samp class=p>>>> </samp><kbd>math.pi</kbd>                <span>&#x2460;</span></a>
<samp>3.1415926535897931</samp>
<a><samp class=p>>>> </samp><kbd>math.sin(math.pi / 2)</kbd>  <span>&#x2461;</span></a>
<samp>1.0</samp>
<a><samp class=p>>>> </samp><kbd>math.tan(math.pi / 4)</kbd>  <span>&#x2462;</span></a>
<samp>0.99999999999999989</samp></pre>
<ol>
<li>Il modulo <code>math</code> include una costante per &pi;, il rapporto tra la circonferenza di un cerchio e il suo diametro.
<li>Il modulo <code>math</code> contiene tutte le funzioni trigonometriche di base, comprese <code>sin()</code>, <code>cos()</code>, <code>tan()</code>, e varianti come <code>asin()</code>.
<li>Notate, comunque, che la precisione numerica di Python non è infinita. <code>tan(&pi; / 4)</code> dovrebbe restituire <code>1.0</code>, non <code>0.99999999999999989</code>.
</ol>
<h3 id=numbers-in-a-boolean-context>Numeri in un contesto logico</h3>
<aside>I valori uguali a zero sono falsi, e i valori diversi da zero sono veri.</aside>
<p>Potete usare i numeri <a href="#booleans">in un contesto logico</a>, come una istruzione <code>if</code>. I valori uguali a zero sono falsi, e i valori diversi da zero sono veri.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>def is_it_true(anything):</kbd>             <span>&#x2460;</span></a>
<samp class=p>... </samp><kbd>  if anything:</kbd>
<samp class=p>... </samp><kbd>    print("sì, è vero")</kbd>
<samp class=p>... </samp><kbd>  else:</kbd>
<samp class=p>... </samp><kbd>    print("no, è falso")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd>is_it_true(1)</kbd>                         <span>&#x2461;</span></a>
<samp>sì, è vero</samp>
<samp class=p>>>> </samp><kbd>is_it_true(-1)</kbd>
<samp>sì, è vero</samp>
<samp class=p>>>> </samp><kbd>is_it_true(0)</kbd>
<samp>no, è falso</samp>
<a><samp class=p>>>> </samp><kbd>is_it_true(0.1)</kbd>                       <span>&#x2462;</span></a>
<samp>sì, è vero</samp>
<samp class=p>>>> </samp><kbd>is_it_true(0.0)</kbd>
<samp>no, è falso</samp>
<samp class=p>>>> </samp><kbd>import fractions</kbd>
<a><samp class=p>>>> </samp><kbd>is_it_true(fractions.Fraction(1, 2))</kbd>  <span>&#x2463;</span></a>
<samp>sì, è vero</samp>
<samp class=p>>>> </samp><kbd>is_it_true(fractions.Fraction(0, 1))</kbd>
<samp>no, è falso</samp></pre>
<ol>
<li>Sapevate di poter definire le vostre funzioni nella shell interattiva di Python? Vi basta premere <kbd>ENTER</kbd> alla fine di ogni riga, ed <kbd>ENTER</kbd> su una riga vuota per concludere la definizione.
<li>In un contesto logico, gli interi diversi da zero sono veri; <code>0</code> è falso.
<li>I numeri in virgola mobile diversi da zero sono veri; <code>0.0</code> è falso. Fate attenzione! Se c'è anche il più piccolo errore di arrotondamento (non impossibile, come avete visto nella precedente sezione) allora Python opererà su <code>0.0000000000001</code> invece di <code>0</code> e restituirà <code>True</code>.
<li>Anche le frazioni possono essere usate in un contesto logico. <code>Fraction(0, n)</code> è falso per tutti i valori di <var>n</var>. Tutte le altre frazioni sono vere.
</ol>
<h2 id=lists>Liste</h2>
<p>Le liste sono il mulo da soma dei tipi di dato Python. Quando dico &#8220;lista,&#8221; potreste pensare &#8220;array la cui dimensione devo dichiarare in anticipo, e che può solo contenere elementi di uno stesso tipo, <i class=baa>&amp;</i>c.&#8221; Non pensatelo. Le liste sono molto più fighe di così.
<blockquote class="note compare perl5">
<p><span>&#x261E;</span>Una lista in Python è come un array in Perl 5. In Perl 5, variabili che memorizzano un array cominciano sempre con il carattere <code>@</code>; in Python, le variabili possono essere chiamate in qualsiasi modo, e Python tiene traccia del tipo di dato internamente.
</blockquote>
<blockquote class="note compare java">
<p><span>&#x261E;</span>Una lista in Python è molto di più di un array in Java (anche se può essere usata come tale se questo è tutto quello che volete dalla vita). Una analogia migliore sarebbe quella con la classe <code>ArrayList</code>, che può contenere oggetti di tipo arbitrario e può espandersi dinamicamente man mano che nuovi elementi vengono aggiunti.
</blockquote>
<h3 id=creatinglists>Creare una lista</h3>
<p>Creare una lista è facile: usate le parentesi quadre per racchiudere una lista di valori separati da virgole.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>a_list = ['a', 'b', 'mpilgrim', 'z', 'example']</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
['a', 'b', 'mpilgrim', 'z', 'example']
<a><samp class=p>>>> </samp><kbd>a_list[0]</kbd>                                        <span>&#x2461;</span></a>
<samp>'a'</samp>
<a><samp class=p>>>> </samp><kbd>a_list[4]</kbd>                                        <span>&#x2462;</span></a>
<samp>'example'</samp>
<a><samp class=p>>>> </samp><kbd>a_list[-1]</kbd>                                       <span>&#x2463;</span></a>
<samp>'example'</samp>
<a><samp class=p>>>> </samp><kbd>a_list[-3]</kbd>                                       <span>&#x2464;</span></a>
<samp>'mpilgrim'</samp></pre>
<ol>
<li>Per prima cosa, definite una lista di cinque elementi. Notate che essi mantengono il loro ordine originale. Questo non è un caso. Una lista è un insieme ordinato di elementi.
<li>Una lista può essere usata come un array il cui indice parte da zero. Il primo elemento di una lista non vuota è sempre <code>a_list[0]</code>.
<li>L'ultimo elemento di questa lista di cinque elementi è <code>a_list[4]</code>, perché l'indice delle liste parte sempre da zero.
<li>Un indice negativo accede gli elementi dalla fine della lista contando all'indietro. L'ultimo elemento di una lista non vuota è sempre <code>a_list[-1]</code>.
<li>Se l'indice negativo vi confonde, pensatela in questo modo: <code>a_list[-<var>n</var>] == a_list[len(a_list) - <var>n</var>]</code>. Quindi, in questa lista, <code>a_list[-3] == a_list[5 - 3] == a_list[2]</code>.
</ol>
<h3 id=slicinglists>Affettare una lista</h3>
<aside>a_list[0] è il primo elemento di a_list.</aside>
<p>Una volta che avete definito una lista, potete ottenerne una parte qualsiasi sotto forma di una nuova lista. Questa operazione si chiama <i>affettare</i> la lista.
<pre class=screen>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp>['a', 'b', 'mpilgrim', 'z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd>a_list[1:3]</kbd>            <span>&#x2460;</span></a>
<samp>['b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd>a_list[1:-1]</kbd>           <span>&#x2461;</span></a>
<samp>['b', 'mpilgrim', 'z']</samp>
<a><samp class=p>>>> </samp><kbd>a_list[0:3]</kbd>            <span>&#x2462;</span></a>
<samp>['a', 'b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd>a_list[:3]</kbd>             <span>&#x2463;</span></a>
<samp>['a', 'b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd>a_list[3:]</kbd>             <span>&#x2464;</span></a>
<samp>['z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd>a_list[:]</kbd>              <span>&#x2465;</span></a>
['a', 'b', 'mpilgrim', 'z', 'example']</pre>
<ol>
<li>Potete ottenere una parte di una lista, chiamata &#8220;fetta&#8221;, specificando due indici. Il valore di ritorno è una nuova lista che contiene tutti gli elementi della lista, in ordine, a cominciare dal primo indice della fetta (in questo caso <code>a_list[1]</code>), fino al secondo indice della fetta escluso (in questo caso <code>a_list[3]</code>).
<li>Affettare una lista funziona anche se uno o entrambi gli indici della fetta sono negativi. Se vi è d'aiuto, potete pensarla in questo modo: leggendo la lista da sinistra a destra, il primo indice della fetta indica il primo elemento che volete, e il secondo indice della fetta indica il primo elemento che non volete. Il valore di ritorno è tutto quello che sta in mezzo.
<li>L'indice delle liste comincia da zero, quindi <code>a_list[0:3]</code> restituisce i primi tre elementi della lista, cominciando da <code>a_list[0]</code>, fino a <code>a_list[3]</code> escluso.
<li>Se l'indice sinistro della lista è <code>0</code>, potete ometterlo, e <code>0</code> diventa implicito. Quindi <code>a_list[:3]</code> è la stessa cosa di <code>a_list[0:3]</code>, perché lo <code>0</code> iniziale è implicito.
<li>Similmente, se l'indice destro della lista è la lunghezza della lista, potete ometterlo. Quindi <code>a_list[3:]</code> è la stessa cosa di <code>a_list[3:5]</code>, perché questa lista ha cinque elementi. C'è una piacevole simmetria qui. In questa lista di cinque elementi, <code>a_list[:3]</code> restituisce i primi 3 elementi, e <code>a_list[3:]</code> restituisce gli ultimi due elementi. In effetti, <code>a_list[:<var>n</var>]</code> restituirà sempre i primi <var>n</var> elementi e <code>a_list[<var>n</var>:]</code> restituirà sempre il resto, a prescindere dalla lunghezza della lista.
<li>Se entrambi gli indici della fetta vengono omessi, tutti gli elementi della lista vengono inclusi. Ma questa non è la stessa lista della variabile <var>a_list</var> originale. &Egrave; una nuova lista a cui capita di avere tutti gli stessi elementi. <code>a_list[:]</code> è una notazione abbreviata per creare la copia completa di una lista.
</ol>
<h3 id=extendinglists>Aggiungere elementi a una lista</h3>
<p>Ci sono quattro modi per aggiungere un elemento a una lista.
<pre class=screen>
<samp class=p>>>> </samp><kbd>a_list = ['a']</kbd>
<a><samp class=p>>>> </samp><kbd>a_list = a_list + [2.0, 3]</kbd>    <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp>['a', 2.0, 3]</samp>
<a><samp class=p>>>> </samp><kbd>a_list.append(True)</kbd>           <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp>['a', 2.0, 3, True]</samp>
<a><samp class=p>>>> </samp><kbd>a_list.extend(['four', 'e'])</kbd>  <span>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp>['a', 2.0, 3, True, 'four', 'e']</samp>
<a><samp class=p>>>> </samp><kbd>a_list.insert(1, 'a')</kbd>         <span>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp>['a', 'a', 2.0, 3, True, 'four', 'e']</samp></pre>
<ol>
<li>L'operatore <code>+</code> concatena liste. Una lista può contenere qualsiasi numero di elementi; non c'è alcun limite sulle dimensioni (a parte la memoria disponibile). Una lista può contenere elementi di ogni tipo di dato; non c'è bisogno che siano tutti dello stesso tipo. Qui abbiamo una lista contenente una stringa, un numero in virgola mobile, e un intero.
<li>Il metodo <code>append()</code> aggiunge un singolo elemento alla fine di una lista. (Ora abbiamo <em>quattro</em> tipi di dato differenti nella lista!)
<li>Le liste sono implementate come classi. &#8220;Creare&#8221; una lista vuol dire in realtà istanziare una classe. Come tale, una lista ha metodi che operano su di essa. Il metodo <code>extend()</code> prende un argomento, una lista, e aggiunge ognuno degli elementi dell'argomento in coda alla lista originale.
<li>Il metodo <code>insert()</code> inserisce un singolo elemento in una lista. Il primo argomento è l'indice del primo elemento nella lista che verrà spostato dalla sua posizione. Gli elementi di una lista non devono essere unici; per esempio, ci sono ora due elementi diversi con il valore <code>'a'</code>, <code>a_list[0]</code> e <code>a_list[1]</code>.
</ol>
<p>Diamo un'occhiata più da vicino alle differenze tra <code>append()</code> ed <code>extend()</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd>a_list = ['a', 'b', 'c']</kbd>
<a><samp class=p>>>> </samp><kbd>a_list.extend(['d', 'e', 'f'])</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp>['a', 'b', 'c', 'd', 'e', 'f']</samp>
<a><samp class=p>>>> </samp><kbd>len(a_list)</kbd>                     <span>&#x2461;</span></a>
<samp>6</samp>
<samp class=p>>>> </samp><kbd>a_list[-1]</kbd>
<samp>'f'</samp>
<a><samp class=p>>>> </samp><kbd>a_list.append(['g', 'h', 'i'])</kbd>  <span>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp>['a', 'b', 'c', 'd', 'e', 'f', ['g', 'h', 'i']]</samp>
<a><samp class=p>>>> </samp><kbd>len(a_list)</kbd>                     <span>&#x2463;</span></a>
<samp>7</samp>
<samp class=p>>>> </samp><kbd>a_list[-1]</kbd>
<samp>['g', 'h', 'i']</samp></pre>
<ol>
<li>Il metodo <code>extend()</code> prende un singolo argomento, che è sempre una lista, e aggiunge ogni elemento di quella lista ad <var>a_list</var>.
<li>Se cominciate con una lista di tre elementi e la estendete con una lista di altri tre elementi, terminerete con una lista di sei elementi.
<li>D'altra parte, il metodo <code>append()</code> prende un singolo argomento, che può avere un tipo di dato qualsiasi. Qui, state chiamando il metodo <code>append()</code> con una lista di tre elementi.
<li>Se cominciate con una lista di sei elementi e vi accodate una lista, terminerete con... una lista di sette elementi. Perché sette? Perché l'ultimo elemento (che avete appena aggiunto) <em>è anch'esso una lista</em>. Le liste possono contenere ogni tipo di dato, comprese altre liste. Questo potrebbe essere quello che volete, oppure no. Ma è quello che avete chiesto, ed è quello che avete ottenuto.
</ol>
<h3 id=searchinglists>Cercare valori in una lista</h3>
<pre class=screen>
<samp class=p>>>> </samp><kbd>a_list = ['a', 'b', 'new', 'mpilgrim', 'new']</kbd>
<a><samp class=p>>>> </samp><kbd>'mpilgrim' in a_list</kbd>      <span>&#x2460;</span></a>
<samp>True</samp>
<a><samp class=p>>>> </samp><kbd>a_list.index('mpilgrim')</kbd>  <span>&#x2461;</span></a>
<samp>3</samp>
<a><samp class=p>>>> </samp><kbd>a_list.index('new')</kbd>       <span>&#x2462;</span></a>
<samp>2</samp>
<a><samp class=p>>>> </samp><kbd>'c' in a_list</kbd>             <span>&#x2463;</span></a>
<samp>False</samp>
<a><samp class=p>>>> </samp><kbd>a_list.index('c')</kbd>         <span>&#x2464;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
ValueError: list.index(x): x not in list</samp></pre>
<ol>
<li>Per verificare se un valore è presente in una lista, usate l'operatore <code>in</code>. Esso restituisce <code>True</code> se il valore è nella lista, oppure <code>False</code> se non lo è. Non vi dirà dove si trova il valore.
<li>Se avete bisogno di sapere esattamente dove si trova un valore nella lista, chiamate il metodo <code>index()</code>. Di default cercherà nell'intera lista, anche se potete specificare, come secondo argomento, l'indice (a partire da <code>0</code>) da cui cominciare e persino, come terzo argomento, l'indice (a partire da <code>0</code>) in cui terminare la ricerca.
<li>Come vi sareste aspettati, questo restituisce <code>False</code>, perché <code>'c'</code> non è un valore contenuto in <var>a_list</var>.
<li>Il metodo <code>index()</code> trova la <em>prima</em> occorrenza di un valore nella lista. In questo caso, <code>'new'</code> appare due volte nella lista, in <code>a_list[2]</code> and <code>a_list[4]</code>, ma il metodo <code>index()</code> restituirà solamente l'indice della prima occorrenza. 
<li>Come <em>non</em> vi sareste aspettati, se il valore non è trovato nella lista, Python solleva una eccezione. Questa è una differenza considerevole rispetto alla maggior parte dei linguaggi, che resituiscono un qualche indice non valido (come <code>-1</code>). Mentre questo può sembrare fastidioso all'inizio, penso che finirete per apprezzarlo. Significa che il vostro programma fallirà alla sorgente del problema invece di fallire stranamente e silenziosamente più tardi. 
</ol>
<h3 id=lists-in-a-boolean-context>Liste in un contesto logico</h3>
<aside>Le liste vuote sono false; tutte le altre liste sono vere.</aside>
<p>Potete usare una lista anche in <a href=#booleans>un contesto logico</a>, come quello di una istruzione <code>if</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd>  if anything:</kbd>
<samp class=p>... </samp><kbd>    print("sì, è vero")</kbd>
<samp class=p>... </samp><kbd>  else:</kbd>
<samp class=p>... </samp><kbd>    print("no, è falso")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd>is_it_true([])</kbd>             <span>&#x2461;</span></a>
<samp>no, è falso</samp>
<a><samp class=p>>>> </samp><kbd>is_it_true(['a'])</kbd>          <span>&#x2462;</span></a>
<samp>sì, è vero</samp>
<a><samp class=p>>>> </samp><kbd>is_it_true([False])</kbd>        <span>&#x2463;</span></a>
<samp>sì, è vero</samp></pre>
<ol>
<li>In un contesto logico, una lista vuota è falsa.
<li>Qualsiasi lista con almeno un elemento è vera.
<li>Qualsiasi lista con almeno un elemento è vera. Il valore degli elementi è irrilevante.
</ol>
<!--
<h2 id=sets>Sets</h2>
<p>FIXME
-->
<h2 id=dictionaries>Dizionari</h2>
<p>Uno dei più importanti tipi di dato Python è il dizionario, che definisce relazioni di tipo uno-a-uno tra chiavi e valori.
<blockquote class="note compare perl5">
<p><span>&#x261E;</span>Un dizionario in Python è come un hash in Perl 5. In Perl 5, variabili che memorizzano hash cominciano sempre con il carattere <code>%</code>. In Python, le variabili possono essere chiamate in qualsiasi modo, e Python tiene traccia del tipo di dato internamente.
</blockquote>
<h3 id=creating-dictionaries>Creare un dizionario</h3>
<p>Creare un dizionario è facile. La sintassi è simile agli <a href=#sets>insiemi</a>, ma invece di valori avete coppie chiave-valore. Una volta che avete un dizionario, potete recuperarne i valori attraverso le loro chiavi.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>a_dict = {"server":"db.diveintopython3.org", "database":"mysql"}</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>a_dict</kbd>
<samp>{'server': 'db.diveintopython3.org', 'database': 'mysql'}</samp>
<a><samp class=p>>>> </samp><kbd>a_dict["server"]</kbd>                                                  <span>&#x2461;</span></a>
'db.diveintopython3.org'
<a><samp class=p>>>> </samp><kbd>a_dict["database"]</kbd>                                                <span>&#x2462;</span></a>
'mysql'
<a><samp class=p>>>> </samp><kbd>a_dict["db.diveintopython3.org"]</kbd>                                  <span>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 'db.diveintopython3.org'</samp></pre>
<ol>
<li>Per prima cosa, create un nuovo dizionario con due elementi e assegnatelo alla variabile <var>a_dict</var>. Ogni elemento è una coppia chiave-valore, e l'intero insieme di elementi è racchiuso tra parentesi graffe.
<li><code>'server'</code> è una chiave, e il suo valore associato, riferito da <code>a_dict["server"]</code>, è <code>'db.diveintopython3.org'</code>.
<li><code>'database'</code> è una chiave, e il suo valore associato, riferito da <code>a_dict["database"]</code>, è <code>'mysql'</code>.
<li>Potete ottenere i valori attraverso le chiavi, ma non potete ottenere le chiavi attraverso i valori. Quindi, <code>a_dict["server"]</code> è <code>'db.diveintopython3.org'</code>, ma <code>a_dict["db.diveintopython3.org"]</code> solleva una eccezione, perché <code>'db.diveintopython3.org'</code> non è una chiave.
</ol>
<h3 id=modifying-dictionaries>Modificare un dizionario</h3>
<p>I dizionari non hanno alcun limite predefinito sulla propria dimensione. Potete aggiungere nuove coppie chiave-valore a un dizionario in ogni momento, oppure potete modificare il valore di una chiave esistente. Continuando dall'esempio precedente:
<pre class=screen>
<samp class=p>>>> </samp><kbd>a_dict</kbd>
<samp>{'server': 'db.diveintopython3.org', 'database': 'mysql'}</samp>
<a><samp class=p>>>> </samp><kbd>a_dict["database"] = "blog"</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>a_dict</kbd>
<samp>{'server': 'db.diveintopython3.org', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd>a_dict["user"] = "mark"</kbd>      <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>a_dict</kbd>                       <span>&#x2462;</span></a>
<samp>{'server': 'db.diveintopython3.org', 'user': 'mark', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd>a_dict["user"] = "dora"</kbd>      <span>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd>a_dict</kbd>
<samp>{'server': 'db.diveintopython3.org', 'user': 'dora', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd>a_dict["User"] = "mark"</kbd>      <span>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd>a_dict</kbd>
<samp>{'User': 'mark', 'server': 'db.diveintopython3.org', 'user': 'dora', 'database': 'blog'}</samp></pre>
<ol>
<li>Non potete avere chiavi duplicate in un dizionario. Assegnare un valore a una chiave esistente cancellerà il vecchio valore.
<li>Potete aggiungere nuove coppie chiave-valore in ogni momento. Questa sintassi è identica a quella per modificare valori già esistenti.
<li>Il nuovo elemento nel dizionario (chiave <code>'user'</code>, valore <code>'mark'</code>) appare nel mezzo. In effetti, è stata solamente una coincidenza che gli elementi apparissero in ordine nel primo esempio; è allo stesso modo una coincidenza che appaiano fuori ordine ora.
<li>Assegnare un valore a una chiave esistente nel dizionario semplicemente sostituisce il vecchio valore con il nuovo.
<li>Questo assegnamento reinserirà "mark" come valore della chiave <code>user</code>? No! Guardate bene la chiave &mdash; c'è una <kbd>U</kbd> maiuscola in <kbd>"User"</kbd>. Le chiavi di un dizionario sono sensibili alle maiuscole, quindi questa istruzione crea una nuova coppia chiave-valore, senza sovrascriverne una esistente. A voi potrebbe sembrare simile, ma per quanto riguarda Python, è completamente diverso.
</ol>
<h3 id=mixed-value-dictionaries>Dizionari a valori misti</h3>
<p>I dizionari non funzionano solo con le stringhe. I valori in un dizionario possono appartenere a qualsiasi tipo di dato, compresi interi, booleani, oggetti arbitrari, e persino altri dizionari. E all'interno di un singolo dizionario, i valori non devono essere tutti dello stesso tipo; potete mescolarli a piacimento. Le chiavi di un dizionario hanno maggiori restrizioni, ma possono essere stringhe, interi, e di pochi altri tipi. Potete mescolare anche i tipi di dato delle chiavi all'interno di un singolo dizionario.
<p>In effetti, avete già visto un dizionario con chiavi e valori che non sono stringhe nel <a href=il-vostro-primo-programma-python.html#divingin>vostro primo programma Python</a>.
<pre><code>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}</code></pre>
<p>Analizziamo questo oggetto nella shell interattiva.
<pre class=screen>
<samp class=p>>>> </samp><kbd>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],</kbd>
<samp class=p>... </samp><kbd>            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}</kbd>
<a><samp class=p>>>> </samp><kbd>len(SUFFIXES)</kbd>      <span>&#x2460;</span></a>
<samp>2</samp>
<a><samp class=p>>>> </samp><kbd>SUFFIXES[1000]</kbd>     <span>&#x2461;</span></a>
<samp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd>SUFFIXES[1024]</kbd>     <span>&#x2462;</span></a>
<samp>['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']</samp>
<a><samp class=p>>>> </samp><kbd>SUFFIXES[1000][3]</kbd>  <span>&#x2463;</span></a>
<samp>'TB'</samp></pre>
<ol>
<li>Come per le <a href=#lists>liste</a><!-- and <a href=#sets>sets</a>-->, la funzione <code>len()</code> vi restituisce il numero di oggetti in un dizionario.
<li><code>1000</code> è una chiave nel dizionario <code>SUFFIXES</code>; il suo valore è una lista di otto elementi (otto stringhe, per essere precisi).
<li>Similmente, <code>1024</code> è una chiave nel dizionario <code>SUFFIXES</code>; il suo valore è anch'esso una lista di otto elementi.
<li>Dato che <code>SUFFIXES[1000]</code> è una lista, potete accedere ai singoli elementi in quella lista attraverso il loro indice a partire da 0.
</ol>
<h3 id=dictionaries-in-a-boolean-context>Dizionari in un contesto logico</h3>
<aside>I dizionari vuoti sono falsi; tutti gli altri dizionari sono veri.</aside>
<p>Potete usare i dizionari anche in <a href=#booleans>un contesto logico</a>, come quello di una istruzione <code>if</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd>  if anything:</kbd>
<samp class=p>... </samp><kbd>    print("sì, è vero")</kbd>
<samp class=p>... </samp><kbd>  else:</kbd>
<samp class=p>... </samp><kbd>    print("no, è falso")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd>is_it_true({})</kbd>             <span>&#x2460;</span></a>
<samp>no, è falso</samp>
<a><samp class=p>>>> </samp><kbd>is_it_true({'a': 1})</kbd>       <span>&#x2461;</span></a>
<samp>sì, è vero</samp></pre>
<ol>
<li>In un contesto logico, un dizionario vuoto è falso.
<li>Qualsiasi dizionario con almeno una coppia chiave-valore è vero.
</ol>
<h2 id=none><code>None</code></h2>
<p><code>None</code> è una costante speciale in Python. &Egrave; un valore nullo. <code>None</code> non è la stessa cosa di <code>False</code>. <code>None</code> non è <code>0</code>. <code>None</code> non è una stringa vuota. Confrontare <code>None</code> con qualcos'altro che non sia <code>None</code> restituirà sempre <code>False</code>.
<p><code>None</code> è l'unico valore nullo. Ha un proprio tipo di dato (<code>NoneType</code>). Potete assegnare <code>None</code> a qualsiasi variabile, ma non potete creare altri oggetti di tipo <code>NoneType</code>. Tutte le varibili il cui valore è <code>None</code> sono uguali tra loro.
<pre class=screen>
<samp class=p>>>> </samp><kbd>type(None)</kbd>
<samp>&lt;class 'NoneType'></samp>
<samp class=p>>>> </samp><kbd>None == False</kbd>
<samp>False</samp>
<samp class=p>>>> </samp><kbd>None == 0</kbd>
<samp>False</samp>
<samp class=p>>>> </samp><kbd>None == ''</kbd>
<samp>False</samp>
<samp class=p>>>> </samp><kbd>None == None</kbd>
<samp>True</samp>
<samp class=p>>>> </samp><kbd>x = None</kbd>
<samp class=p>>>> </samp><kbd>x == None</kbd>
<samp>True</samp>
<samp class=p>>>> </samp><kbd>y = None</kbd>
<samp class=p>>>> </samp><kbd>x == y</kbd>
<samp>True</samp>
</pre>
<h3 id=none-in-a-boolean-context><code>None</code> in un contesto logico</h3>
<p>In <a href=#booleans>un contesto logico</a>, <code>None</code> è falso e <code>not None</code> è vero.
<pre class=screen>
<samp class=p>>>> </samp><kbd>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd>  if anything:</kbd>
<samp class=p>... </samp><kbd>    print("sì, è vero")</kbd>
<samp class=p>... </samp><kbd>  else:</kbd>
<samp class=p>... </samp><kbd>    print("no, è falso")</kbd>
<samp class=p>...</samp>
<samp class=p>>>> </samp><kbd>is_it_true(None)</kbd>
<samp>no, è falso</samp>
<samp class=p>>>> </samp><kbd>is_it_true(not None)</kbd>
<samp>sì, è vero</samp></pre>
<h2 id=furtherreading>Letture di approfondimento</h2>
<ul>
<li><a href="http://docs.python.org/3.0/library/fractions.html">The <code>fractions</code> module</a>
<li><a href="http://docs.python.org/3.0/library/math.html">The <code>math</code> module</a>
<li><a href="http://www.python.org/dev/peps/pep-0237/"><abbr>PEP</abbr> 237: Unifying Long Integers and Integers</a>
<li><a href="http://www.python.org/dev/peps/pep-0238/"><abbr>PEP</abbr> 238: Changing the Division Operator</a>
</ul>
<p class=nav><a rel=prev href=il-vostro-primo-programma-python.html title="indietro a &#8220;Il vostro primo programma Python&#8221;"><span>&#x261C;</span></a> <a rel=next href=stringhe.html title="avanti a &#8220;Stringhe&#8221;"><span>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;9 <a href=informazioni-sul-libro.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
