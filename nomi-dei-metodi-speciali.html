<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Nomi dei metodi speciali - Dive into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<link rel=stylesheet href=dip3-it.css>
<style>
h1:before{counter-increment:h1;content:"Appendice B. "}
h2:before{counter-increment:h2;content:"B." counter(h2) ". "}
h3:before{counter-increment:h3;content:"B." counter(h2) "." counter(h3) ". "}
tr + tr th:first-child{font:medium 'Arial Unicode MS',FreeSerif,OpenSymbol,'DejaVu Sans',sans-serif}
table{width:100%;border-collapse:collapse}
th,td{width:30%;padding:0 0.5em;border:1px solid #bbb}
th{text-align:left;vertical-align:baseline}
td{vertical-align:top}
th:first-child{width:10%;text-align:center}
th,td,td pre{margin:0}
td pre{padding:0;border:0}
td a:link, td a:visited{border:0}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#special-method-names>Dive Into Python 3</a> <span>&#8227;</span>
<p id=level>Livello di difficoltà: <span class=u title=pro>&#x2666;&#x2666;&#x2666;&#x2666;&#x2666;</span>
<h1>Nomi dei metodi speciali</h1>
<blockquote class=q>
<p><span>&#x275D;</span> La mia specialità è avere ragione quando altri hanno torto. <span>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/George_Bernard_Shaw>George Bernard Shaw</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>Abbiamo già trattato alcuni metodi speciali in altri punti di questo libro &mdash; metodi &#8220;magici&#8221; che Python invoca quando usate una certa sintassi. Sfruttando i metodi speciali, le vostre classi possono assumere il comportamento di sequenze, dizionari, funzioni, iteratori, o addirittura numeri! Questa appendice serve sia come riferimento per i metodi speciali che abbiamo già visto, sia come breve introduzione ad alcuni dei metodi speciali più esoterici.

<h2 id=basics>Le basi</h2>

<p>Se avete letto <a href=iterators.html#divingin>l'introduzione alle classi</a>, avete già visto il metodo speciale più comune: il metodo <code>__init__()</code>. La maggior parte delle classi che scrivo finiscono per avere bisogno di un qualche tipo di inizializzazione. Ci sono anche alcuni altri metodi speciali di base che si rivelano particolarmente utili quando dovete effettuare il debug delle vostre classi.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>&#x2460;
<td>inizializzare un'istanza
<td><code>x = MyClass()</code>
<td><code>x.<dfn>__init__</dfn>()</code>
<tr><th>&#x2461;
<td>la rappresentazione &#8220;ufficiale&#8221; sotto forma di stringa
<td><code><dfn>repr</dfn>(x)</code>
<td><code>x.<dfn>__repr__</dfn>()</code>
<tr><th>&#x2462;
<td>la rappresentazione &#8220;informale&#8221; sotto forma di stringa
<td><code><dfn>str</dfn>(x)</code>
<td><code>x.<dfn>__str__</dfn>()</code>
<tr><th>&#x2463;
<td>la rappresentazione &#8220;informale&#8221; sotto forma di array di byte
<td><code><dfn>bytes</dfn>(x)</code>
<td><code>x.<dfn>__bytes__</dfn>()</code>
<tr><th>&#x2464;
<td>la rappresentazione sotto forma di stringa formattata
<td><code>format(x)</code>
<td><code>x.<dfn>__format__</dfn>(<var>format_spec</var>)</code>
</table>
<ol>
<li>Il metodo <code>__init__()</code> viene invocato <em>dopo</em> che l'istanza è stata creata. Se volete controllare l'effettivo processo di creazione, usate <a href=#esoterica>il metodo <code>__new__()</code></a>.
<li>Per convenzione, la stringa restituita dal metodo <code>__repr__()</code> dovrebbe essere un'espressione Python valida.
<li>Il metodo <code>__str__()</code> viene invocato anche quando chiamate <code>print(x)</code>.
<li>Il metodo <code>__bytes__()</code> è <em>una novità di Python 3</em>, dato che il tipo <code>bytes</code> è stato introdotto in questa versione del linguaggio.
<li>Per convenzione, <var>format_spec</var> dovrebbe conformarsi al <a href=http://www.python.org/doc/3.0/library/string.html#formatspec>mini-linguaggio per le specifiche di formato</a>. Il modulo <code>decimal</code> nella libreria standard di Python implementa il proprio metodo <code>__format__()</code>.
</ol>

<h2 id=acts-like-iterator>Classi che si comportano come iteratori</h2>

<p>Nel <a href=iterators.html>capitolo sugli iteratori</a> avete visto come implementare un iteratore da zero utilizzando i metodi <code>__iter__()</code> e <code>__next__()</code>.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>&#x2460;
<td>iterare attraverso una sequenza
<td><code><dfn>iter</dfn>(seq)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__iter__><code>seq.<dfn>__iter__</dfn>()</code></a>
<tr><th>&#x2461;
<td>ottenere il valore successivo da un iteratore
<td><code><dfn>next</dfn>(seq)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__next__><code>seq.<dfn>__next__</dfn>()</code></a>
<tr><th>&#x2462;
<td>creare un iteratore in ordine inverso
<td><code><dfn>reversed</dfn>(seq)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__reversed__><code>seq.<dfn>__reversed__</dfn>()</code></a>
</table>
<ol>
<li>Il metodo <code>__iter__()</code> viene invocato ogni volta che create un nuovo iteratore. &Egrave; un buon posto per inizializzare valori che saranno poi necessari durante l'iterazione.
<li>Il metodo <code>__next__()</code> viene invocato ogni volta che recuperate il valore successivo da un iteratore.
<li>Il metodo <code>__reversed__()</code> è poco comune. Prende una sequenza esistente e restituisce un iteratore che produce gli elementi della sequenza in ordine inverso, dall'ultimo al primo.
</ol>

<h2 id=computed-attributes>Proprietà calcolate</h2>

<p class=fixme>FIXME not sure of the wording/depth required here because I don't yet know if I'm going to cover these in a previous chapter. Let's assume I'm not, and I can move the examples later if need be.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>&#x2460;
<td>ottenere (incondizionatamente) una proprietà calcolata
<td><code>x.my_property</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__getattribute__><code>x.<dfn>__getattribute__</dfn>(<var>"my_property"</var>)</code></a>
<tr><th>&#x2461;
<td>ottenere (alternativamente) una proprietà calcolata
<td><code>x.my_property</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__getattr__><code>x.<dfn>__getattr__</dfn>(<var>"my_property"</var>)</code></a>
<tr><th>&#x2462;
<td>impostare il valore di una proprietà
<td><code>x.my_property = value</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__setattr__><code>x.<dfn>__setattr__</dfn>(<var>"my_property"</var>, <var>value</var>)</code></a>
<tr><th>&#x2463;
<td>eliminare una proprietà
<td><code>del x.my_property</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__delattr__><code>x.<dfn>__delattr__</dfn>(<var>"my_property"</var>)</code></a>
<tr><th>&#x2464;
<td>elencare tutte le proprietà e i metodi
<td><code>dir(x)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__dir__><code>x.<dfn>__dir__</dfn>()</code></a>
</table>
<ol>
<li>Se la vostra classe definisce un metodo <code>__getattribute__()</code>, Python lo invocherà <em>ogni volta che fate riferimento al nome di una proprietà o di un metodo qualsiasi</em> (a parte i nomi dei metodi speciali, dato che questo causerebbe uno spiacevole ciclo infinito).
<li>Se la vostra classe definisce un metodo <code>__getattr__()</code>, Python lo invocherà solo dopo aver cercato la proprietà in tutti i posti in cui viene cercata normalmente. Se un'istanza <var>x</var> definise una proprietà <var>color</var>, l'accesso a <var>x.color</var> <em>non</em> causerà l'invocazione di <code>x.__getattr__("color")</code> ma restituirà semplicemente il valore di <var>x.color</var> già definito.
<li>Il metodo <code>__setattr__()</code> viene invocato ogni volta che assegnate un valore a una proprietà.
<li>Il metodo <code>__delattr__()</code> viene invocato ogni volta che eliminate una proprietà.
<li>Il metodo <code>__dir__()</code> è utile se definite un metodo <code>__getattr__()</code> o un metodo <code>__getattribute__()</code>. Generalmente, l'invocazione di <code>dir(x)</code> elenca solo le proprietà e i metodi normali. Se il vostro metodo <code>__getattr__()</code> gestisce dinamicamente una proprietà <var>color</var>, <code>dir(x)</code> non mostrerà <var>color</var> come una delle proprietà disponibili. Fornire una vostra implementazione del metodo <code>__dir__()</code> vi permette di mostrare <var>color</var> nell'elenco delle proprietà disponibili, venendo in aiuto ad altri programmatori che vorrebbero usare la vostra classe senza doverne esaminare i dettagli interni.
</ol>

<p>La distinzione tra i metodi <code>__getattr__()</code> e <code>__getattribute__()</code> è sottile ma importante. Posso spiegarla con due esempi:

<pre class=screen>
<code>class Dynamo:
    def __getattr__(self, key):
<a>        if key == "color":         <span>&#x2460;</span></a>
            return "PapayaWhip"
        else:
<a>            raise AttributeError   <span>&#x2461;</span></a></code>

<samp class=p>>>> </samp><kbd>dyn = Dynamo()</kbd>
<a><samp class=p>>>> </samp><kbd>dyn.color</kbd>                      <span>&#x2462;</span></a>
<samp>'PapayaWhip'</samp>
<samp class=p>>>> </samp><kbd>dyn.color = "LemonChiffon"</kbd>
<a><samp class=p>>>> </samp><kbd>dyn.color</kbd>                      <span>&#x2463;</span></a>
<samp>'LemonChiffon'</samp></pre>
<ol>
<li>Il nome della proprietà viene passato al metodo <code>__getattr__()</code> sotto forma di stringa. Se il nome è <code>"color"</code>, il metodo restituisce un valore. (In questo caso, il valore è solo una stringa costante, ma normalmente effettuereste una qualche sorta di computazione e ne restituireste il risultato.)
<li>Se il nome della proprietà è sconosciuto, il metodo <code>__getattr__()</code> deve sollevare un'eccezione di tipo <code>AttributeError</code>, altrimenti il vostro codice fallirà silenziosamente quando accedete a proprietà non definite. (Tecnicamente, se il metodo non solleva un'eccezione o restituisce esplicitamente un valore, allora restituisce <code>None</code>, il valore nullo di Python. In questo caso, <em>tutte</em> le proprietà non esplicitamente definite varrebbero <code>None</code>, che quasi sicuramente non è quello che volete.)
<li>L'istanza <var>dyn</var> non ha una proprietà chiamata <var>color</var>, quindi il metodo <code>__getattr__()</code> viene invocato per fornirne il valore calcolato.
<li>Dopo aver esplicitamente impostato <var>dyn.color</var>, il metodo <code>__getattr__()</code> non viene più invocato per fornire il valore di <var>dyn.color</var>, perché <var>dyn.color</var> è già definita in questa istanza.
</ol>

<p>D'altra parte, il metodo <code>__getattribute__()</code> viene invocato in maniera assoluta e incondizionata.

<pre class=screen>
<code>class SuperDynamo:
    def __getattribute__(self, key):
        if key == 'color':
            return "PapayaWhip"
        else:
            raise AttributeError</code>

<samp class=p>>>> </samp><kbd>dyn = SuperDynamo()</kbd>
<a><samp class=p>>>> </samp><kbd>dyn.color</kbd>                      <span>&#x2460;</span></a>
<samp>"PapayaWhip"</samp>
<samp class=p>>>> </samp><kbd>dyn.color = "LemonChiffon"</kbd>
<a><samp class=p>>>> </samp><kbd>dyn.color</kbd>                      <span>&#x2461;</span></a>
<samp>"PapayaWhip"</samp></pre>
<ol>
<li>Il metodo <code>__getattribute__()</code> viene invocato per fornire il valore di <var>dyn.color</var>.
<li>Anche dopo aver esplicitamente impostato <var>dyn.color</var>, il metodo <code>__getattribute__()</code> <em>viene ancora invocato</em> per fornirne il valore. Se esiste, il metodo <code>__getattribute__()</code> <em>viene invocato incondizionatamente</em> per ogni accesso a proprietà e metodi, anche per proprietà che avete esplicitamente impostato dopo la creazione di un'istanza.
</ol>

<blockquote class=note>
<p><span>&#x261E;</span>Se la vostra classe definisce un metodo <code>__getattribute__()</code>, vorrete probabilmente definire anche un metodo <code>__setattr__()</code> e coordinare i due per tenere traccia del valore delle proprietà. Altrimenti, qualsiasi proprietà che impostiate dopo aver creato un'istanza scomparirà in un buco nero.
</blockquote>

<p>Dovete usare il metodo <code>__getattribute__()</code> con particolare attenzione, perché viene invocato anche quando Python cerca il nome di un metodo nella vostra classe.

<pre class=screen>
<code>class Rastan:
    def __getattribute__(self, key):
<a>        raise AttributeError           <span>&#x2460;</span></a>
    def swim(self):
        pass</code>

<samp class=p>>>> </samp><kbd>hero = Rastan()</kbd>
<a><samp class=p>>>> </samp><kbd>hero.swim()</kbd>                        <span>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;stdin>", line 3, in __getattribute__
AttributeError</samp></pre>
<ol>
<li>Questa classe definisce un metodo <code>__getattribute__()</code> che solleva sempre un'eccezione di tipo <code>AttributeError</code>. Nessun accesso a proprietà o metodi avrà successo.
<li>Quando invocate <code>hero.swim()</code>, Python cerca un metodo <code>swim()</code> nella classe <code>Rastan</code>. Questa ricerca passa attraverso il metodo <code>__getattribute__()</code>, <em>perché tutti gli accessi a proprietà e metodi passano attraverso il metodo <code>__getattribute__()</code></em>. In questo caso, il metodo <code>__getattribute__()</code> solleva un'eccezione di tipo <code>AttributeError</code>, quindi l'accesso al metodo fallisce, quindi la chiamata di metodo fallisce.
</ol>

<h2 id=acts-like-function>Classi che si comportano come funzioni</h2>

<p>Potete rendere invocabile un'istanza di una classe &mdash; esattamente come è invocabile una funzione &mdash; definendo il metodo <code>__call__()</code>.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>&#8220;invocare&#8221; un'istanza come una funzione
<td><code>my_instance()</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__call__><code>my_instance.<dfn>__call__</dfn>()</code></a>
</table>

<p>Il <a href=http://docs.python.org/3.0/library/zipfile.html>modulo <code>zipfile</code></a> usa questa tecnica per definire una classe che possa <dfn>decodificare</dfn> un file <dfn>zip</dfn> <dfn>criptato</dfn> con una data password. L'algoritmo di <dfn>decodifica</dfn> per i file zip richiede di memorizzare uno stato durante l'esecuzione. Definire il decodificatore come una classe vi permette di mantenere questo stato all'interno di una singola istanza di tale classe. Lo stato viene inizializzato nel metodo <code>__init__()</code> e aggiornato man mano che il file viene <dfn>decodificato</dfn>. Ma dato che la classe è anche &#8220;invocabile&#8221; come una funzione, potete passare l'istanza come primo argomento alla funzione <code>map()</code>, in questo modo:

<pre><code>
# estratto da zipfile.py
class _ZipDecrypter:
.
.
.
    def __init__(self, pwd):
<a>        self.key0 = 305419896               <span>&#x2460;</span></a>
        self.key1 = 591751049
        self.key2 = 878082192
        for p in pwd:
            self._UpdateKeys(p)

<a>    def __call__(self, c):                  <span>&#x2461;</span></a>
        assert isinstance(c, int)
        k = self.key2 | 2
        c = c ^ (((k * (k^1)) >> 8) & 255)
        self._UpdateKeys(c)
        return c
.
.
.
<a>zd = _ZipDecrypter(pwd)                    <span>&#x2462;</span></a>
bytes = zef_file.read(12)
<a>h = list(map(zd, bytes[0:12]))             <span>&#x2463;</span></a></code></pre>
<ol>
<li>La classe <code>_ZipDecrypter</code> mantiene il proprio stato sotto forma di tre chiavi di cifratura, che vengono successivamente aggiornate facendone ruotare i bit nel metodo <code>_UpdateKeys()</code> (che qui non viene mostrato).
<li>La classe definisce un metodo <code>__call__()</code> che rende le istanze di questa classe invocabili come funzioni. In questo caso, il metodo <code>__call__()</code> decodifica un singolo byte del file zip, quindi aggiorna le chiavi di cifratura sulla base del byte che è stato decodificato.
<li><var>zd</var> è un'istanza della classe <code>_ZipDecrypter</code>. La variabile <var>pwd</var> viene passata al metodo <code>__init__()</code>, dove viene memorizzata e usata per aggiornare le chiavi di cifratura per la prima volta.
<li>Dati i primi 12 byte di un file zip, li decodificate applicando <var>zd</var> ai byte, in sostanza &#8220;invocando&#8221; 12 volte <var>zd</var>, quindi invocando 12 volte il metodo <code>__call__()</code>, che per 12 volte aggiorna lo stato interno del decodificatore e restituisce un byte come risultato.
</ol>

<h2 id=acts-like-list>Classi che si comportano come sequenze</h2>

<p>Nel caso la vostra classe agisca come contenitore per un insieme di valori &mdash; cioè, nel caso abbia senso chiedere se la vostra classe &#8220;contiene&#8221; un valore &mdash; allora dovrebbe probabilmente definire i seguenti metodi speciali che le permettono di assumere il comportamento di una sequenza.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>la lunghezza di una sequenza
<td><code><dfn>len</dfn>(seq)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__len__><code>seq.<dfn>__len__</dfn>()</code></a>
<tr><th>
<td>sapere se una sequenza contiene uno specifico valore
<td><code>x in seq</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__contains__><code>seq.<dfn>__contains__</dfn>(<var>x</var>)</code></a>
</table>

<p id=acts-like-list-example>Il <a href=http://docs.python.org/3.0/library/cgi.html>modulo <code>cgi</code></a> sfrutta questi metodi nella sua classe <code>FieldStorage</code>, che rappresenta tutti i campi di una form o i parametri di richiesta inviati a una pagina web dinamica.

<pre><code>
# Uno script che risponde a http://example.com/search?q=cgi
import cgi
fs = cgi.FieldStorage()
<a>if "q" in fs:                                               <span>&#x2460;</span></a>
  do_search()

# Un estratto da cgi.py che spiega come funziona lo script
class FieldStorage:
.
.
.
<a>    def __contains__(self, key):                            <span>&#x2461;</span></a>
        if self.list is None:
            raise TypeError("not indexable")
<a>        return any(item.name == key for item in self.list)  <span>&#x2462;</span></a>

<a>    def __len__(self):                                      <span>&#x2463;</span></a>
        return len(self.keys())</code></pre>
<ol>
<li>Una volta creata un'istanza della classe <code>cgi.FieldStorage</code>, potete usare l'operatore &#8220;<code>in</code>&#8221; per controllare se un particolare parametro è stato incluso nella stringa di richiesta.
<li>Il metodo <code>__contains__()</code> è la magia che fa funzionare quel controllo.
<li>Quando dite <code>if "q" in fs</code>, Python cerca nell'oggetto <var>fs</var> il metodo <code>__contains__()</code>, che è definito in <code>cgi.py</code>. Il valore <code>"q"</code> è passato al metodo <code>__contains__()</code> come argomento <var>key</var>.
<li>La stessa classe <code>FieldStorage</code> è in grado di restituire il valore della propria lunghezza, quindi <code>len(<var>fs</var>)</code> invocherà il metodo <code>__len__()</code> sull'istanza della classe <code>FieldStorage</code> per restituire il numero di parametri di richiesta che sono stati identificati.
</ol>

<h2 id=acts-like-dict>Classi che si comportano come dizionari</h2>

<p>Estendendo un poco la sezione precedente, potete definire classi che non solo rispondono all'operatore &#8220;<code>in</code>&#8221; e alla funzione <code>len()</code>, ma che si comportano come dizionari veri e propri, restituendo valori sulla base di chiavi.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>ottenere un valore tramite la sua chiave
<td><code>x[key]</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__getitem__><code>x.<dfn>__getitem__</dfn>(<var>"key"</var>)</code></a>
<tr><th>
<td>impostare un valore tramite la sua chiave
<td><code>x[key] = value</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__setitem__><code>x.<dfn>__setitem__</dfn>(<var>"key"</var>, <var>value</var>)</code></a>
<tr><th>
<td>eliminare una coppia chiave-valore
<td><code>del x[key]</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__delitem__><code>x.<dfn>__delitem__</dfn>(<var>"key"</var>)</code></a>
<tr><th>
<td>fornire un valore di default per chiavi mancanti
<td><code>x[nonexistent_key]</code>
<td><a href=http://docs.python.org/3.0/library/collections.html#collections.defaultdict.__missing__><code>x.<dfn>__missing__</dfn>(<var>"nonexistent_key"</var>)</code></a>
</table>

<p>La <a href=#acts-like-list-example>classe <code>FieldStorage</code></a> del <a href=http://docs.python.org/3.0/library/cgi.html>modulo <code>cgi</code></a> definisce anche questi metodi speciali, in modo che possiate fare cose come queste:

<pre><code>
# Uno script che risponde a http://example.com/search?q=cgi
import cgi
fs = cgi.FieldStorage()
if "q" in fs:
<a>  do_search(fs["q"])                              <span>&#x2460;</span></a>

# Un estratto da cgi.py che spiega come funziona lo script
class FieldStorage:
.
.
.
<a>    def __getitem__(self, key):                   <span>&#x2461;</span></a>
        if self.list is None:
            raise TypeError("not indexable")
        found = []
        for item in self.list:
            if item.name == key: found.append(item)
        if not found:
            raise KeyError(key)
        if len(found) == 1:
            return found[0]
        else:
            return found</code></pre>
<ol>
<li>L'oggetto <var>fs</var> è un'istanza di <code>cgi.FieldStorage</code>, tuttavia potete valutare espressioni come <code>fs["q"]</code>.
<li><code>fs["q"]</code> invoca il metodo <code>__getitem__()</code> con il parametro <var>key</var> impostato a <code>"q"</code>. Quindi controlla se la lista di parametri di richiesta che mantiene internamente (<var>self.list</var>) contiene un elemento la cui proprietà <code>name</code> corrisponde alla chiave data.
</ol>

<h2 id=acts-like-number>Classi che si comportano come numeri</h2>

<p>Usando i metodi speciali appropriati, potete definire classi che si comportano come numeri. Questo significa che potete sommarle, sottrarle ed eseguire su di esse altre operazioni matematiche. Questo è il modo in cui <a href=advanced-classes.html#implementing-fractions>sono realizzate le <dfn>frazioni</dfn></a> &mdash; la classe <code><dfn>Fraction</dfn></code> implementa questi metodi speciali, in modo che possiate fare cose come questa:

<pre class=screen>
<samp class=p>>>> </samp><kbd>from fractions import Fraction</kbd>
<samp class=p>>>> </samp><kbd>x = Fraction(1, 3)</kbd>
<samp class=p>>>> </samp><kbd>x / 3</kbd>
<samp>Fraction(1, 9)</samp></pre>

<p>Ecco la lista completa dei metodi speciali che dovete implementare per avere una classe simile ai numeri.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>addizione
<td><code>x + y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__add__><code>x.<dfn>__add__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>sottrazione
<td><code>x - y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__sub__><code>x.<dfn>__sub__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>moltiplicazione
<td><code>x * y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__mul__><code>x.<dfn>__mul__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>divisione
<td><code>x / y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__truediv__><code>x.<dfn>__truediv__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>divisione intera
<td><code>x // y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__floordiv__><code>x.<dfn>__floordiv__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>modulo (resto)
<td><code>x % y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__mod__><code>x.<dfn>__mod__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>divisione intera <i class=baa>&amp;</i> modulo
<td><code>divmod(x, y)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__divmod__><code>x.<dfn>__divmod__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>elevamento a potenza
<td><code>x ** y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__pow__><code>x.<dfn>__pow__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>scorrimento a sinistra
<td><code>x &lt;&lt; y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__lshift__><code>x.<dfn>__lshift__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>scorrimento a destra
<td><code>x >> y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rshift__><code>x.<dfn>__rshift__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td><code>and</code> bit per bit
<td><code>x &amp; y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__and__><code>x.<dfn>__and__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td><code>xor</code> bit per bit
<td><code>x ^ y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__xor__><code>x.<dfn>__xor__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td><code>or</code> bit per bit
<td><code>x | y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__or__><code>x.<dfn>__or__</dfn>(<var>y</var>)</code></a>
</table>

<p>Tutto questo va bene se <var>x</var> è un'istanza di una classe che implementa questi metodi. Ma cosa succede se non ne implementa uno? O peggio, cosa succede se lo implementa, ma non può gestire certi tipi di argomenti? Per esempio:

<pre class=screen>
<samp class=p>>>> </samp><kbd>from fractions import Fraction</kbd>
<samp class=p>>>> </samp><kbd>x = Fraction(1, 3)</kbd>
<samp class=p>>>> </samp><kbd>1 / x</kbd>
<samp>Fraction(3, 1)</samp></pre>

<p>Questo <em>non</em> è il caso in cui un oggetto <code>Fraction</code> viene diviso per un intero (come nell'esempio precedente). Quel caso era semplice: <code>x / 3</code> invoca <code>x.__truediv__(3)</code> e il metodo <code>__truediv__()</code> della classe <code>Fraction</code> gestisce tutta la matematica coinvolta. Ma gli interi non &#8220;sanno&#8221; come fare operazioni aritmetiche con le frazioni. Quindi come mai questo esempio funziona?

<p>La risposta è in un secondo insieme di metodi speciali per l'aritmetica con <i>operandi rovesciati</i>. Data un'operazione aritmetica con due operandi (<i>e.g.</i> <code>x / y</code>), ci sono due modi di eseguirla:

<ol>
<li>Dire a <var>x</var> di dividersi per <var>y</var>, oppure
<li>Dire a <var>y</var> di dividere <var>x</var> per lei stessa
</ol>

<p>L'insieme di metodi speciali appena visto adotta il primo approccio: dato <code>x / y</code>, fornisce a <var>x</var> un modo per dire &#8220;So come dividermi per <var>y</var>.&#8221; L'insieme di metodi speciali che segue adotta il secondo approccio: fornisce a <var>y</var> un modo per dire &#8220;So come fare il denominatore e dividere <var>x</var> per me stessa.&#8221;

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>addizione
<td><code>x + y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__radd__><code>y.<dfn>__radd__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>sottrazione
<td><code>x - y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rsub__><code>y.<dfn>__rsub__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>moltiplicazione
<td><code>x * y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rmul__><code>y.<dfn>__rmul__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>divisione
<td><code>x / y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rtruediv__><code>y.<dfn>__rtruediv__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>divisione intera
<td><code>x // y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rfloordiv__><code>y.<dfn>__rfloordiv__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>modulo (resto)
<td><code>x % y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rmod__><code>y.<dfn>__rmod__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>divisione intera <i class=baa>&amp;</i> modulo
<td><code>divmod(x, y)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rdivmod__><code>y.<dfn>__rdivmod__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>elevamento a potenza
<td><code>x ** y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rpow__><code>y.<dfn>__rpow__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>scorrimento a sinistra
<td><code>x &lt;&lt; y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rlshift__><code>y.<dfn>__rlshift__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>scorrimento a destra
<td><code>x >> y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rrshift__><code>y.<dfn>__rrshift__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td><code>and</code> bit per bit
<td><code>x &amp; y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rand__><code>y.<dfn>__rand__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td><code>xor</code> bit per bit
<td><code>x ^ y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__rxor__><code>y.<dfn>__rxor__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td><code>or</code> bit per bit
<td><code>x | y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__ror__><code>y.<dfn>__ror__</dfn>(<var>x</var>)</code></a>
</table>

<p>Ma aspettate! C'è di più! Se state eseguendo operazioni &#8220;in loco&#8221;, come <code>x /= 3</code>, ci sono ancora altri metodi speciali aggiuntivi che potete definire.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>addizione in loco
<td><code>x += y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__iadd__><code>x.<dfn>__iadd__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>sottrazione in loco
<td><code>x -= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__isub__><code>x.<dfn>__isub__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>moltiplicazione in loco
<td><code>x *= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__imul__><code>x.<dfn>__imul__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>divisione in loco
<td><code>x /= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__itruediv__><code>x.<dfn>__itruediv__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>divisione intera in loco
<td><code>x //= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__ifloordiv__><code>x.<dfn>__ifloordiv__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>modulo in loco
<td><code>x %= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__imod__><code>x.<dfn>__imod__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>elevamento a potenza in loco
<td><code>x **= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__ipow__><code>x.<dfn>__ipow__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>scorrimento a sinistra in loco
<td><code>x &lt;&lt;= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__ilshift__><code>x.<dfn>__ilshift__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>scorrimento a destra in loco
<td><code>x >>= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__irshift__><code>x.<dfn>__irshift__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td><code>and</code> bit per bit in loco
<td><code>x &amp;= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__iand__><code>x.<dfn>__iand__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td><code>xor</code> bit per bit in loco
<td><code>x ^= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__ixor__><code>x.<dfn>__ixor__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td><code>or</code> bit per bit in loco
<td><code>x |= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__ior__><code>x.<dfn>__ior__</dfn>(<var>y</var>)</code></a>
</table>

<p>Notate che la maggior parte dei metodi per le operazioni in loco non è richiesta. Se non definite il metodo per una particolare operazione in loco, Python proverà a utilizzare gli altri metodi. Per esempio, cercando di eseguire l'espressione <code>x /= y</code>, Python proverà a:

<ol>
<li>Invocare <code>x.__itruediv__(<var>y</var>)</code>. Se questo metodo è definito e restituisce un valore diverso da <code>NotImplemented</code>, abbiamo finito.
<li>Invocare <code>x.__truediv__(<var>y</var>)</code>. Se questo metodo è definito e restituisce un valore diverso da <code>NotImplemented</code>, il vecchio valore di <var>x</var> viene scartato e rimpiazzato dal valore restituito, esattamente come se aveste eseguito <code>x = x / y</code>.
<li>Invocare <code>y.__rtruediv__(<var>x</var>)</code>. Se questo metodo è definito e restituisce un valore diverso da <code>NotImplemented</code>, il vecchio valore di <var>x</var> viene scartato e rimpiazzato dal valore restituito.
</ol>

<p>Quindi avete bisogno di definire metodi in loco come il metodo <code>__itruediv__()</code> solo se volete effettuare qualche ottimizzazione speciale per l'operando in loco. Altrimenti, Python essenzialmente riformulerà l'operazione in loco in modo da utilizzare un operando normale più un assegnamento di variabile.

<p>Ci sono anche alcune operazioni matematiche &#8220;unarie&#8221; che gli oggetti simili a numeri possono eseguire su sé stessi.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>un numero negativo
<td><code>-x</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__neg__><code>x.<dfn>__neg__</dfn>()</code></a>
<tr><th>
<td>un numero positivo
<td><code>+x</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__pos__><code>x.<dfn>__pos__</dfn>()</code></a>
<tr><th>
<td>il valore assoluto
<td><code>abs(x)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__abs__><code>x.<dfn>__abs__</dfn>()</code></a>
<tr><th>
<td>l'inverso
<td><code>~x</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__invert__><code>x.<dfn>__invert__</dfn>()</code></a>
<tr><th>
<td>un numero complesso
<td><code>complex(x)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__complex__><code>x.<dfn>__complex__</dfn>()</code></a>
<tr><th>
<td>un numero intero
<td><code>int(x)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__int__><code>x.<dfn>__int__</dfn>()</code></a>
<tr><th>
<td>un numero in virgola mobile
<td><code>float(x)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__float__><code>x.<dfn>__float__</dfn>()</code></a>
<tr><th>
<td>un numero arrotondato all'intero più vicino
<td><code>round(x)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__round__><code>x.<dfn>__round__</dfn>()</code></a>
<tr><th>
<td>un numero arrotondato alla <var>n</var>-sima cifra
<td><code>round(x, n)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__round__><code>x.<dfn>__round__</dfn>(n)</code></a>
<tr><th>
<td>il più piccolo intero che sia <code>>= x</code>
<td><code>math.ceil(x)</code>
<td><a href=http://docs.python.org/3.0/library/math.html#math.ceil><code>x.<dfn>__ceil__</dfn>()</code></a>
<tr><th>
<td>il più grande intero che sia <code>&lt;= x</code>
<td><code>math.floor(x)</code>
<td><a href=http://docs.python.org/3.0/library/math.html#math.floor><code>x.<dfn>__floor__</dfn>()</code></a>
<tr><th>
<td>troncare <code>x</code> all'intero più vicino verso lo <code>0</code>
<td><code>math.trunc(x)</code>
<td><a href=http://docs.python.org/3.0/library/math.html#math.trunc><code>x.<dfn>__trunc__</dfn>()</code></a>
<tr><th><a href=http://www.python.org/dev/peps/pep-0357/>PEP 357</a>
<td>usare un numero come indice di lista
<td><code>a_list[<var>x</var>]</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__index__><code>x.<dfn>__index__</dfn>()</code></a>
</table>

<h2 id=rich-comparisons>Classi che possono essere confrontate</h2>

<p>Ho separato questa sezione dalla precedente perché i confronti non sono strettamente un privilegio dei numeri. Molti tipi di dato possono essere confrontati &mdash; stringhe, liste, persino dizionari. Se state creando una vostra classe e ha senso confrontare i vostri oggetti con altri oggetti, potete usare i metodi speciali che seguono per realizzare i confronti.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>uguaglianza
<td><code>x == y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__eq__><code>x.<dfn>__eq__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>disuguaglianza
<td><code>x != y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__ne__><code>x.<dfn>__ne__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>minore di
<td><code>x &lt; y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__lt__><code>x.<dfn>__lt__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>minore o uguale a
<td><code>x &lt;= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__le__><code>x.<dfn>__le__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>maggiore di
<td><code>x >  y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__gt__><code>x.<dfn>__gt__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>maggiore o uguale a
<td><code>x >= y</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__ge__><code>x.<dfn>__ge__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>un valore di verità in un contesto logico
<td><code>if x:</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__bool__><code>x.<dfn>__bool__</dfn>()</code></a>
</table>

<h2 id=pickle>Classi che possono essere serializzate</h2>
<!--see http://docs.python.org/3.0/library/pickle.html:-->

<p>Python supporta la serializzazione e la deserializzazione di oggetti arbitrari. (La maggior parte del materiale di consultazione su Python chiama questi processi &#8220;pickling&#8221; e &#8220;unpickling.&#8221;) La serializzazione può rivelarsi utile per salvare lo stato di un oggetto su un file e ripristinarlo successivamente. Tutti i <a href=native-datatypes.html>tipi di dato nativi</a> includono già il supporto per la serializzazione. Se create una classe che volete essere in grado di serializzare, vi suggerisco di leggere la documentazione sul <a href=http://docs.python.org/3.0/library/pickle.html>protocollo di serializzazione</a> per vedere quando e come i metodi speciali che seguono vengono invocati.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>la copia di un oggetto
<td><code>copy.copy(x)</code>
<td><a href=http://docs.python.org/3.0/library/copy.html><code>x.<dfn>__copy__</dfn>()</code></a>
<tr><th>
<td>la copia in profondità di un oggetto
<td><code>copy.deepcopy(x)</code>
<td><a href=http://docs.python.org/3.0/library/copy.html><code>x.<dfn>__deepcopy__</dfn>()</code></a>
<tr><th>
<td>ottenere lo stato di un oggetto prima della serializzazione
<td><code>pickle.dump(x, <var>file</var>)</code>
<td><a href=http://docs.python.org/3.0/library/pickle.html#pickle-state><code>x.<dfn>__getstate__</dfn>()</code></a>
<tr><th>
<td>serializzare un oggetto
<td><code>pickle.dump(x, <var>file</var>)</code>
<td><a href=http://docs.python.org/3.0/library/pickle.html#pickling-class-instances><code>x.<dfn>__reduce__</dfn>()</code></a>
<tr><th>
<td>serializzare un oggetto (con un nuovo protocollo di pickling)
<td><code>pickle.dump(x, <var>file</var>, <var>protocol_version</var>)</code>
<td><a href=http://docs.python.org/3.0/library/pickle.html#pickling-class-instances><code>x.<dfn>__reduce_ex__</dfn>(<var>protocol_version</var>)</code></a>
<tr><th>
<td>controllare come un oggetto viene creato durante la deserializzazione
<td><code>x = pickle.load(<var>file</var>)</code>
<td><a href=http://docs.python.org/3.0/library/pickle.html#pickling-class-instances><code>x.<dfn>__getnewargs__</dfn>()</code></a>
<tr><th>
<td>ripristinare lo stato di un oggetto dopo la deserializzazione
<td><code>x = pickle.load(<var>file</var>)</code>
<td><a href=http://docs.python.org/3.0/library/pickle.html#pickle-state><code>x.<dfn>__setstate__</dfn>()</code></a>
</table>

<h2 id=context-managers>Classi che possono essere usate in un blocco <code>with</code></h2>

<p>Python 3 supporta l'istruzione <code>with</code>, che vi permette di accedere alle proprietà e ai metodi di un oggetto senza riferirvi esplicitamente all'oggetto per ogni accesso. Un blocco <code>with</code> definisce un <a href=http://www.python.org/doc/3.0/library/stdtypes.html#typecontextmanager>contesto a tempo di esecuzione</a>; voi &#8220;entrate&#8221; nel contesto quando l'istruzione <code>with</code> viene eseguita, e &#8220;uscite&#8221; dal contesto dopo che l'ultima istruzione nel blocco è stata eseguita.

<p>Qualsiasi classe può essere usata in un blocco <code>with</code>; non è richiesto alcun metodo speciale. L'interprete Python creerà il contesto a tempo di esecuzione e inoltrerà alla vostra classe tutti gli accessi alle proprietà e le chiamate ai metodi. Comunque, se volete che la vostra classe faccia qualcosa di particolare quando entra o esce da un contesto a tempo di esecuzione, potete definire i metodi speciali che seguono.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>fare qualcosa di speciale quando entrate in un blocco <code>with</code>
<td><code>with x:</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__enter__><code>x.<dfn>__enter__</dfn>()</code></a>
<tr><th>
<td>fare qualcosa di speciale quando lasciate un blocco <code>with</code>
<td><code>with x:</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__exit__><code>x.<dfn>__exit__</dfn>()</code></a>
</table>

<p>Ecco come <span class=fixme>[FIXME-xref]</span> funziona l'idioma <code>with <var>file</var></code>.

<p class=fixme>FIXME-xref a una sezione al momento ancora da scrivere sulle annotazioni di funzione

<pre><code># estratto da io.py:
def _checkClosed(self, msg=None):
    """Internal: raise an ValueError if file is closed
    """
    if self.closed:
        raise ValueError("I/O operation on closed file."
                         if msg is None else msg)

def __enter__(self) -> "IOBase":
    """Context management protocol.  Returns self."""
<a>    self._checkClosed()                                <span>&#x2460;</span></a>
<a>    return self                                        <span>&#x2461;</span></a>

def __exit__(self, *args) -> None:
    """Context management protocol.  Calls close()"""
<a>    self.close()                                       <span>&#x2462;</span></a></code></pre>
<ol>
<li>L'oggetto file definisce sia un metodo <code>__enter__()</code> che un metodo <code>__exit__()</code>. Il metodo <code>__enter__()</code> verifica che il file sia aperto: se non lo è, il metodo <code>_checkClosed()</code> solleva un'eccezione.
<li>Il metodo <code>__enter__()</code> dovrebbe quasi sempre restituire <var>self</var> &mdash; questo è l'oggetto che il blocco <code>with</code> userà per inoltrare gli accessi a proprietà e metodi.
<li>All'uscita dal blocco <code>with</code>, l'oggetto file viene automaticamente chiuso. In che modo? Invocando <code>self.close()</code> nel metodo <code>__exit__()</code>.
</ol>

<blockquote class=note>
<p><span>&#x261E;</span>Il metodo <code>__exit__()</code> verrà sempre invocato, anche se un'eccezione viene sollevata all'interno del blocco <code>with</code>. In effetti, nel caso in cui un'eccezione venga sollevata, le informazioni su quella eccezione saranno passate al metodo <code>__exit__()</code>. Si veda la documentazione sui <a href=http://www.python.org/doc/3.0/reference/datamodel.html#with-statement-context-managers>gestori di contesto per l'istruzione with</a> per maggiori dettagli.
</blockquote>

<h2 id=esoterica>Roba veramente esoterica</h2>

<p>Se sapete quello che state facendo, potete ottenere il controllo quasi completo su come le classi sono confrontate, come le proprietà sono definite, e quali tipi di classi sono considerate sottoclassi della vostra classe.

<table>
<tr><th>Note
<th>Voi volete&hellip;
<th>Quindi scrivete&hellip;
<th>E Python invoca&hellip;
<tr><th>
<td>il costruttore di una classe
<td><code>x = MyClass()</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__new__><code>x.<dfn>__new__</dfn>()</code></a>
<tr><th>
<td>il distruttore di una classe
<td><code>del x</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__del__><code>x.<dfn>__del__</dfn>()</code></a>
<tr><th>
<td>che solo uno specifico insieme di proprietà sia definito
<td>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__slots__><code>x.<dfn>__slots__</dfn>()</code></a>
<tr><th>
<td>un valore di hash personalizzato
<td><code>hash(x)</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__hash__><code>x.<dfn>__hash__</dfn>()</code></a>
<tr><th>
<td>ottenere il valore di una proprietà
<td><code>x.color</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__get__><code>type(x).<dfn>__dict__</dfn>['color'].__get__(x, type(x))</code></a>
<tr><th>
<td>impostare il valore di una proprietà
<td><code>x.color = 'PapayaWhip'</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__set__><code>type(x).<dfn>__dict__</dfn>['color'].__set__(x, 'PapayaWhip')</code></a>
<tr><th>
<td>eliminare una proprietà
<td><code>del x.color</code>
<td><a href=http://www.python.org/doc/3.0/reference/datamodel.html#object.__delete__><code>type(x).<dfn>__dict__</dfn>['color'].__del__(x)</code></a>
<tr><th>
<td>controllare se un oggetto è istanza della vostra classe
<td><code>isinstance(x, MyClass)</code>
<td><a href=http://www.python.org/dev/peps/pep-3119/#overloading-isinstance-and-issubclass><code>MyClass.<dfn>__instancecheck__</dfn>(x)</code></a>
<tr><th>
<td>controllare se una classe è sottoclasse di una vostra classe
<td><code>issubclass(C, MyClass)</code>
<td><a href=http://www.python.org/dev/peps/pep-3119/#overloading-isinstance-and-issubclass><code>MyClass.<dfn>__subclasscheck__</dfn>(C)</code></a>
<tr><th>
<td>controllare se una classe è sottoclasse di una vostra classe astratta di base
<td><code>issubclass(C, MyABC)</code>
<td><a href=http://docs.python.org/3.0/library/abc.html#abc.ABCMeta.__subclasshook__><code>MyABC.<dfn>__subclasshook__</dfn>(C)</code></a>
</table>

<p class=nav><a rel=prev href=convertire-codice-verso-python-3-con-2to3.html title="indietro a &#8220;Convertire codice verso Python 3 con 2to3&#8221;"><span>&#x261C;</span></a> <a rel=next class=todo><span>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;9 <a href=informazioni-sul-libro.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=j/jquery.js></script>
<script src=j/dip3.js></script>
