<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Iterators &amp; generators - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
body{counter-reset:h1 5}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#iterators-and-generators>Dive Into Python 3</a> <span>&#8227;</span>
<h1>Iteratori <i class=baa>&amp;</i> generatori</h1>
<blockquote class=q>
<p><span>&#x275D;</span> East is East, and West is West, and never the twain shall meet. <span>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Rudyard_Kipling>Rudyard Kipling</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>L'inglese è una lingua schizofrenica che prende in prestito parole da molte altre lingue. Le operazioni linguistiche più basilari, come prendere un sostantivo singolare e trasformarlo in un sostantivo plurale, sono complicate dal retaggio misto della lingua. Ci sono delle regole, e poi ci sono delle eccezioni alle regole, e infine ci sono delle eccezioni alle eccezioni.
<p>In questo capitolo, imparerete qualcosa sui sostantivi plurali in inglese. E anche su funzioni che restituiscono altre funzioni, sull'uso avanzato delle espressioni regolari, su iteratori e generatori. Ma prima, parliamo di come si costruiscono i sostantivi plurali in inglese. (Se non avete ancora letto <a href=espressioni-regolari.html>il capitolo sulle espressioni regolari</a>, questo potrebbe essere un buon momento per farlo. Questo capitolo presume che abbiate capito le basi delle espressioni regolari, e si inoltrerà velocemente verso i loro usi più avanzati.)
<p>Se siete cresciuti in un paese di lingua madre inglese o avete imparato l'inglese in un ambiente scolastico formale, avrete familiarità con le regole di base:
<ul>
<li>Se una parola finisce con S, X, o Z, aggiungete ES. <i>Bass</i> diventa <i>basses</i>, <i>fax</i> diventa <i>faxes</i>, e <i>waltz</i> diventa <i>waltzes</i>.
<li>Se una parola finisce con una H rumorosa, aggiungete ES; se finisce con una H muta, aggiungete solo S. Che cos'è una H rumorosa? Una H che viene combinata con altre lettere per creare un suono che si possa udire. Quindi <i>coach</i> diventa <i>coaches</i> e <i>rash</i> diventa <i>rashes</i>, perché potete udire i suoni CH e SH quando li pronunciate. Ma <i>cheetah</i> diventa <i>cheetahs</i>, perché la H è muta.
<li>Se una parola finisce con una Y che suona come una I, cambiate la Y in IES; se la Y è combinata con una vocale per suonare come qualcos'altro, aggiungete solo S. Così <i>vacancy</i> diventa <i>vacancies</i>, ma <i>day</i> diventa <i>days</i>.
<li>Se tutto il resto fallisce, aggiungete S e sperate per il meglio.
</ul>
<p>(Lo so, ci sono un sacco di eccezioni. <i>Man</i> diventa <i>men</i> e <i>woman</i> diventa <i>women</i>, ma <i>human</i> diventa <i>humans</i>. <i>Mouse</i> diventa <i>mice</i> e <i>louse</i> diventa <i>lice</i>, ma <i>house</i> diventa <i>houses</i>. <i>Knife</i> diventa <i>knives</i> e <i>wife</i> diventa <i>wives</i>, ma <i>lowlife</i> diventa <i>lowlifes</i>. E non fatemi parlare delle parole che sono il loro stesso plurale, come <i>sheep</i>, <i>deer</i>, e <i>haiku</i>.)
<p>In altre lingue, ovviamente, le cose sono completamente differenti.
<p>Progettiamo una libreria Python che crei automaticamente il plurale dei sostantivi inglesi. Cominceremo giusto con queste quattro regole, ma tenete a mente che dovrete inevitabilmente aggiungerne altre.
<h2 id=i-know>Ci sono, usiamo le espressioni regolari!</h2>
<p>E così state guardando alle parole, il che significa, almeno in inglese, che state guardando a stringhe di caratteri. Avete regole che dicono che dovete trovare combinazioni differenti di caratteri, e poi fare loro cose differenti. Questo sembra un lavoro per le espressioni regolari!
<p class=d>[<a href=esempi/plural1.py>scarica <code>plural1.py</code></a>]
<pre><code>import re

def plural(noun):          
<a>    if re.search('[sxz]$', noun):             <span>&#x2460;</span></a>
<a>        return re.sub('$', 'es', noun)        <span>&#x2461;</span></a>
    elif re.search('[^aeioudgkprt]h$', noun):
        return re.sub('$', 'es', noun)       
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:
        return noun + 's'</code></pre>
<ol>
<li>Questa è una espressione regolare, ma usa una sintassi che non avete visto nel capitolo <a href=espressioni-regolari.html><i>Espressioni regolari</i></a>. Le parentesi quadre significano &#8220;trova una corrispondenza con esattamente uno di questi caratteri.&#8221; Così <code>[sxz]</code> significa &#8220;<code>s</code>, oppure <code>x</code>, oppure <code>z</code>&#8221;, ma solo uno di loro. Il simbolo <code>$</code> dovrebbe risultarvi familiare; corrisponde alla fine della stringa. Combinata, questa espressione regolare verifica che <var>noun</var> finisca con <code>s</code>, <code>x</code>, oppure <code>z</code>.
<li>Questa funzione <code>re.sub()</code> esegue sostituzioni di stringhe basandosi su una espressione regolare.
</ol>

<p>Diamo un'occhiata alle sostituzioni di espressioni regolari in maggior dettaglio.
<pre class=screen>
<samp class=p>>>> </samp><kbd>import re</kbd>
<a><samp class=p>>>> </samp><kbd>re.search('[abc]', 'Mark')</kbd>    <span>&#x2460;</span></a>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<a><samp class=p>>>> </samp><kbd>re.sub('[abc]', 'o', 'Mark')</kbd>  <span>&#x2461;</span></a>
<samp>'Mork'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub('[abc]', 'o', 'rock')</kbd>  <span>&#x2462;</span></a>
<samp>'rook'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub('[abc]', 'o', 'caps')</kbd>  <span>&#x2463;</span></a>
<samp>'oops'</samp></pre>
<ol>
<li>La stringa <code>Mark</code> contiene <code>a</code>, <code>b</code>, oppure <code>c</code>? Sì, contiene <code>a</code>.
<li>OK, adesso trova <code>a</code>, <code>b</code>, oppure <code>c</code>, e sostituiscilo con <code>o</code>. <code>Mark</code> diventa <code>Mork</code>.
<li>La stessa funzione trasforma <code>rock</code> in <code>rook</code>.
<li>Potreste pensare che questo trasformi <code>caps</code> in <code>oaps</code>, ma non lo fa. <code>re.sub()</code> rimpiazza <em>tutte</em> le corrispondenze, non solo la prima. Quindi questa espressione regolare trasforma <code>caps</code> in <code>oops</code>, perché sia la <code>c</code> che la <code>a</code> vengono trasformate in <code>o</code>.
</ol>

<p>E ora, torniamo alla funzione <code>plural()</code>&hellip;

<pre><code>def plural(noun):          
    if re.search('[sxz]$', noun):            
<a>        return re.sub('$', 'es', noun)         <span>&#x2460;</span></a>
<a>    elif re.search('[^aeioudgkprt]h$', noun):  <span>&#x2461;</span></a>
<a>        return re.sub('$', 'es', noun)         <span>&#x2462;</span></a>
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:
        return noun + 's'</code></pre>
<ol>
<li>Qui, state sostituendo la fine della stringa (a cui corrisponde il simbolo <code>$</code>) con la stringa <code>es</code>. In altre parole, state aggiungendo <code>es</code> alla stringa. Potreste ottenere la stessa cosa con la concatenazione di stringhe, per esempio <code>noun + 'es'</code>, ma ho scelto di usare le espressioni regolari per ogni regola, per ragioni che diverranno chiare più tardi in questo capitolo.
<li>Guardate attentamente, questa è un'altra nuova variazione. Il simbolo <code>^</code> come primo carattere tra parentesi quadre significa qualcosa di speciale: negazione. <code>[^abc]</code> significa &#8220;ogni singolo carattere <em>tranne</em> <code>a</code>, <code>b</code>, oppure <code>c</code>&#8221;. Allo stesso modo, <code>[^aeioudgkprt]</code> significa qualsiasi carattere tranne <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>d</code>, <code>g</code>, <code>k</code>, <code>p</code>, <code>r</code>, oppure <code>t</code>. Successivamente, quel carattere deve essere seguito da <code>h</code>, seguito a sua volta dalla fine della stringa. State cercando parole che finiscono in H dove la H può essere udita.
<li>Stesso schema qui: cerca parole che finiscono in Y, dove il carattere che precede la Y <em>non</em> è <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, oppure <code>u</code>. State cercando parole che finiscono con una Y che suona come una I.
</ol>

<p>Diamo una occhiata alle espressioni regolari negate in maggior dettaglio.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import re</kbd>
<a><samp class=p>>>> </samp><kbd>re.search('[^aeiou]y$', 'vacancy')</kbd>  <span>&#x2460;</span></a>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<a><samp class=p>>>> </samp><kbd>re.search('[^aeiou]y$', 'boy')</kbd>      <span>&#x2461;</span></a>
<samp class=p>>>> </samp>
<samp class=p>>>> </samp><kbd>re.search('[^aeiou]y$', 'day')</kbd>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd>re.search('[^aeiou]y$', 'pita')</kbd>     <span>&#x2462;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li><code>vacancy</code> corrisponde a questa espressione regolare, perché finisce con <code>cy</code>, e <code>c</code> non è <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, oppure <code>u</code>.
<li><code>boy</code> non corrisponde, perché finisce con <code>oy</code>, e avete specificatamente detto che il carattere prima della <code>y</code> non può essere <code>o</code>. <code>day</code> non corrisponde, perche termina in <code>ay</code>.
<li><code>pita</code> non corrisponde, perché non termina in <code>y</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>re.sub('y$', 'ies', 'vacancy')</kbd>               <span>&#x2460;</span></a>
<samp>'vacancies'</samp>
<samp class=p>>>> </samp><kbd>re.sub('y$', 'ies', 'agency')</kbd>
<samp>'agencies'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub('([^aeiou])y$', r'\1ies', 'vacancy')</kbd>  <span>&#x2461;</span></a>
<samp>'vacancies'</samp></pre>
<ol>
<li>Questa espressione regolare trasforma <code>vacancy</code> in <code>vacancies</code> e <code>agency</code> in <code>agencies</code>, che è quello che volevate. Notate che trasformerebbe anche <code>boy</code> in <code>boies</code>, ma questo non succederà mai nella funzione perché avete utilizzato <code>re.search()</code> prima per capire se dovreste applicare <code>re.sub()</code>.
<li>Giusto di passaggio, voglio sottolineare che è possibile combinare queste due espressioni regolari (una per scoprire se la regola è applicabile, e l'altra per applicarla effettivamente) in una singola espressione regolare. Questo è come apparirebbe. La maggior parte di essa dovrebbe sembrare familiare: state usando un gruppo da memorizzare, che avete imparato nella sezione <a href=espressioni-regolari.html#phonenumbers>Caso di studio: riconoscere i numeri di telefono</a>. Il gruppo è usato per ricordare il carattere prima della lettera <code>y</code>. Poi, nella stringa di sostituzione, usate una nuova sintassi, <code>\1</code>, che significa &#8220;ehi, hai presente quel primo gruppo che hai memorizzato? mettilo proprio qui.&#8221; In questo caso, avete memorizzato la <code>c</code> prima della <code>y</code>; quando fate la sostituzione, sostituite <code>c</code> al posto di <code>c</code>, e <code>ies</code> al posto di <code>y</code>. (Se avete memorizzato più di un gruppo, potete usare <code>\2</code> e <code>\3</code> e così via.)
</ol>
<p>Le sostituzioni di espressioni regolari sono estremamente potenti, e la sintassi <code>\1</code> le rende ancora più potenti. Ma combinare entrambe le operazioni in un'unica espressione regolare è anche più difficile da leggere, e non corrisponde direttamente al modo in cui avete precedentemente descritto le regole per la pluralizzazione. Avete originariamente esposto le regole come &#8220;se la parola finisce con S, X, o Z, allora aggiungete ES&#8221;. Se guardate questa funzione, ci sono due righe di codice che dicono esattamente &#8220;se la parola finisce con S, X, o Z, allora aggiungete ES&#8221;. Non potete essere più diretti di così. 

<h2 id=a-list-of-functions>Una lista di funzioni</h2>

<p>Ora state per aggiungere un livello di astrazione. Avete cominciato definendo una lista di regole: se accade questo, fai quello, altrimenti vai alla prossima regola. Complichiamo temporaneamente parte del programma in modo da semplificarne un'altra parte.

<p class=d>[<a href=esempi/plural2.py>scarica <code>plural2.py</code></a>]
<pre><code>import re

def match_sxz(noun):
    return re.search('[sxz]$', noun)

def apply_sxz(noun):
    return re.sub('$', 'es', noun)

def match_h(noun):
    return re.search('[^aeioudgkprt]h$', noun)

def apply_h(noun):
    return re.sub('$', 'es', noun)

<a>def match_y(noun):                             <span>&#x2460;</span></a>
    return re.search('[^aeiou]y$', noun)
        
<a>def apply_y(noun):                             <span>&#x2461;</span></a>
    return re.sub('y$', 'ies', noun)

def match_default(noun):
    return True

def apply_default(noun):
    return noun + 's'

<a>rules = ((match_sxz, apply_sxz),               <span>&#x2462;</span></a>
         (match_h, apply_h),
         (match_y, apply_y),
         (match_default, apply_default)
         )

def plural(noun):           
<a>    for matches_rule, apply_rule in rules:       <span>&#x2463;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>Ora, ogni regola di ricerca è contenuta in una propria funzione che restituisce i risultati della chiamata alla funzione <code>re.sub()</code>.
<li>Anche ogni regola di sostituzione è contenuta in una propria funzione che chiama la funzione <code>re.search()</code> per applicare la regola di pluralizzazione appropriata.
<li>Invece di avere una funzione (<code>plural()</code>) che contiene più regole, avete la struttura dati <code>rules</code>, che è una sequenza di coppie di funzioni.
<li>Dato che le regole sono state estratte in una struttura dati separata, la nuova funzione <code>plural()</code> può essere ridotta a poche righe di codice. Usando un ciclo <code>for</code>, potete estrarre regole di ricerca e sostituzione due alla volta (una per il primo tipo, una per il secondo) dalla struttura dati <var>rules</var>. Alla prima iterazione del ciclo <code>for</code>, <var>matches_rule</var> varrà <code>match_sxz</code>, e <var>apply_rule</var> varrà <code>apply_sxz</code>. Alla seconda iterazione (supponendo che ci arriviate), a <var>matches_rule</var> verrà assegnata <code>match_h</code>, e ad <var>apply_rule</var> verrà assegnata <code>apply_h</code>. La funzione garantisce di restituire qualcosa alla fine, perché l'ultima regola di corrispondenza (<code>match_default</code>) restituisce semplicemente <code>True</code>, significando che la regola di applicazione corrispondente (<code>apply_default</code>) sarà sempre applicata.
</ol>

<aside>La variabile &#8220;rules&#8221; è una lista di funzioni.</aside>
<p>La ragione per cui questa tecnica funziona è che <a href=il-vostro-primo-programma-python.html#everythingisanobject>ogni cosa in Python è un oggetto</a>, comprese le funzioni. La struttura dati <var>rules</var> contiene funzioni &mdash; non nomi di funzioni, ma veri e propri oggetti funzione. Quando questi oggetti vengono assegnati nel ciclo <code>for</code>, allora <var>matches_rule</var> e <var>apply_rule</var> diventano vere e proprie funzioni che potete eseguire. La prima iterazione del ciclo <code>for</code> è equivalente a chiamare <code>matches_sxz(noun)</code> e, se viene restituita una corrispondenza, a chiamare anche <code>apply_sxz(noun)</code>.

<p>Se questo livello di astrazione aggiuntivo vi confonde, provate a sviluppare la funzione per vedere l'equivalenza. L'intero ciclo <code>for</code> è equivalente a quanto segue:

<pre><code>
def plural(noun):
    if match_sxz(noun):
        return apply_sxz(noun)
    if match_h(noun):
        return apply_h(noun)
    if match_y(noun):
        return apply_y(noun)
    if match_default(noun):
        return apply_default(noun)</code></pre>

<p>Il beneficio qui è che questa funzione <code>plural()</code> è ora semplificata. Prende una lista di regole, definite da qualche altra parte, e itera attraverso di loro in modo generico.

<ol>
<li>Ottiene una regola di ricerca
<li>Trova una corrispondenza? Allora chiama la regola di applicazione e restituite il risultato.
<li>Nessuna corrispondenza? Ritorna al passo 1.
</ol>

<p>Le regole potrebbero essere definite ovunque, in ogni caso. La funzione <code>plural()</code> non se ne cura.

<p>Ora, l'aggiunta di questo livello di astrazione meritava? Non ancora. Consideriamo cosa bisognerebbe fare per aggiungere una nuova regola alla funzione. Nel primo esempio, questo richiederebbe l'aggiunta di una istruzione <code>if</code> alla funzione <code>plural()</code>. Nel secondo esempio, richiederebbe l'aggiunta di due funzioni, <code>match_foo()</code> e <code>apply_foo()</code>, e l'aggiornamento della lista <var>rules</var> per specificare in quale ordine le nuove funzioni di ricerca e sostituzione dovrebbero essere chiamate rispetto alle altre regole. 

<p>Ma questa è solo una pietra miliare verso la prossima sezione. Proseguiamo&hellip;

<h2 id=a-list-of-patterns>Una lista di pattern</h2>

<p>Definire separatamente una funzione con un proprio nome per ogni regola di ricerca e sostituzione non è realmente necessario. Non le chiamate mai direttamente; le aggiungete alla lista <var>rules</var> e le chiamate attraverso di essa. In più, ogni funzione segue uno di due schemi. Tutte le funzioni di ricerca chiamano <code>re.search()</code>, e tutte le funzioni di sostituzione chiamano <code>re.sub()</code>. Fattorizziamo gli schemi in modo che definire nuove regole diventi più semplice.

<p class=d>[<a href=esempi/plural3.py>scarica <code>plural3.py</code></a>]
<pre><code>import re

def build_match_and_apply_functions(pattern, search, replace):
<a>    def matches_rule(word):                                     <span>&#x2460;</span></a>
        return re.search(pattern, word)
<a>    def apply_rule(word):                                       <span>&#x2461;</span></a>
        return re.sub(search, replace, word)
<a>    return (matches_rule, apply_rule)                           <span>&#x2462;</span></a></code></pre>
<ol>
<li><code>build_match_and_apply_functions()</code> è una funzione che costruisce dinamicamente altre funzioni. Accetta in ingresso <var>pattern</var>, <var>search</var> e <var>replace</var>, poi definisce una funzione <code>matches_rule()</code> che chiama <code>re.search()</code> con il <var>pattern</var> che è stato passato alla funzione <code>build_match_and_apply_functions()</code>, e la <var>word</var> che è stata passata alla funzione <code>matches_rule()</code> che state costruendo. Whoa.
<li>La costruzione della funzione di sostituzione viene fatta allo stesso modo. La funzione di sostituzione è una funzione che accetta un parametro, e chiama <code>re.sub()</code> con i parametri <var>search</var> e <var>replace</var> che sono stati passati alla funzione <code>build_match_and_apply_functions()</code>, e la <var>word</var> che è stata passata alla funzione <code>apply_rule()</code> che state costruendo. Questa tecnica di usare i valori di parametri esterni all'interno di una funzione dinamica è chiamata <em>chiusura</em>. State essenzialmente definendo delle costanti nell'ambito della funzione di sostituzione che state costruendo; quest'ultima accetta un parametro (<var>word</var>), ma poi agisce su quello più due altri valori (<var>search</var> e <var>replace</var>) che sono stati impostati quando avete definito la funzione di sostituzione.
<li>Infine, la funzione <code>build_match_and_apply_functions()</code> restituisce una tupla di due valori: le due funzioni che avete appena creato. Le costanti definite in quelle funzioni (<var>pattern</var> nell'ambito di <var>matchFunction</var>, e <var>search</var> e <var>replace</var> nell'ambito di <var>applyFunction</var>) mantengono il loro valore in quelle funzioni persino dopo che le avete restituite da <code>build_match_and_apply_functions()</code>. Questo è incredibilmente figo.
</ol>

<p>Se questo risulta incredibilmente confuso (e dovrebbe, è roba strana), potrebbe diventare più chiaro nel momento in cui vedete come si usa.

<pre><code>
<a>patterns = \                                                        <span>&#x2460;</span></a>
  [
    ['[sxz]$',           '$',  'es'],
    ['[^aeioudgkprt]h$', '$',  'es'],
    ['(qu|[^aeiou])y$',  'y$', 'ies'],
    ['$',                '$',  's']
  ]
<a>rules = [build_match_and_apply_functions(pattern, search, replace)  <span>&#x2461;</span></a>
         for (pattern, search, replace) in patterns]</code></pre>
<ol>
<li>Le nostre regole di pluralizzazione sono ora definite come una lista di liste di stringhe (non funzioni). La prima stringa in ogni gruppo è l'espressione regolare che usereste in <code>re.search()</code> per vedere se c'è una corrispondenza con questa regola. La seconda e la terza stringa di ogni gruppo sono le espressioni di ricerca e sostituzione che usereste in <code>re.sub()</code> per applicare effettivamente la regola e trasformare un sostantivo nel suo plurale.
<li>Questa riga è magia. Prende la lista di stringhe in <var>patterns</var> e la trasforma in una lista di funzioni. Come? Tracciando una corrispondenza tra le stringhe e la funzione <code>build_match_and_apply_functions()</code>, che accetta appunto tre stringhe come parametri di ingresso e restituisce una tupla di due funzioni in uscita. Questo significa che <var>rules</var> finisce per essere esattamente ciò che era nell'esempio precedente: una lista di tuple, dove ogni tupla è una coppia di funzioni, dove la prima funzione è la funzione di ricerca che chiama <code>re.search()</code>, e la seconda funzione è la funzione di sostituzione che chiama <code>re.sub()</code>.
</ol>

<p>Per completare questa versione del programma ecco il punto di entrata principale, la funzione <code>plural()</code>.

<pre><code>def plural(noun):
<a>    for matches_rule, apply_rule in rules:  <span>&#x2460;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>Visto che la lista <var>rules</var> è la stessa dell'esempio precedente (davvero, lo è), non dovrebbe sorprendervi che la funzione <code>plural()</code> non sia cambiata per niente. Rimane completamente generica; prende una lista di funzioni di regole e le chiama in ordine. Non si preoccupa di come le regole sono definite. Nell'esempio precedente, le regole erano definite come funzioni separate con un proprio nome. Ora sono costruite dinamicamente mappando l'uscita della funzione <code>build_match_and_apply_functions()</code> su una lista di stringhe. Non ha importanza; la funzione <code>plural()</code> continua a lavorare nello stesso modo.
</ol>

<h2 id=a-file-of-patterns>Un file di pattern</h2>

<p>Avete fattorizzato tutto il codice duplicato e aggiunto abbastanza astrazioni in modo che le regole di pluralizzazione siano definite in una lista di stringhe. Il passo logico successivo consiste nel prendere queste stringhe e metterle in un file separato, dove possano essere mantenute separatamente dal codice che le usa. 

<p>Prima di tutto, creiamo un file di testo che contiene le regole che volete. Nessuna struttura dati elaborata, solo stringhe separate da spazi bianchi su tre colonne. Chiamiamo questo file <code>plural4-rules.txt</code>.

<p class=d>[<a href=esempi/plural4-rules.txt>scarica <code>plural4-rules.txt</code></a>]
<pre><code>[sxz]$               $    es
[^aeioudgkprt]h$     $    es
[^aeiou]y$          y$    ies
$                    $    s</code></pre>

<p>Ora vediamo come potete usare questo file di regole.

<p class=fixme>[FIXME: now that this chapter comes before the I/O chapter, need to at least mention what open() does]
<p class=d>[<a href=esempi/plural4.py>scarica <code>plural4.py</code></a>]
<pre><code>import re

<a>def build_match_and_apply_functions(pattern, search, replace):  <span>&#x2460;</span></a>
    def matches_rule(word):
        return re.search(pattern, word)
    def apply_rule(word):
        return re.sub(search, replace, word)
    return (matches_rule, apply_rule)

rules = []
<a>pattern_file = open('plural4-rules.txt')                        <span>&#x2461;</span></a>
try:
<a>    for line in pattern_file:                                   <span>&#x2462;</span></a>
<a>        pattern, search, replace = line.split(None, 3)          <span>&#x2463;</span></a>
<a>        rules.append(build_match_and_apply_functions(           <span>&#x2464;</span></a>
                pattern, search, replace))
finally:
<a>    pattern_file.close()                                        <span>&#x2465;</span></a></code></pre>
<ol>
<li>La funzione <code>build_match_and_apply_functions()</code> non è cambiata. State ancora usando le chiusure per costruire dinamicamente due funzioni che usano variabili definite nella funzione esterna.
<li>Aprite il file che contiene i pattern.
<li>Leggete il file una riga alla volta, usando l'idioma <code>for line in &lt;fileobject&gt;</code>.
<li>Ogni riga nel file in realtà contiene tre valori, ma essi sono separati da spazi bianchi (che siano tabulazioni o spazi non fa alcuna differenza). Per separarli, usate il metodo <code>split()</code> delle stringhe. Il primo argomento del metodo <code>split()</code> è <code>None</code>, il che significa &#8220;separa sulla base di qualsiasi spazio bianco (che siano tabulazioni o spazi non fa alcuna differenza).&#8221; Il secondo argomento è <code>3</code>, che significa &#8220;separa sulla base di spazi bianchi per 3 volte, poi scarta il resto della riga.&#8221; Una riga come <code>[sxz]$ $ es</code> verrà spezzata nella tupla <code>('[sxz]$', '$', 'es')</code>, il che significa che <var>pattern</var> avrà il valore <code>'[sxz]$'</code>, <var>search</var> avrà il valore <code>'$'</code>, e <var>replace</var> avrà il valore <code>'es'</code>. C'è molta potenza in una piccola riga di codice.
<li>Usate un blocco <code>try..finally</code> per assicurarvi di chiudere l'oggetto file.
</ol>

<p>In questo caso il miglioramento è che avete completamente separato le regole di pluralizzazione in un file esterno, in modo che possa essere mantenuto separatamente dal codice che lo utilizza. Il codice è codice, i dati sono dati, e la vita è bella.

<h2 id=generators>Generatori</h2>

<p>Ora siete pronti per imparare i generatori.

<p class=d>[<a href=esempi/plural5.py>scarica <code>plural5.py</code></a>]
<pre><code>def rules():
    for line in open('plural5-rules.txt'):
        pattern, search, replace = line.split(None, 3)
        yield build_match_and_apply_functions(pattern, search, replace)

def plural(noun):
    for matches_rule, apply_rule in rules():
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>

<p>Come cavolo funziona <em>questo</em>? Diamo prima un'occhiata dalla shell interattiva.

<pre class=screen>
<samp class=p>>>> </samp><kbd>def make_counter(x):</kbd>
<samp class=p>... </samp><kbd>print 'entering make_counter'</kbd>
<samp class=p>... </samp><kbd>while True:</kbd>
<a><samp class=p>... </samp><kbd>    yield x</kbd>                    <span>&#x2460;</span></a>
<samp class=p>... </samp><kbd>    print 'incrementing x'</kbd>
<samp class=p>... </samp><kbd>    x = x + 1</kbd>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd>counter = make_counter(2)</kbd>      <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>counter</kbd>                        <span>&#x2462;</span></a>
&lt;generator object at 0x001C9C10>
<a><samp class=p>>>> </samp><kbd>next(counter)</kbd>                  <span>&#x2463;</span></a>
<samp>entering make_counter
2</samp>
<a><samp class=p>>>> </samp><kbd>next(counter)</kbd>                  <span>&#x2464;</span></a>
<samp>incrementing x
3</samp>
<a><samp class=p>>>> </samp><kbd>next(counter)</kbd>                  <span>&#x2465;</span></a>
<samp>incrementing x
4</samp></pre>
<ol>
<li>La presenza della parola chiave <code>yield</code> in <code>make_counter()</code> significa che questa non è una normale funzione. &Egrave; un tipo speciale di funzione che genera valori uno alla volta. Potete pensarla come una funzione riesumabile. Chiamarla restituirà un <i>generatore</i> che può essere usato per generare valori successivi di <var>x</var>.
<li>Per creare un'istanza del generatore <code>make_counter()</code>, vi basta invocarlo come ogni altra funzione. Notate che questo non esegue effettivamente il codice della funzione. Potete rendervene conto perché la prima riga della funzione <code>make_counter()</code> chiama <code>print()</code>, ma nulla è stato ancora stampato.
<li>La funzione <code>make_counter()</code> restituisce un oggetto generatore.
<li>La funzione <code>next()</code> accetta un generatore e restituisce il suo valore successivo. La prima volta che chiamate <code>next()</code> con il generatore <var>counter</var>, esegue il codice in <code>make_counter()</code> fino al prima istruzione <code>yield</code>, poi restituisce il valore che è stato generato. In questo caso, quel valore sarà <code>2</code>, perché avete originariamente creato il generatore invocando <code>make_counter(2)</code>.
<li>Chiamare ripetutamente <code>next()</code> con lo stesso oggetto generatore riprende l'esecuzione esattamente da dove aveva lasciato e continua fino a quando non arriva alla successiva istruzione <code>yield</code>. Tutte le variabili, lo stato locale, <i class=baa>&amp;</i>c. sono salvate da <code>yield</code> e ripristinate da <code>next()</code>. La successiva riga di codice che attende di essere eseguita chiama <code>print()</code>, che stampa <samp>incrementing x</samp>. Dopo di che, viene eseguita l'istruzione <code>x = x + 1</code>. Poi si passa di nuovo attraverso il ciclo <code>while</code>, e la prima cosa che si esegue è l'istruzione <code>yield x</code>, che salva lo stato di tutto e restituisce il valore corrente di <var>x</var> (ora <code>3</code>).
<li>La seconda volta che chiamate <code>next(counter)</code>, fate di nuovo tutte le stesse cose, ma questa volta <var>x</var> vale <code>4</code>
</ol>

<p>Dato che <code>make_counter()</code> contiene un ciclo infinito, potreste teoricamente fare questo per sempre, e il generatore continuerebbe semplicemente a incrementare <var>x</var> e sputare fuori valori. Ma guardiamo invece a usi più produttivi dei generatori.

<h3 id=a-fibonacci-generator>Un generatore di Fibonacci</h3>

<p class=d>[<a href=esempi/fibonacci.py>scarica <code>fibonacci.py</code></a>]
<pre><code>def fib(max):
<a>    a, b = 0, 1          <span>&#x2460;</span></a>
    while a &lt; max:
<a>        yield a          <span>&#x2461;</span></a>
<a>        a, b = b, a + b  <span>&#x2462;</span></a></code></pre>
<ol>
<li>La sequenza di Fibonacci è una sequenza numerica dove ogni numero è la somma dei due numeri che lo precedono. Comincia con <code>0</code> e <code>1</code>, si incrementa lentamente all'inizio, e poi sempre più rapidamente. Per cominciare la sequenza, avete bisogno di due variabili: <var>a</var> inizia a <code>0</code>, e <var>b</var> inizia a <code>1</code>.
<li><var>a</var> è il numero corrente nella sequenza, quindi <span class=wtf>yield it</span>.
<li><var>b</var> è il numero successivo nella sequenza, quindi assegnatelo ad <var>a</var>, ma calcolate anche il prossimo valore (<code>a + b</code>) e assegnatelo a <var>b</var> per usarlo più tardi. Notate che questo accade in parallelo; se <var>a</var> è <code>3</code> e <var>b</var> è <code>5</code>, allora <code>a, b = b, a + b</code> imposterà <var>a</var> a <code>5</code> (il valore precedente di <var>b</var>) e <var>b</var> a <code>8</code> (la somma dei valori precedenti di <var>a</var> e <var>b</var>).
</ol>

<aside>&#8220;yield&#8221; mette in pausa una funzione. &#8220;next()&#8221; la riesuma da dove aveva lasciato.</aside>

<p>Quindi avete una funzione che sputa fuori valori successivi dei numeri di Fibonacci. Certo, potreste farlo con la ricorsione, ma questo modo è più facile da leggere. In più, funziona bene con i cicli <code>for</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd>from fibonacci import fib</kbd>
<a><samp class=p>>>> </samp><kbd>for n in fib(1000):</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd>    print(n, end=' ')</kbd>    <span>&#x2461;</span></a>
<samp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp></pre>
<ol>
<li>Potete usare un generatore come <code>fib()</code> direttamente in un ciclo <code>for</code>. Il ciclo <code>for</code> chiamerà automaticamente la funzione <code>next()</code> per ottenere valori dal generatore <code>fib()</code> e assegnarli alla variabile di indice del ciclo <code>for</code> (<var>n</var>).
<li>A ogni iterazione nel ciclo <code>for</code>, <var>n</var> ottiene un nuovo valore dalla istruzione <code>yield</code> in <code>fib()</code>, e tutto quello che dovete fare è stamparlo. Una volta che <code>fib()</code> ha finito i numeri (<var>a</var> diventa più grande di <var>max</var>, che nel nostro caso è <code>1000</code>), allora il ciclo <code>for</code> esce gentilmente.
</ol>

<h3 id=a-plural-rule-generator>Un generatore di regole per i sostantivi plurali</h3>

<p>Torniamo indietro a <code>plural5.py</code> e vediamo se questa versione della funzione <code>plural()</code> funziona.

<pre><code>def rules():
<a>    for line in open('plural5-rules.txt'):                               <span>&#x2460;</span></a>
<a>        pattern, search, replace = line.split(None, 3)                   <span>&#x2461;</span></a>
<a>        yield build_match_and_apply_functions(pattern, search, replace)  <span>&#x2462;</span></a>

def plural(noun):
<a>    for matches_rule, apply_rule in rules():                             <span>&#x2463;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>Come avete visto, <code>for line in open(...)</code> è un idioma comune per leggere da un file una riga alla volta. Ma qui c'è qualcosa che potreste non sapere: la ragione per cui questo idioma funziona è perché <em><code>open()</code> in realtà restituisce un generatore, e invocare <code>next()</code> su questo generatore restituisce la riga successiva del file.</em>
<li>Nessuna magia qui. Ricordate che le righe del file di regole hanno tre valori separati da spazi bianchi, quindi usate <code>line.split(None, 3)</code> per ottenere le tre &#8220;colonne&#8221; e assegnarle a tre variabili locali.
<li><em>E poi utilizzate <code>yield</code>.</em> Che cosa producete? Due funzioni, costruite dinamicamente con la vostra vecchia amica, <code>build_match_and_apply_functions()</code>, che è identica all'esempio precedente. In altre parole, <code>rules()</code> è un generatore che produce funzioni di ricerca e sostituzione <em>su richiesta</em>.
<li>Dato che <code>rules()</code> è un generatore, potete usarlo direttamente in un ciclo <code>for</code>. Alla prima iterazione nel ciclo <code>for</code>, chiamerete la funzione <code>rules()</code>, che aprirà il file dei pattern, leggerà la prima riga, costruirà dinamicamente una funzione di ricerca e una funzione di sostituzione usando i pattern di quella riga, e produrrà in uscita le funzioni costruite dinamicamente. Nella seconda iterazione del ciclo <code>for</code>, <code>rules()</code> riprenderà ad eseguire esattamente da dove l'avevate lasciata (cioè nel mezzo del ciclo <code>for line in file(...)</code>). La prima cosa che farà è leggere la riga successiva del file (che è ancora aperto), poi costruirà dinamicamente un'altra coppia di funzioni di ricerca e sostituzione basate sui pattern di quella riga, e infine produrrà in uscita le due funzioni.
</ol>

<p>Che cosa avete guadagnato rispetto alla fase 4? Tempo di inizializzazione. Nella fase 4, quando importavate il modulo <code>plural4</code>, il file dei pattern veniva interamente letto e una lista di tutte le possibili regole veniva costruita prima ancora che poteste anche solo pensare di chiamare la funzione <code>plural()</code>. Con i generatori, potete fare ogni cosa in maniera ritardata: leggete la prima regola e create le corrispettive funzioni e le provate, e se funziona non dovete nemmeno leggere il resto del file o creare nessun'altra funzione.

<p>Che cosa avete perso? Prestazioni! Ogni volta che chiamate la funzione <code>plural()</code>, il generatore <code>rules()</code> ricomincia dall'inizio &mdash; il che vuol dire riaprire il file dei pattern e leggerlo dall'inizio, una riga alla volta.

<p>E se poteste avere il meglio dei due mondi? Minimo costo di inizializzazione (non eseguire alcun codice alla chiamata di <code>import</code>), <em>e</em> massime prestazioni (non costuire sempre le stesse funzioni ogni volta). Oh, e volete ancora mantenere le regole in un file separato (perché il codice è codice, e i dati sono dati), fino a quando non dovete leggere la stessa riga due volte.

<h2 id=iterators>Iteratori</h2>

<p>In verità, i generatori sono un caso speciale di <i>iteratori</i>. Una funzione che produce valori tramite <code>yield</code> è un modo carino e compatto di costruire un iteratore senza costruire un iteratore. Lasciate che vi mostri cosa intendo dire con questo.

<h3 id=a-fibonacci-iterator>Un iteratore di Fibonacci</h3>

<p>Ricordate il <a href=a-fibonacci-generator>generatore di Fibonacci</a>? Qui lo trovate reimplementato da zero sotto forma di iteratore:

<p class=d>[<a href=esempio/fibonacci2.py>scarica <code>fibonacci2.py</code></a>]
<pre><code><a>class fib:                                        <span>&#x2460;</span></a>
<a>    def __init__(self, max):                      <span>&#x2461;</span></a>
        self.max = max

<a>    def __iter__(self):                           <span>&#x2462;</span></a>
        self.a, self.b = 0, 1
        return self

<a>    def __next__(self):                           <span>&#x2463;</span></a>
        fib = self.a
        if fib > self.max:
<a>            raise StopIteration                   <span>&#x2464;</span></a>
        self.a, self.b = self.b, self.a + self.b
<a>        return fib                                <span>&#x2465;</span></a></code></pre>
<ol>
<li>Per costruire un iteratore partendo da zero, <code>fib</code> deve essere una classe, non una funzione.
<li>&#8220;Chiamare&#8221; <code>fib(max)</code> vuol dire in realtà creare una istanza di questa classe e chiamare il suo metodo <code>__init__()</code> con <var>max</var>. Il metodo <code>__init__()</code> salva il valore massimo come una variabile di istanza in modo che altri metodi possano usarlo più tardi.
<li>Il metodo <code>__iter__()</code> viene chiamato ogni volta che qualcuno chiama <code>iter(fib)</code>. (Come vedrete in un minuto, un ciclo <code>for</code> chiama questo metodo automaticamente, ma potete chiamarlo anche voi manualmente.) Dopo aver eseguito l'inizializzazione all'inizio della iterazione (in questo caso, impostando i valori di <code>self.a</code> e <code>self.b</code>, i nostri due contatori), il metodo <code>__iter__()</code> può restituire qualsiasi oggetto che implementi un metodo <code>__next__()</code>. In questo caso (e nella maggior parte dei casi), <code>__iter__()</code> restituisce semplicemente <code>self</code>, dato che questa classe implementa il proprio metodo <code>__next__()</code>.
<li>Il metodo <code>__next__()</code> viene chiamato ogni volta che qualcuno chiama <code>next()</code> su un iteratore di una istanza di una classe. Questo avrà più senso fra un minuto.
<li>Quando il metodo <code>__next__()</code> solleva una eccezione di tipo <code>StopIteration</code>, questo segnala al chiamante che l'iterazione è terminata; non ci sono più valori disponibili. Se il chiamante è un ciclo <code>for</code>, noterà questa eccezione di tipo <code>StopIteration</code> e uscirà gentilmente dal ciclo. (In altre parole, ingoierà l'eccezione.) Questo piccolo tocco di magia è in realtà la chiave per usare gli iteratori nei cicli <code>for</code>.
<li>Per sputare fuori il valore successivo, il metodo <code>__next__()</code> di un iteratore semplicemente restituisce il valore tramite l'istruzione <code>return</code>. Qui <code>yield</code> non viene usato; quello è zucchero sintattico che si applica solo quando state usando i generatori. Qui invece state creando il vostro iteratore da zero; usate quindi <code>return</code>.
</ol>

<p>Non siete ancora completamente confusi? Eccellente. Vediamo come invocare questo iteratore:</p>

<pre class=screen>
<samp class=p>>>> </samp><kbd>from fibonacci2 import fib</kbd>
<samp class=p>>>> </samp><kbd>for n in fib(1000):</kbd>
<samp class=p>... </samp><kbd>    print(n, end=' ')</kbd>
<samp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp></pre>

<p>Ehi, è esattamente lo stesso! Identico byte per byte a come chiamavate il generatore di Fibonacci! Ma com'è possibile?

<p>Vi avevo detto che c'è un poco di magia coinvolta nei cicli <code>for</code>. Ecco cosa succede:

<ul>
<li>Il ciclo <code>for</code> invoca <code>fib(1000)</code>, come mostrato. Questo restituisce una istanza della classe <code>fib</code>. Chiamiamo questa istanza <var>fib_inst</var>.
<li>Segretamente, e piuttosto ingegnosamente, il ciclo <code>for</code> chiama <code>iter(fib_inst)</code>, che restituisce un oggetto iteratore. Chiamiamo questo oggetto <var>fib_iter</var>. In questo caso, <var>fib_iter</var> == <var>fib_inst</var>, perché il metodo <code>__iter__()</code> restituisce <code>self</code>, anche se il ciclo <code>for</code> non lo sa (o non se ne cura).
<li>Per &#8220;ciclare attraverso&#8221; l'iteratore, il ciclo <code>for</code> chiama <code>next(fib_iter)</code>, che chiama il metodo <code>__next__()</code> sull'oggetto <var>fib_iter</var>, che calcola il successivo numero di Fibonacci e restituisce un valore. Il ciclo <code>for</code> prende questo valore e lo assegna a <var>n</var>, poi esegue il corpo del ciclo <code>for</code> per quel valore di <var>n</var>.
<li>Come fa il ciclo <code>for</code> a sapere quando fermarsi? Sono contento che lo abbiate chiesto! Quando <code>next(fib_iter)</code> solleva una eccezione di tipo <code>StopIteration</code>, il ciclo <code>for</code> ingoierà l'eccezione e uscirà gentilmente. (Ogni altra eccezione vi passerà attraverso e verrà sollevata come al solito.) E dove avete visto una eccezione di tipo <code>StopIteration</code>? Nel metodo <code>__next__()</code>, naturalmente!
</ul>

<h3 id=a-plural-rule-iterator>Un iteratore di regole per i sostantivi plurali</h3>

<aside>iter(f) chiama f.__iter__<br>next(f) chiama f.__next__</aside>
<p>Ora è il momento del gran finale.

<p class=d>[<a href=esempi/plural6.py>scarica <code>plural6.py</code></a>]
<pre><code>class LazyRules:
    def __init__(self):
        self.pattern_file = open('plural6-rules.txt')
        self.cache = []

    def __iter__(self):
        self.cache_index = 0
        return self

    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
            return self.cache[self.cache_index - 1]

        if self.pattern_file.closed:
            raise StopIteration

        line = self.pattern_file.readline()
        if not line:
            self.pattern_file.close()
            raise StopIteration

        pattern, search, replace = line.split(None, 3)
        funcs = build_match_and_apply_functions(
            pattern, search, replace)
        self.cache.append(funcs)
        return funcs

rules = LazyRules()</code></pre>

<p>Così questa è una classe che implementa <code>__iter__()</code> e <code>__next__()</code>, e perciò può essere usata come un iteratore. Dunque, ne istanziate la classe e assegnate l'istanza a <var>rules</var>. Questo accade solo una volta, al momento di importare il modulo.

<p>Analizziamo la classe un pezzo alla volta.

<pre><code>class LazyRules:
<a>    def __init__(self):                                <span>&#x2460;</span></a>
<a>        self.pattern_file = open('plural6-rules.txt')  <span>&#x2462;</span></a>
<a>        self.cache = []                                <span>&#x2461;</span></a></code></pre>
<ol>
<li>Il metodo <code>__init__()</code> viene chiamato una volta sola, quando istanziate la classe e ne assegnate l'istanza a <var>rules</var>.
<li>Dato che viene chiamato una volta sola, questo metodo è il posto perfetto dove aprire il file dei pattern. Lo leggerete più tardi; non ha senso fare più di quello che dovete assolutamente fare fino a quando non diviene assolutamente necessario farlo!
<li>In più, questo metodo è un buon posto anche per inizializzare la cache, che userete più tardi durante la lettura dei pattern dal file.
</ol>

<pre><code><a>    def __iter__(self):       <span>&#x2460;</span></a>
<a>        self.cache_index = 0  <span>&#x2461;</span></a>
<a>        return self           <span>&#x2462;</span></a>
</code></pre>
<ol>
<li>Il metodo <code>__iter__()</code> verrà chiamato ogni volta che qualcuno &mdash; diciamo, un ciclo <code>for</code> &mdash; chiama <code>iter(rules)</code>.
<li>Questo metodo è il posto dove resettare i contatori che useremo per recuperare gli oggetti dalla cache (che ancora non abbiamo popolato &mdash; pazienza, cavalletta).
<li>Infine, il metodo <code>__iter__()</code> restituisce <code>self</code>, che segnala che questa classe si prenderà cura di restituire i propri valori attraverso l'iterazione.
</ol>

<pre><code><a>    def __next__(self):                                 <span>&#x2460;</span></a>
        .
        .
        .
        pattern, search, replace = line.split(None, 3)
<a>        funcs = build_match_and_apply_functions(        <span>&#x2461;</span></a>
            pattern, search, replace)
<a>        self.cache.append(funcs)                        <span>&#x2462;</span></a>
        return funcs</code></pre>
<ol>
<li>Il metodo <code>__next__()</code> viene chiamato ogni volta che qualcuno &mdash; diciamo, un ciclo <code>for</code> &mdash; chiama <code>next(rules)</code>. Questo metodo si capisce meglio se cominciamo dalla fine e lo leggiamo all'indietro. Quindi, facciamolo.
<li>L'ultima parte di questa funzione dovrebbe sembrare familiare, quantomeno. La funzione <code>build_match_and_apply_functions()</code> non è cambiata; è la stessa che è sempre stata. <em>Ogni riga del file di pattern verrà letta esattamente una volta, il più tardi possibile.</em>
<li>L'unica differenza è che, prima di restituire le funzioni di ricerca e sostituzione (che sono memorizzate nella tupla <var>funcs</var>), dobbiamo salvarle in <code>self.cache</code>. <em>Ogni funzione di ricerca e sostituzione verrà costruita esattamente una volta, il più tardi possibile, e poi salvata in cache.</em>
</ol>

<p>Muovendosi all'indietro&hellip;

<pre><code>    def __next__(self):
        .
        .
        .
<a>        line = self.pattern_file.readline()  <span>&#x2460;</span></a>
<a>        if not line:                         <span>&#x2461;</span></a>
            self.pattern_file.close()
<a>            raise StopIteration              <span>&#x2462;</span></a>
        .
        .
        .</code></pre>
<ol>
<li>Qui utilizziamo i file in maniera astuta. Il metodo <code>readline()</code> (notate: singolare, non il plurale <code>readlines()</code>) legge esattamente una riga da un file aperto. Nello specifico, la riga successiva. (<em>Anche gli oggetti file sono iteratori! <span class=wtf>It&#8217;s iterators all the way down&hellip;</span></em>)
<li>Se c'è una riga da leggere per <code>readline()</code>, <var>line</var> non sarà una stringa vuota. Anche se il file contenesse una riga vuota, <var>line</var> finirebbe per essere la stringa <code>'\n'</code> contenente il carattere di ritorno a capo. Quando <var>line</var> è davvero la stringa vuota, significa che non ci sono più righe da leggere nel file.
<li>Quando raggiungiamo la fine del file, dobbiamo chiudere il file e lanciare la magica eccezione di tipo <code>StopIteration</code>. Ricordate, siamo arrivati a questo punto perché avevamo bisogno di una funzione di ricerca e sostituzione per la regola successiva. Tale regola proviene dalla riga successiva nel file&hellip; ma non c'è nessun'altra riga! Di conseguenza, non abbiamo alcun valore da restituire. L'iterazione è finita. (<span>&#x266B;</span> The party&#8217;s over&hellip; <span>&#x266B;</span>)
</ol>

<p>Spostandoci all'indietro fino all'inizio del metodo <code>__next__()</code>&hellip;

<pre><code>    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
<a>            return self.cache[self.cache_index - 1]     <span>&#x2460;</span></a>

        if self.pattern_file.closed:
<a>            raise StopIteration                         <span>&#x2461;</span></a>
        .
        .
        .</code></pre>
<ol>
<li><code>self.cache</code> sarà una lista di funzioni per cercare corrispondenze con le singole regole e poi sostituirle. (Almeno <em>questo</em> dovrebbe suonarvi familiare!) <code>self.cache_index</code> tiene traccia di quale elemento in cache dovremo restituire successivamente. Se non abbiamo ancora esaurito la cache (cioè se la lunghezza di <code>self.cache</code> è maggiore di <code>self.cache_index</code>), allora abbiamo una <self class=wtf>hit</self> nella cache! Urrà! Possiamo restituire le funzioni di ricerca e sostituzione dalla cache invece che costruirle da zero.
<li>D'altra parte, se non otteniamo una <self class=wtf>hit</self> dalla cache, <em>e</em> l'oggetto file è stato chiuso (cosa che potrebbe accadere, più in giù nel metodo, come avete visto nel precedente frammento di codice), allora non c'è nient'altro che possiamo fare. Se il file è chiuso, vuol dire che lo abbiamo esaurito &mdash; abbiamo già letto ogni riga dal file dei pattern, e abbiamo già costruito e memorizzato le funzioni di ricerca e sostituzione per ogni pattern. Il file è esaurito; la cache è esaurita; anche io sono esaurito. Aspettate, cosa? Tenete duro, abbiamo quasi finito.
</ol>

<p>Mettendo insieme tutti i pezzi, ecco cosa succede quando:

<ul>
<li>Quando il modulo viene importato, viene creata una singola istanza della classe <code>LazyRules</code>, chiamata <var>rules</var>, che apre il file dei pattern ma non lo legge.
<li>Quando si richiedono a <var>rules</var> le prime funzioni di ricerca e sostituzione, l'istanza controlla la propria cache ma scopre che è vuota. Quindi legge una singola riga dal file dei pattern, costruisce le funzioni di ricerca e sostituzione per quei pattern, e le memorizza nella cache.
<li>Diciamo che, per amor di discussione, proprio la prima regola trova una corrispondenza. Se è così, nessuna nuova coppia di funzioni viene costruita, e nessun'altra riga viene letta dal file.
<li>In più, sempre per amor di discussione, supponiamo che il chiamante invochi la funzione <code>plural()</code> <em>di nuovo</em> per costruire il plurale di una parola diversa. Il ciclo <code>for</code> nella funzione <code>plural()</code> chiamerà <code>iter(rules)</code>, che azzererà l'indice della cache ma non l'oggetto file aperto.
<li>Alla prima iterazione, il ciclo <code>for</code> chiederà un valore a <var>rules</var>, che invocherà il suo metodo <code>__next__()</code>. Questa volta, però, la cache è caricata con una singola coppia di funzioni di ricerca e sostituzione, corrispondenti ai pattern nella prima riga del file dei pattern. Visto che la coppia è stata costruita e memorizzata nel tentativo di creare il plurale della parola precedente, viene recuperata dalla cache. L'indice della cache viene incrementato, e il file aperto non viene mai toccato.
<li>Diciamo ora che, per amor di discussione, la prima regola questa volta non genera alcuna corrispondenza. Quindi il ciclo <code>for</code> ricomincia da capo e chiede un altro valore a <var>rules</var>. Questi invoca il metodo <code>__next__()</code> una seconda volta. Questa volta, la cache è esaurita &mdash; conteneva un solo elemento, e noi ne stiamo chiedendo un secondo &mdash; quindi il metodo <code>__next__()</code> prosegue. Legge un'altra riga dal file aperto, costruisce le funzioni di ricerca e sostituzione dai pattern, e le memorizza in cache.
<li>Questo processo di lettura-costruzione-memorizzazione continuerà fino a quando le regole lette dal file dei pattern non corrisponderanno alla parola di cui stiamo cercando di costruire il plurale. Se troviamo una regola che corrisponde prima della fine del file, semplicemente la usiamo e ci fermiamo, con il file ancora aperto. Il puntatore del file rimarrà dovunque avremo smesso di leggere, aspettando il prossimo comando di <code>readline()</code>. Nel frattempo, la cache ha ora più elementi, e se ricominciamo di nuovo a cercare di pluralizzare una nuova parola, ognuno degli elementi in cache verrà provato prima di leggere la riga successiva dal file dei pattern.
</ul>

<p>E quindi, abbiamo raggiunto i nostri obiettivi combinati:

<ol>
<li><strong>Costo di inizializzazione minimo.</strong> L'unica cosa che succede durante l'importazione del modulo è la creazione di una singola istanza di una classe e l'apertura di un file (ma senza alcuna lettura).
<li><strong>Prestazioni massime.</strong> L'esempio precedente avrebbe letto tutto il file e costruito funzioni dinamicamente ogni volta che volevate pluralizzare una parola. Questa versione memorizza le funzioni non appena vengono costruite, e nel caso peggiore leggerà tutto il file dei pattern una volta sola, a prescindere dal numero di parole che pluralizzate.
<li><strong>Separazione di codice e dati.</strong> Tutti i pattern sono archiviati in un file separato. Il codice è codice, i dati sono dati, <span class=wtf>and never the twain shall meet</span>.
</ol>

<h2 id=furtherreading>Letture di approfondimento</h2>
<ul>
<li><a href=http://www.python.org/dev/peps/pep-0234/>PEP 234: Iterators</a>
<li><a href=http://www.python.org/dev/peps/pep-0255/>PEP 255: Simple Generators</a>
</ul>

<p class=nav><a rel=prev href=espressioni-regolari.html title="indietro a &#8220;Espressioni regolari&#8221;"><span>&#x261C;</a> <a rel=next href=uso-avanzato-degli-iteratori.html title="avanti a &#8220;Uso avanzato degli iteratori&#8221;"><span>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;9 <a href=about.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
