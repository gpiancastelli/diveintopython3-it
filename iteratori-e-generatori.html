<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Iterators &amp; generators - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
body{counter-reset:h1 5}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#iterators-and-generators>Dive Into Python 3</a> <span>&#8227;</span>
<h1>Iteratori <i class=baa>&amp;</i> generatori</h1>
<blockquote class=q>
<p><span>&#x275D;</span> East is East, and West is West, and never the twain shall meet. <span>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Rudyard_Kipling>Rudyard Kipling</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>L'inglese è una lingua schizofrenica che prende in prestito parole da molte altre lingue. Le più basilari operazioni linguistiche, come prendere un nome singolare e trasformarlo in un nome plurale, sono complicate dal retaggio misto della lingua. Ci sono regole, e poi ci sono eccezioni alle regole, e infine ci sono eccezioni alle eccezioni.
<p>In questo capitolo, imparerete qualcosa sui nomi plurali. E anche su funzioni che restituiscono altre funzioni, espressioni regolare avanzate, iteratori e generatori. Ma prima, parliamo di come costruire nomi plurali. (Se non avete ancora letto <a href=espressioni-regolari.html>il capitolo sulle espressioni regolari</a>, questo potrebbe essere un buon momento per farlo. Questo capitolo presume che abbiate capito le basi delle espressioni regolari, e discenderà velocemente verso usi più avanzati.)
<p>Se siete cresciuti in un paese di lingua madre inglese o avete imparato l'inglese in un ambiente scolastico formale, avrete familiarità con le regole di base:
<ul>
<li>Se una parola finisce con S, X, o Z, aggiungete ES. <i>Bass</i> diventa <i>basses</i>, <i>fax</i> diventa <i>faxes</i>, e <i>waltz</i> diventa <i>waltzes</i>.
<li>Se una parola finisce con una H rumorosa, aggiungete ES; se finisce con una H muta, aggiungete solo S. Che cos'è una H rumorosa? UNa H che viene combinata con altre lettere per creare un suono che si possa udire. Quindi <i>coach</i> diventa <i>coaches</i> e <i>rash</i> diventa <i>rashes</i>, perché potete udire i suoni CH e SH quando li pronunciate. Ma <i>cheetah</i> diventa <i>cheetahs</i>, perché la H è muta.
<li>Se una parola finisce con una Y che suona come una I, cambiate la Y in IES; se la Y è combinata con una vocale per suonare come qualcos'altro, aggiungete solo S. Così <i>vacancy</i> diventa <i>vacancies</i>, ma <i>day</i> diventa <i>days</i>.
<li>Se tutto il resto fallisce, aggiungete S e sperate per il meglio.
</ul>
<p>(Lo so, ci sono un sacco di eccezioni.<i>Man</i> diventa <i>men</i> e <i>woman</i> diventa <i>women</i>, ma <i>human</i> diventa <i>humans</i>. <i>Mouse</i> diventa <i>mice</i> e <i>louse</i> diventa <i>lice</i>, ma <i>house</i> diventa <i>houses</i>. <i>Knife</i> diventa <i>knives</i> e <i>wife</i> diventa <i>wives</i>, ma <i>lowlife</i> diventa <i>lowlifes</i>. E non fatemi parlare delle parole che sono il loro stesso plurale, come <i>sheep</i>, <i>deer</i>, e <i>haiku</i>.)
<p>In altre lingue, ovviamente, le cose sono completamente differenti.
<p>Progettiamo una libreria Python che crei automaticamente il plurale dei nomi inglesi. Cominceremo giusto con queste quattro regole, ma tenete a mente che dovrete inevitabilmente aggiungerne altre.
<h2 id=i-know>I Know, Let&#8217;s Use Regular Expressions!</h2>
<p>E così state guardando alle parole, il che significa, almeno in inglese, che state guardando a stringhe di caratteri. Avete regole che dicono che avete bisogno di trovare combinazioni differenti di caratteri, e poi fare loro cose differenti. Questo sembra un lavoro per le espressioni regolari!
<p class=d>[<a href=esempi/plural1.py>scarica <code>plural1.py</code></a>]
<pre><code>import re

def plural(noun):          
<a>    if re.search('[sxz]$', noun):             <span>&#x2460;</span></a>
<a>        return re.sub('$', 'es', noun)        <span>&#x2461;</span></a>
    elif re.search('[^aeioudgkprt]h$', noun):
        return re.sub('$', 'es', noun)       
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:
        return noun + 's'</code></pre>
<ol>
<li>Questa è una espressione regolare, ma usa una sintassi che non avete visto nel capitolo <a href=espressioni-regolari.html><i>Espressioni regolari</i></a>. Le parentesi quadre significano &#8220;trova una corrispondenza con esattamente uno di questi caratteri.&#8221; Così <code>[sxz]</code> significa &#8220;<code>s</code>, oppure <code>x</code>, oppure <code>z</code>&#8221;, ma solo uno di loro. Il simbolo <code>$</code> dovrebbe risultarvi familiare; corrisponde alla fine della stringa. Combinata, questa espressione regolare verifica che <var>noun</var> finisca con <code>s</code>, <code>x</code>, oppure <code>z</code>.
<li>Questa funzione <code>re.sub</code> esegue sostituzioni di stringhe basandosi su una espressione regolare.
</ol>

<p>Diamo un'occhiata alle sostituzioni di espressioni regolari in maggior dettaglio.
<pre class=screen>
<samp class=p>>>> </samp><kbd>import re</kbd>
<a><samp class=p>>>> </samp><kbd>re.search('[abc]', 'Mark')</kbd>    <span>&#x2460;</span></a>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<a><samp class=p>>>> </samp><kbd>re.sub('[abc]', 'o', 'Mark')</kbd>  <span>&#x2461;</span></a>
<samp>'Mork'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub('[abc]', 'o', 'rock')</kbd>  <span>&#x2462;</span></a>
<samp>'rook'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub('[abc]', 'o', 'caps')</kbd>  <span>&#x2463;</span></a>
<samp>'oops'</samp></pre>
<ol>
<li>La stringa <code>Mark</code> contiene <code>a</code>, <code>b</code>, oppure <code>c</code>? Sì, contiene <code>a</code>.
<li>OK, adesso trova <code>a</code>, <code>b</code>, oppure <code>c</code>, e sostituiscilo con <code>o</code>. <code>Mark</code> diventa <code>Mork</code>.
<li>La stessa funzione trasforma <code>rock</code> in <code>rook</code>.
<li>Potreste pensare che questo trasformi <code>caps</code> in <code>oaps</code>, ma non lo fa. <code>re.sub</code> rimpiazza <em>tutte</em> le corrispondenze, non solo la prima. Quindi questa espressione regolare trasforma <code>caps</code> in <code>oops</code>, perché entrambe le <code>c</code> e le <code>a</code> vengono trasformate in <code>o</code>.
</ol>

<p>E ora, torniamo alla funzione <code>plural()</code>&hellip;

<pre><code>def plural(noun):          
    if re.search('[sxz]$', noun):            
<a>        return re.sub('$', 'es', noun)         <span>&#x2460;</span></a>
<a>    elif re.search('[^aeioudgkprt]h$', noun):  <span>&#x2461;</span></a>
<a>        return re.sub('$', 'es', noun)         <span>&#x2462;</span></a>
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:
        return noun + 's'</code></pre>
<ol>
<li>Qui, state sostituendo la fine della stringa (a cui corrisponde il simbolo <code>$</code>) con la stringa <code>es</code>. In altre parole, state aggiungendo <code>es</code> alla stringa. Potreste ottenere la stessa cosa con la concatenazione di stringhe, per esempio <code>noun + 'es'</code>, ma ho scelto di usare le espressioni regolari per ogni regola, per ragioni che diverranno chiare più tardi in questo capitolo.
<li>Guardate attentamente, questa è un'altra nuova variazione. Il simbolo <code>^</code> come primo carattere tra parentesi quadre significa qualcosa di speciale: negazione. <code>[^abc]</code> significa &#8220;ogni singolo carattere <em>tranne</em> <code>a</code>, <code>b</code>, oppure <code>c</code>&#8221;. Allo stesso modo, <code>[^aeioudgkprt]</code> significa qualsiasi carattere tranne <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>d</code>, <code>g</code>, <code>k</code>, <code>p</code>, <code>r</code>, oppure <code>t</code>. Successivamente, quel carattere deve essere seguito da <code>h</code>, seguito a sua volta dalla fine della stringa. State cercando parole che finiscono in H dove la H può essere udita.
<li>Stesso schema qui: cerca parole che finiscono in Y, dove il carattere che precede la Y <em>non</em> è <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, oppure <code>u</code>. State cercando parole che finiscono con una Y che suona come una I.
</ol>

<p>Diamo una occhiata alle espressioni regolari negate in maggior dettaglio.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import re</kbd>
<a><samp class=p>>>> </samp><kbd>re.search('[^aeiou]y$', 'vacancy')</kbd>  <span>&#x2460;</span></a>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<a><samp class=p>>>> </samp><kbd>re.search('[^aeiou]y$', 'boy')</kbd>      <span>&#x2461;</span></a>
<samp class=p>>>> </samp>
<samp class=p>>>> </samp><kbd>re.search('[^aeiou]y$', 'day')</kbd>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd>re.search('[^aeiou]y$', 'pita')</kbd>     <span>&#x2462;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li><code>vacancy</code> corrisponde a questa espressione regolare, perché finisce con <code>cy</code>, e <code>c</code> non è <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, oppure <code>u</code>.
<li><code>boy</code> non corrisponde, perché finisce con <code>oy</code>, e avete specificatamente detto che il carattere prima della <code>y</code> non può essere <code>o</code>. <code>day</code> non corrisponde, perche termina in <code>ay</code>.
<li><code>pita</code> non corrisponde, perché non termina in <code>y</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>re.sub('y$', 'ies', 'vacancy')</kbd>               <span>&#x2460;</span></a>
<samp>'vacancies'</samp>
<samp class=p>>>> </samp><kbd>re.sub('y$', 'ies', 'agency')</kbd>
<samp>'agencies'</samp>
<a><samp class=p>>>> </samp><kbd>re.sub('([^aeiou])y$', r'\1ies', 'vacancy')</kbd>  <span>&#x2461;</span></a>
<samp>'vacancies'</samp></pre>
<ol>
<li>Questa espressione regolare trasforma <code>vacancy</code> in <code>vacancies</code> e <code>agency</code> in <code>agencies</code>, che è quello che volevate. Notate che trasformerebbe anche <code>boy</code> in <code>boies</code>, ma questo non succederà mai nella funzione perché avete utilizzato <code>re.search</code> prima per capire se dovreste applicare <code>re.sub</code>.
<li>Giusto di passaggio, voglio sottolineare che è possibile combinare queste due espressioni regolari (una per scoprire se la regola è applicabile, e l'altra per applicarla effettivamente) in una singola espressione regolare. Questo è come apparirebbe. La maggior parte di essa dovrebbe sembrare familiare: state usando un <span class=wtf>remembered group</span>, che avete imparato nella sezione <a href=espressioni-regolari.html#phonenumbers>Caso di studio: riconoscere i numeri di telefono</a>. Il gruppo è usato per ricordare il carattere prima della lettera <code>y</code>. Poi, nella stringa di sostituzione, usate una nuova sintassi, <code>\1</code>, che significa &#8220;ehi, quel primo gruppo che ricordi? mettilo proprio qui.&#8221; In questo caso, avete ricordato la <code>c</code> prima della <code>y</code>; quando fate la sostituzione, sostituite <code>c</code> al posto di <code>c</code>, e <code>ies</code> al posto di <code>y</code>. (Se avete più di un <span class=wtf>remembered group</span>, potete usare <code>\2</code> e <code>\3</code> e così via.)
</ol>
<p>Le sostituzioni di espressioni regolari sono estremamente potenti, e la sintassi <code>\1</code> le rende ancora più potenti. Ma combinare entrambe le operazioni in un'unica espressione regolare è anche più difficile da leggere, e non corrisponde direttamente al modo in cui avete precedentemente descritto le regole per la pluralizzazione. Avete originariamente esposto le regole come &#8220;se la parola finisce con S, X, o Z, allora aggiungete ES&#8221;. Se guardate a questa funzione, avete due righe di codice che dicono esattamente &#8220;se la parola finisce con S, X, o Z, allora aggiungete ES&#8221;. Non può essere più diretto di così. 

<h2 id=a-list-of-functions>Una lista di funzioni</h2>

<p>Ora state per aggiungere un livello di astrazione. Avete cominciato definendo una lista di regole: se accade questo, fai quello, altrimenti vai alla prossima regola. Complichiamo temporaneamente parte del programma in modo da semplificarne un'altra parte.

<p class=d>[<a href=esempi/plural2.py>scarica <code>plural2.py</code></a>]
<pre><code>import re

def match_sxz(noun):
    return re.search('[sxz]$', noun)

def apply_sxz(noun):
    return re.sub('$', 'es', noun)

def match_h(noun):
    return re.search('[^aeioudgkprt]h$', noun)

def apply_h(noun):
    return re.sub('$', 'es', noun)

<a>def match_y(noun):                             <span>&#x2460;</span></a>
    return re.search('[^aeiou]y$', noun)
        
<a>def apply_y(noun):                             <span>&#x2461;</span></a>
    return re.sub('y$', 'ies', noun)

def match_default(noun):
    return True

def apply_default(noun):
    return noun + 's'

<a>rules = ((match_sxz, apply_sxz),               <span>&#x2462;</span></a>
         (match_h, apply_h),
         (match_y, apply_y),
         (match_default, apply_default)
         )

def plural(noun):           
<a>    for matches_rule, apply_rule in rules:       <span>&#x2463;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>Ora, ogni regola di corrispondenza è la sua propria funzione che restituisce i risultati della chiamata della funzione <code>re.sub()</code>.
<li>Anche ogni regola di applicazione è la sua propria funzione che chiama la funzione <code>re.search()</code> per applicare la regola di pluralizzazione appropriata.
<li>Invece di avere una funzione (<code>plural()</code>) con regole multiple, avete la struttura dati <code>rules</code>, che è una sequenza di coppie di funzioni.
<li>Dato che le regole sono state estratte in una struttura dati separata, la nuova funzione <code>plural()</code> può essere ridotta a poche righe di codice. Usando un ciclo <code>for</code>, potete estrarre regole di corrispondenza e applicazione due alla volta (una per il primo tipo, una per il secondo) dalla struttura dati <var>rules</var>. Alla prima iterazione del ciclo <code>for</code>, <var>matches_rule</var> varrà <code>match_sxz</code>, e <var>apply_rule</var> varrà <code>apply_sxz</code>. Alla seconda iterazione (supponendo che ci arriviate), a <var>matches_rule</var> verrà assegnata <code>match_h</code>, e a <var>apply_rule</var> verrà assegnata <code>apply_h</code>. La funzione garantisce di restituire qualcosa alla fine, perché l'ultima regola di corrispondenza (<code>match_default</code>) restituisce semplicemente <code>True</code>, significando che la regola di applicazione corrispondente (<code>apply_default</code>) sarà sempre applicata.
</ol>

<aside>La variabile &#8220;rules&#8221; è una lista di funzioni.</aside>
<p>La ragione per cui questa tecnica funzione è che <a href=il-vostro-primo-programma-python.html#everythingisanobject>ogni cosa in Python è un oggetto</a>, comprese le funzioni. La struttura dati <var>rules</var> contiene funzioni &mdash; non nomi di funzioni, ma reali oggetti funzione. Quando essi vengono assegnati nel ciclo <code>for</code>, allora <var>matches_rule</var> e <var>apply_rule</var> diventano funzioni reali che potete chiamare. Alla prima iterazione del ciclo <code>for</code>, questo è equivalente a chiamare <code>matches_sxz(noun)</code>, e se restituisce una corrispondenza, a chiamare anche <code>apply_sxz(noun)</code>.

<p>Se questo livello di astrazione addizionale vi confonde, provate a svolgere la funzione per vedere l'equivalenza. L'intero ciclo <code>for</code> è equivalente a quanto segue:

<pre><code>
def plural(noun):
    if match_sxz(noun):
        return apply_sxz(noun)
    if match_h(noun):
        return apply_h(noun)
    if match_y(noun):
        return apply_y(noun)
    if match_default(noun):
        return apply_default(noun)</code></pre>

<p>Il beneficio qui è che quella funzione <code>plural()</code> è ora semplificata. Prende una lista di regole, definite da qualche altra parte, e itera attraverso di loro in modo generico.

<ol>
<li>Ottenete una regola di corrispondenza
<li>Corrisponde? Allora chiamate la regola di applicazione e restituite il risultato.
<li>Nessuna corrispondenza? Andate al passo 1.
</ol>

<p>Le regole potrebbero essere definite ovunque, in ogni caso. La funzione <code>plural()</code> non se ne cura.

<p>Ora, l'aggiunta di questo livello di astrazione meritava? Non ancora. Consideriamo cosa sarebbe necessario fare per aggiungere una nuova regola alla funzione. Nel primo esempio, questo richiederebbe l'aggiunta di una istruzione <code>if</code> alla funzione <code>plural()</code>. Nel secondo esempio, richiederebbe l'aggiunta di due funzioni, <code>match_foo()</code> e <code>apply_foo()</code>, e l'aggiornamento della lista <var>rules</var> per specificare in quale ordine le nuove funzioni di corrispondenza e applicazione dovrebbero essere chiamate rispetto alle altre regole. 

<p>Ma questa è solo una pietra miliare verso la prossima sezione. Muoviamoci&hellip;

<h2 id=a-list-of-patterns>Una lista di pattern</h2>

<p>Definire funzioni nominate separatamente per ogni regola di corrispondenza e applicazione non è realmente necessario. Non le chiamate mai direttamente; le aggiungete alla lista <var>rules</var> e le chiamate attraverso là. In più, ogni funzione segue uno di due schemi. Tutte le funzioni di corrispondenza chiamano <code>re.search()</code>, e tutte le funzioni di applicazione chiamano <code>re.sub()</code>. Fattorizziamo gli schemi in modo che definire nuove regole diventi più semplice.

<p class=d>[<a href=esempi/plural3.py>scarica <code>plural3.py</code></a>]
<pre><code>import re

def build_match_and_apply_functions(pattern, search, replace):
<a>    def matches_rule(word):                                     <span>&#x2460;</span></a>
        return re.search(pattern, word)
<a>    def apply_rule(word):                                       <span>&#x2461;</span></a>
        return re.sub(search, replace, word)
<a>    return (matches_rule, apply_rule)                           <span>&#x2462;</span></a></code></pre>
<ol>
<li><code>build_match_and_apply_functions()</code> è una funzione che costruisce altre funzioni dinamicamente. Prende <var>pattern</var>, <var>search</var> e <var>replace</var>, poi definisce una funzione <code>matches_rule()</code> che chiama <code>re.search()</code> con il <var>pattern</var> che è stato passato alla funzione <code>build_match_and_apply_functions()</code>, e la <var>word</var> che è stata passata alla funzione <code>matches_rule()</code> che state costruendo. Whoa.
<li>La costruzione della funzione di applicazione viene fatta allo stesso modo. La funzione di applicazione è una funzione che prende un parametro, e chiama <code>re.sub()</code> con i parametri <var>search</var> e <var>replace</var> che sono stati passati alla funzione <code>build_match_and_apply_functions()</code>, e la <var>word</var> che è stata passata alla funzione <code>apply_rule()</code> che state costruendo. Questa tecnica di usare i valori di parametri esterni all'interno di una funzione dinamica è chiamata <em>chiusura</em>. State essenzialmente definendo delle costanti nell'ambto della funzione di applicazione che state costruendo; questa prende un parametro (<var>word</var>), ma poi agisce su quello più due altri valori (<var>search</var> and <var>replace</var>) che sono stati impostati quando avete definito la funzione di applicazione.
<li>Infine, la funzione <code>build_match_and_apply_functions()</code> restituisce una tupla di due valori: le due funzion che avete appena creato. Le costanti definite in quelle funzioni (<var>pattern</var> nell'ambito di <var>matchFunction</var>, e <var>search</var> e <var>replace</var> nell'ambito di <var>applyFunction</var>) rimangono con quelle funzioni, persino dopo che le avete restituite da <code>build_match_and_apply_functions()</code>. Questo è increidbilmente figo.
</ol>

<p>Se questo risulta incredibilmente confuso (e dovrebbe, è roba strana), potrebbe diventare più chiaro nel momento in cui vedete come si usa.

<pre><code>
<a>patterns = \                                                        <span>&#x2460;</span></a>
  [
    ['[sxz]$',           '$',  'es'],
    ['[^aeioudgkprt]h$', '$',  'es'],
    ['(qu|[^aeiou])y$',  'y$', 'ies'],
    ['$',                '$',  's']
  ]
<a>rules = [build_match_and_apply_functions(pattern, search, replace)  <span>&#x2461;</span></a>
         for (pattern, search, replace) in patterns]</code></pre>
<ol>
<li>Le nostre regole di pluralizzazione sono ora definite come una lista di liste di stringhe (non funzioni). La prima stringa in ogni gruppo è l'espressione regolare che usereste in <code>re.search()</code> per vedere se c'è una corrispondenza con questa regola. La seconda e la terza stringa di ogni gruppo sono le espressioni di ricerca e sostituzione che usereste in <code>re.sub()</code> per applicare effettivamente la regola e trasformare un sostantivo nel suo plurale.
<li>Questa riga è magia. Prende la lista di stringhe in <var>patterns</var> e la trasforma in una lista di funzioni. Come? Facendo corrispondere le stringhe alla funzione <code>build_match_and_apply_functions()</code>, che giustamente capita di prendere tre stringhe come parametri e restituire una tupla di due funzioni. Questo significa che <var>rules</var> finisce per essere esattamente come nell'esempio precedente: una lista di tuple, dove ogni tupla è una coppia di funzioni, dove la prima funzione è la funzione di corrispondenza che chiama <code>re.search()</code>, e la seconda funzione è la funzione di applicazione che chiama <code>re.sub()</code>.
</ol>

<p>Per completare questa versione del programma ecco il punto di entrata principale, la funzione <code>plural()</code>.

<pre><code>def plural(noun):
<a>    for matches_rule, apply_rule in rules:  <span>&#x2460;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>Visto che la lista <var>rules</var> è la stessa dell'esempio precedente (davvero, lo è), non dovrebbe sorprendervi che la funzione <code>plural()</code> non sia cambiata per niente. Rimane completamente generica; prende una lista di funzioni di regole e le chiama in ordine. Non si cura di come le regole sono definite. Nell'esempio precedente, esse erano definite come funzioni separate con un proprio nome. Ora sono costruite dinamicamente mappando l'uscita della funzione <code>build_match_and_apply_functions()</code> su una lista di grezze stringhe. Non ha importanza; la funzione <code>plural</code> continua a lavorare nello stesso modo.
</ol>

<h2 id=a-file-of-patterns>Un file di pattern</h2>

<p>Avete fattorizzato tutto il codice duplicato e aggiunto abbastanza astrazioni in modo che le regole di pluralizzazione sono definite in una lista di stringhe. Il passo logico successivo consiste nel prendere queste stringhe e metterle in un file separato, dove possano essere mantenute separatamente dal codice che le usa. 

<p>Prima di tutto, creiamo un file di testo che contiene le regole che volete. Nessuna struttura dati elaborata, solo stringhe separate da spazi bianchi in tre colonne. Chiamiamo questo file <code>plural4-rules.txt</code>.

<p class=d>[<a href=esempi/plural4-rules.txt>scarica <code>plural4-rules.txt</code></a>]
<pre><code>[sxz]$               $    es
[^aeioudgkprt]h$     $    es
[^aeiou]y$          y$    ies
$                    $    s</code></pre>

<p>Ora vediamo come potete usare questo file di regole.

<p class=fixme>[FIXME: now that this chapter comes before the I/O chapter, need to at least mention what open() does]
<p class=d>[<a href=esempi/plural4.py>scarica <code>plural4.py</code></a>]
<pre><code>import re

<a>def build_match_and_apply_functions(pattern, search, replace):  <span>&#x2460;</span></a>
    def matches_rule(word):
        return re.search(pattern, word)
    def apply_rule(word):
        return re.sub(search, replace, word)
    return (matches_rule, apply_rule)

rules = []
<a>pattern_file = open('plural4-rules.txt')                        <span>&#x2461;</span></a>
try:
<a>    for line in pattern_file:                                   <span>&#x2462;</span></a>
<a>        pattern, search, replace = line.split(None, 3)          <span>&#x2463;</span></a>
<a>        rules.append(build_match_and_apply_functions(           <span>&#x2464;</span></a>
                pattern, search, replace))
finally:
<a>    pattern_file.close()                                        <span>&#x2465;</span></a></code></pre>
<ol>
<li>La funzione <code>build_match_and_apply_functions()</code> non è cambiata. State ancora usando le chiusure per costruire dinamicamente due funzioni che usano variabili definite nella funzione esterna.
<li>Aprite il file che contiene i pattern.
<li>Leggete il file una riga alla volta, usando l'idioma <code>for line in &lt;fileobject&gt;</code>.
<li>Ogni riga nel file in realtà contiene tre valori, ma essi sono separati da spazi bianchi (tabulazioni o spazi non fa alcuna differenza). Per separarli, usate il metodo <code>split()</code> delle stringhe. Il primo argomento del metodo <code>split()</code> è <code>None</code>, il che significa &#8220;separa sulla base di qualsiasi spazio bianco (tabulazioni o spazi non fa alcuna differenza).&#8221; Il secondo argomento è <code>3</code>, che significa &#8220;separa sulla base di spazi bianchi per 3 volte, poi scarta il resto della riga.&#8221; Una riga come <code>[sxz]$ $ es</code> verrà spezzata nella tupla <code>('[sxz]$', '$', 'es')</code>, il che significa che <var>pattern</var> avrà il valore <code>'[sxz]$'</code>, <var>search</var> avrà il valore <code>'$'</code>, e <var>replace</var> avrà il valore <code>'es'</code>. C'è molta potenza in una piccola riga di codice.
<li>Usate un blocco <code>try..finally</code> per assicurarvi di chiudere l'oggetto file.
</ol>

<p>In questo caso il miglioramento è che avete completamente separato le regole di pluralizzazione in un file esterno, in modo che possa essere mantenuto separatamente dal codice che lo utilizza. Il codice è codice, i dati sono dati, e la vita è bella.

<h2 id=generators>Generators</h2>

<p>Now you&#8217;re ready to learn about generators.

<p class=d>[<a href=examples/plural5.py>download <code>plural5.py</code></a>]
<pre><code>def rules():
    for line in open('plural5-rules.txt'):
        pattern, search, replace = line.split(None, 3)
        yield build_match_and_apply_functions(pattern, search, replace)

def plural(noun):
    for matches_rule, apply_rule in rules():
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>

<p>How the heck does <em>that</em> work? Let&#8217;s look at an interactive example first.

<pre class=screen>
<samp class=p>>>> </samp><kbd>def make_counter(x):</kbd>
<samp class=p>... </samp><kbd>print 'entering make_counter'</kbd>
<samp class=p>... </samp><kbd>while True:</kbd>
<a><samp class=p>... </samp><kbd>    yield x</kbd>                    <span>&#x2460;</span></a>
<samp class=p>... </samp><kbd>    print 'incrementing x'</kbd>
<samp class=p>... </samp><kbd>    x = x + 1</kbd>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd>counter = make_counter(2)</kbd>      <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>counter</kbd>                        <span>&#x2462;</span></a>
&lt;generator object at 0x001C9C10>
<a><samp class=p>>>> </samp><kbd>next(counter)</kbd>                  <span>&#x2463;</span></a>
<samp>entering make_counter
2</samp>
<a><samp class=p>>>> </samp><kbd>next(counter)</kbd>                  <span>&#x2464;</span></a>
<samp>incrementing x
3</samp>
<a><samp class=p>>>> </samp><kbd>next(counter)</kbd>                  <span>&#x2465;</span></a>
<samp>incrementing x
4</samp></pre>
<ol>
<li>The presence of the <code>yield</code> keyword in <code>make_counter</code> means that this is not a normal function. It is a special kind of function which generates values one at a time. You can think of it as a resumable function. Calling it will return a <i>generator</i> that can be used to generate successive values of <var>x</var>.
<li>To create an instance of the <code>make_counter</code> generator, just call it like any other function. Note that this does not actually execute the function code. You can tell this because the first line of the <code>make_counter()</code> function calls <code>print()</code>, but nothing has been printed yet.
<li>The <code>make_counter()</code> function returns a generator object.
<li>The <code>next()</code> function takes a generator object and returns its next value. The first time you call <code>next()</code> with the <var>counter</var> generator, it executes the code in <code>make_counter()</code> up to the first <code>yield</code> statement, then returns the value that was yielded. In this case, that will be <code>2</code>, because you originally created the generator by calling <code>make_counter(2)</code>.
<li>Repeatedly calling <code>next()</code> with the same generator object resumes exactly where it left off and continues until it hits the next <code>yield</code> statement. All variables, local state, <i class=baa>&amp;</i>c. are saved on <code>yield</code> and restored on <code>next()</code>. The next line of code waiting to be executed calls <code>print()</code>, which prints <samp>incrementing x</samp>. After that, the statement <code>x = x + 1</code>. Then it loops through the <code>while</code> loop again, and the first thing it hits is the statement <code>yield x</code>, which saves the state of everything and returns the current value of <var>x</var> (now <code>3</code>).
<li>The second time you call <code>next(counter)</code>, you do all the same things again, but this time <var>x</var> is now <code>4</code>.
</ol>

<p>Since <code>make_counter</code> sets up an infinite loop, you could theoretically do this forever, and it would just keep incrementing <var>x</var> and spitting out values. But let&#8217;s look at more productive uses of generators instead.

<h3 id=a-fibonacci-generator>A Fibonacci Generator</h3>

<p class=d>[<a href=examples/fibonacci.py>download <code>fibonacci.py</code></a>]
<pre><code>def fib(max):
<a>    a, b = 0, 1          <span>&#x2460;</span></a>
    while a &lt; max:
<a>        yield a          <span>&#x2461;</span></a>
<a>        a, b = b, a + b  <span>&#x2462;</span></a></code></pre>
<ol>
<li>The Fibonacci sequence is a sequence of numbers where each number is the sum of the two numbers before it. It starts with <code>0</code> and <code>1</code>, goes up slowly at first, then more and more rapidly. To start the sequence, you need two variables: <var>a</var> starts at <code>0</code>, and <var>b</var> starts at <code>1</code>.
<li><var>a</var> is the current number in the sequence, so yield it.
<li><var>b</var> is the next number in the sequence, so assign that to <var>a</var>, but also calculate the next value (<code>a + b</code>) and assign that to <var>b</var> for later use. Note that this happens in parallel; if <var>a</var> is <code>3</code> and <var>b</var> is <code>5</code>, then <code>a, b = b, a + b</code> will set <var>a</var> to <code>5</code> (the previous value of <var>b</var>) and <var>b</var> to <code>8</code> (the sum of the previous values of <var>a</var> and <var>b</var>).
</ol>

<aside>&#8220;yield&#8221; pauses a function. &#8220;next()&#8221; resumes where it left off.</aside>

<p>So you have a function that spits out successive Fibonacci numbers. Sure, you could do that with recursion, but this way is easier to read. Also, it works well with <code>for</code> loops.

<pre class=screen>
<samp class=p>>>> </samp><kbd>from fibonacci import fib</kbd>
<a><samp class=p>>>> </samp><kbd>for n in fib(1000):</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd>    print(n, end=' ')</kbd>    <span>&#x2461;</span></a>
<samp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp></pre>
<ol>
<li>You can use a generator like <code>fib()</code> in a <code>for</code> loop directly. The <code>for</code> loop will automatically call the <code>next()</code> function to get values from the <code>fib()</code> generator and assign them to the <code>for</code> loop index variable (<var>n</var>).
<li>Each time through the <code>for</code> loop, <var>n</var> gets a new value from the <code>yield</code> statement in <code>fib()</code>, and all you have to do is print it out. Once <code>fib()</code> runs out of numbers (<var>a</var> becomes bigger than <var>max</var>, which in this case is <code>1000</code>), then the <code>for</code> loop exits gracefully.
</ol>

<h3 id=a-plural-rule-generator>A Plural Rule Generator</h3>

<p>Let&#8217;s go back to <code>plural5.py</code> and see how this version of the <code>plural()</code> function works.

<pre><code>def rules():
<a>    for line in open('plural5-rules.txt'):                               <span>&#x2460;</span></a>
<a>        pattern, search, replace = line.split(None, 3)                   <span>&#x2461;</span></a>
<a>        yield build_match_and_apply_functions(pattern, search, replace)  <span>&#x2462;</span></a>

def plural(noun):
<a>    for matches_rule, apply_rule in rules():                             <span>&#x2463;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>As you&#8217;ve seen, <code>for line in open(...)</code> is a common idiom for reading from a file one line at a time. But here&#8217;s what you might not know: the reason this idiom works is because <em><code>open()</code> actually returns a generator, and calling <code>next()</code> on this generator returns the next line of the file.</em>
<li>No magic here. Remember that the lines of the rules file have three values separated by whitespace, so you use <code>line.split(None, 3)</code> to get the three &#8220;columns&#8221; and assign them to three local variables.
<li><em>And then you yield.</em> What do you yield? Two functions, built dynamically with your old friend, <code>build_match_and_apply_functions()</code>, which is identical to the previous examples. In other words, <code>rules()</code> is a generator that spits out match and apply functions <em>on demand</em>.
<li>Since <code>rules()</code> is a generator, you can use it directly in a <code>for</code> loop. The first time through the <code>for</code> loop, you will call the <code>rules()</code> function, which will open the pattern file, read the first line, dynamically build a match function and an apply function from the patterns on that line, and yield the dynamically built functions. The second time through the <code>for</code> loop, you will pick up exactly where you left off in <code>rules()</code> (which was in the middle of the <code>for line in file(...)</code> loop). The first thing it will do is read the next line of the file (which is still open), dynamically build another match and apply function based on the patterns on that line in the file, and yield the two functions.
</ol>

<p>What have you gained over stage 4? Startup time. In stage 4, when you imported the <code>plural4</code> module, it read the entire patterns file and built a list of all the possible rules, before you could even think about calling the <code>plural()</code> function. With generators, you can do everything lazily: you read the first rule and create functions and try them, and if that works you don&#8217;t ever read the rest of the file or create any other functions.

<p>What have you lost? Performance! Every time you call the <code>plural()</code> function, the <code>rules()</code> generator starts over from the beginning &mdash; which means re-opening the patterns file and reading from the beginning, one line at a time.

<p>What if you could have the best of both worlds: minimal startup cost (don&#8217;t execute any code on <code>import</code>), <em>and</em> maximum performance (don&#8217;t build the same functions over and over again). Oh, and you still want to keep the rules in a separate file (because code is code and data is data), just as long as you never have to read the same line twice.

<h2 id=iterators>Iterators</h2>

<p>In truth, generators are special case of <i>iterators</i>. A function that <code>yield</code>s values is a nice, compact way of building an iterator without building an iterator. Let me show you what I mean by that.

<h3 id=a-fibonacci-iterator>A Fibonacci Iterator</h3>

<p>Remember <a href=a-fibonacci-generator>the Fibonacci generator</a>? Here it is as a built-from-scratch iterator:

<p class=d>[<a href=examples/fibonacci2.py>download <code>fibonacci2.py</code></a>]
<pre><code><a>class fib:                                        <span>&#x2460;</span></a>
<a>    def __init__(self, max):                      <span>&#x2461;</span></a>
        self.max = max

<a>    def __iter__(self):                           <span>&#x2462;</span></a>
        self.a, self.b = 0, 1
        return self

<a>    def __next__(self):                           <span>&#x2463;</span></a>
        fib = self.a
        if fib > self.max:
<a>            raise StopIteration                   <span>&#x2464;</span></a>
        self.a, self.b = self.b, self.a + self.b
<a>        return fib                                <span>&#x2465;</span></a></code></pre>
<ol>
<li>To build an iterator from scratch, <code>fib</code> needs to be a class, not a function.
<li>&#8220;Calling&#8221; <code>fib(max)</code> is really creating an instance of this class and calling its <code>__init__()</code> method with <var>max</var>. The <code>__init__()</code> method saves the maximum value as an instance variable so other methods can refer to it later.
<li>The <code>__iter__()</code> method is called whenever someone calls <code>iter(fib)</code>. (As you&#8217;ll see in a minute, a <code>for</code> loop will call this automatically, but you can also call it yourself manually.) After performing beginning-of-iteration initialization (in this case, resetting <code>self.a</code> and <code>self.b</code>, our two counters), the <code>__iter__()</code> method can return any object that implements a <code>__next__()</code> method. In this case (and in most cases), <code>__iter__()</code> simply returns <code>self</code>, since this class implements its own <code>__next__()</code> method.
<li>The <code>__next__()</code> method is called whenever someone calls <code>next()</code> on an iterator of an instance of a class. That will make more sense in a minute.
<li>When the <code>__next__()</code> method raises a <code>StopIteration</code> exception, this signals to the caller that the iteration is over; no more values are available. If the caller is a <code>for</code> loop, it will notice this <code>StopIteration</code> exception and gracefully exit the loop. (In other words, it will swallow the exception.) This little bit of magic is actually the key to using iterators in <code>for</code> loops.
<li>To spit out the next value, an iterator&#8217;s <code>__next__()</code> method simply <code>return</code>s the value. Do not use <code>yield</code> here; that&#8217;s a bit of syntactic sugar that only applies when you&#8217;re using generators. Here you&#8217;re creating your own iterator from scratch; use <code>return</code> instead.
</ol>

<p>Thoroughly confused yet? Excellent. Let&#8217;s see how to call this iterator:</p>

<pre class=screen>
<samp class=p>>>> </samp><kbd>from fibonacci2 import fib</kbd>
<samp class=p>>>> </samp><kbd>for n in fib(1000):</kbd>
<samp class=p>... </samp><kbd>    print(n, end=' ')</kbd>
<samp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp></pre>

<p>Why, it&#8217;s exactly the same! Byte for byte identical to how you called Fibonacci-as-a-generator! But how?

<p>I told you there was a bit of magic involved in <code>for</code> loops. Here&#8217;s what happens:

<ul>
<li>The <code>for</code> loop calls <code>fib(1000)</code>, as shown. This returns an instance of the <code>fib</code> class. Call this <var>fib_inst</var>.
<li>Secretly, and quite cleverly, the <code>for</code> loop calls <code>iter(fib_inst)</code>, which returns an iterator object. Call this <var>fib_iter</var>. In this case, <var>fib_iter</var> == <var>fib_inst</var>, because the <code>__iter__()</code> method returns <code>self</code>, but the <code>for</code> loop doesn&#8217;t know (or care) about that.
<li>To &#8220;loop through&#8221; the iterator, the <code>for</code> loop calls <code>next(fib_iter)</code>, which calls the <code>__next__()</code> method on the <code>fib_iter</code> object, which does the next-Fibonacci-number calculations and returns a value. The <code>for</code> loop takes this value and assigns it to <var>n</var>, then executes the body of the <code>for</code> loop for that value of <var>n</var>.
<li>How does the <code>for</code> loop know when to stop? I&#8217;m glad you asked! When <code>next(fib_iter)</code> raises a <code>StopIteration</code> exception, the <code>for</code> loop will swallow the exception and gracefully exit. (Any other exception will pass through and be raised as usual.) And where have you seen a <code>StopIteration</code> exception? In the <code>__next__()</code> method, of course!
</ul>

<h3 id=a-plural-rule-iterator>A Plural Rule Iterator</h3>

<aside>iter(f) calls f.__iter__<br>next(f) calls f.__next__</aside>
<p>Now it&#8217;s time for the finale.

<p class=d>[<a href=examples/plural6.py>download <code>plural6.py</code></a>]
<pre><code>class LazyRules:
    def __init__(self):
        self.pattern_file = open('plural6-rules.txt')
        self.cache = []

    def __iter__(self):
        self.cache_index = 0
        return self

    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
            return self.cache[self.cache_index - 1]

        if self.pattern_file.closed:
            raise StopIteration

        line = self.pattern_file.readline()
        if not line:
            self.pattern_file.close()
            raise StopIteration

        pattern, search, replace = line.split(None, 3)
        funcs = build_match_and_apply_functions(
            pattern, search, replace)
        self.cache.append(funcs)
        return funcs

rules = LazyRules()</code></pre>

<p>So this is a class that implements <code>__iter__()</code> and <code>__next__()</code>, so it can be used as an iterator. Then, you instantiate the class and assign it to <var>rules</var>. This happens just once, on import.

<p>Let&#8217;s take the class one bite at a time.

<pre><code>class LazyRules:
<a>    def __init__(self):                                <span>&#x2460;</span></a>
<a>        self.pattern_file = open('plural6-rules.txt')  <span>&#x2462;</span></a>
<a>        self.cache = []                                <span>&#x2461;</span></a></code></pre>
<ol>
<li>The <code>__init__()</code> method is only going to be called once, when you instantiate the class and assign it to <var>rules</var>.
<li>Since this is only going to get called once, it&#8217;s the perfect place to open the pattern file. You&#8217;ll read it later; no point doing more than you absolutely have to until absolutely necessary!
<li>Also, this is a good place to initialize the cache, which you&#8217;ll use later as you read the patterns from the pattern file.
</ol>

<pre><code><a>    def __iter__(self):       <span>&#x2460;</span></a>
<a>        self.cache_index = 0  <span>&#x2461;</span></a>
<a>        return self           <span>&#x2462;</span></a>
</code></pre>
<ol>
<li>The <code>__iter__()</code> method will be called every time someone &mdash; say, a <code>for</code> loop &mdash; calls <code>iter(rules)</code>.
<li>This is the place to reset the counter that we&#8217;re going to use to retrieve items from the cache (that we haven&#8217;t built yet &mdash; patience, grasshopper).
<li>Finally, the <code>__iter__()</code> method returns <code>self</code>, which signals that this class will take care of returning its own values throughout an iteration.
</ol>

<pre><code><a>    def __next__(self):                                 <span>&#x2460;</span></a>
        .
        .
        .
        pattern, search, replace = line.split(None, 3)
<a>        funcs = build_match_and_apply_functions(        <span>&#x2461;</span></a>
            pattern, search, replace)
<a>        self.cache.append(funcs)                        <span>&#x2462;</span></a>
        return funcs</code></pre>
<ol>
<li>The <code>__next__()</code> method gets called whenever someone &mdash; say, a <code>for</code> loop &mdash; calls <code>next(rules)</code>. This method will only make sense if we start at the end and work backwards. So let&#8217;s do that.
<li>The last part of this function should look familiar, at least. The <code>build_match_and_apply_functions()</code> function hasn&#8217;t changed; it&#8217;s the same as it ever was. <em>Each line of the pattern file will be read exactly once, as late as possible.</em>
<li>The only difference is that, before returning the match and apply functions (which are stored in the tuple <var>funcs</var>), we&#8217;ve going to save them in <code>self.cache</code>. <em>Each match and apply function will be built exactly once, as late as possible, then cached.</em>
</ol>

<p>Moving backwards&hellip;

<pre><code>    def __next__(self):
        .
        .
        .
<a>        line = self.pattern_file.readline()  <span>&#x2460;</span></a>
<a>        if not line:                         <span>&#x2461;</span></a>
            self.pattern_file.close()
<a>            raise StopIteration              <span>&#x2462;</span></a>
        .
        .
        .</code></pre>
<ol>
<li>A bit of advanced file trickery here. The <code>readline()</code> method (note: singular, not the plural <code>readlines()</code>) reads exactly one line from an open file. Specifically, the next line. (<em>File objects are iterators too! It&#8217;s iterators all the way down&hellip;</em>)
<li>If there was a line for <code>readline()</code> to read, <var>line</var> will not be an empty string. Even if the file contained a blank line, <var>line</var> would end up as the one-character string <code>'\n'</code> (a carriage return). If <var>line</var> is really an empty string, that means there are no more lines to read from the file.
<li>When we reach the end of the file, we should close the file and raise the magic <code>StopIteration</code> exception. Remember, we got to this point because we needed a match and apply function for the next rule. The next rule comes from the next line of the file&hellip; but there is no next line! Therefore, we have no value to return. The iteration is over. (<span>&#x266B;</span> The party&#8217;s over&hellip; <span>&#x266B;</span>)
</ol>

<p>Moving backwards all the way to the start of the <code>__next__()</code> method&hellip;

<pre><code>    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
<a>            return self.cache[self.cache_index - 1]     <span>&#x2460;</span></a>

        if self.pattern_file.closed:
<a>            raise StopIteration                         <span>&#x2461;</span></a>
        .
        .
        .</code></pre>
<ol>
<li><code>self.cache</code> will be a list of the functions we need to match and apply individual rules. (At least <em>that</em> should sound familiar!) <code>self.cache_index</code> keeps track of which cached item we should return next. If we haven&#8217;t exhausted the cache yet (<i>i.e.</i> if the length of <code>self.cache</code> is greater than <code>self.cache_index</code>), then we have a cache hit! Hooray! We can return the match and apply functions from the cache instead of building them from scratch.
<li>On the other hand, if we don&#8217;t get a hit from the cache, <em>and</em> the file object has been closed (which could happen, further down the method, as you saw in the previous code snippet), then there&#8217;s nothing more we can do. If the file is closed, it means we&#8217;ve exhausted it &mdash; we&#8217;ve already read through every line from the pattern file, and we&#8217;ve already built and cached the match and apply functions for each pattern. The file is exhausted; the cache is exhausted; I&#8217;m exhausted. Wait, what? Hang in there, we&#8217;re almost done.
</ol>

<p>Putting it all together, here&#8217;s what happens when:

<ul>
<li>When the module is imported, it creates a single instance of the <code>LazyRules</code> class, called <var>rules</var>, which opens the pattern file but does not read from it.
<li>When asked for the first match and apply function, it checks its cache but finds the cache is empty. So it reads a single line from the pattern file, builds the match and apply functions from those patterns, and caches them.
<li>Let&#8217;s say, for the sake of argument, that the very first rule matched. If so, no further match and apply functions are built, and no further lines are read from the pattern file.
<li>Furthermore, for the sake of argument, suppose that the caller calls the <code>plural()</code> function <em>again</em> to pluralize a different word. The <code>for</code> loop in the <code>plural()</code> function will call <code>iter(rules)</code>, which will reset the cache index but will not reset the open file object.
<li>The first time through, the <code>for</code> loop will ask for a value from <var>rules</var>, which will invoke its <code>__next__()</code> method. This time, however, the cache is primed with a single pair of match and apply functions, corresponding to the patterns in the first line of the pattern file. Since they were built and cached in the course of pluralizing the previous word, they&#8217;re retrieved from the cache. The cache index increments, and the open file is never touched.
<li>Let&#8217;s say, for the sake of argument, that the first rule does <em>not</em> match this time around. So the <code>for</code> loop comes around again and asks for another value from <var>rules</var>. This invokes the <code>__next__()</code> method a second time. This time, the cache is exhausted &mdash; it only contained one item, and we&#8217;re asking for a second &mdash; so the <code>__next__()</code> method continues. It reads another line from the open file, builds match and apply functions out of the patterns, and caches them.
<li>This read-build-and-cache process will continue as long as the rules being read from the pattern file don&#8217;t match the word we&#8217;re trying to pluralize. If we do find a matching rule before the end of the file, we simply use it and stop, with the file still open. The file pointer will stay wherever we stopped reading, waiting for the next <code>readline()</code> command. In the meantime, the cache now has more items in it, and if we start all over again trying to pluralize a new word, each of those items in the cache will be tried before reading the next line from the pattern file.
</ul>

<p>Thus, we have achieved our combined goal:

<ol>
<li><strong>Minimal startup cost.</strong> The only thing that happens on <code>import</code> is instantiating a single class and opening a file (but not reading from it).
<li><strong>Maximum performance.</strong> The previous example would read through the file and build functions dynamically every time you wanted to pluralize a word. This version will cache functions as soon as they&#8217;re built, and in the worst case, it will only read through the pattern file once, no matter how many words you pluralize.
<li><strong>Separation of code and data.</strong> All the patterns are stored in a separate file. Code is code, and data is data, and never the twain shall meet.
</ol>

<h2 id=furtherreading>Further Reading</h2>
<ul>
<li><a href=http://www.python.org/dev/peps/pep-0234/>PEP 234: Iterators</a>
<li><a href=http://www.python.org/dev/peps/pep-0255/>PEP 255: Simple Generators</a>
</ul>

<p class=c>&copy; 2001&ndash;9 <a href=about.html>Mark Pilgrim</a>
<script src=jquery.js></script>
<script src=dip3.js></script>
