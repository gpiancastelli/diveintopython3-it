<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Convertire codice verso Python 3 con 2to3 - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
h1:before{counter-increment:h1;content:"Appendix A. "}
h2:before{counter-increment:h2;content:"A." counter(h2) ". "}
h3:before{counter-increment:h3;content:"A." counter(h2) "." counter(h3) ". "}
tr + tr th:first-child{font:medium 'Arial Unicode MS',FreeSerif,OpenSymbol,'DejaVu Sans',sans-serif}
table{width:100%;border-collapse:collapse}
th,td{width:45%;padding:0 0.5em;border:1px solid #bbb}
th{text-align:left;vertical-align:baseline}
td{vertical-align:top}
th:first-child{width:10%;text-align:center}
th,td,td pre{margin:0}
td pre{padding:0;border:0}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#porting-code-to-python-3-with-2to3>Dive Into Python 3</a> <span>&#8227;</span>
<p id=level>Livello di difficoltà: <span title=pro>&#x2666;&#x2666;&#x2666;&#x2666;&#x2666;</span>
<h1>Convertire codice verso Python 3 con <code>2to3</code></h1>
<blockquote class=q>
<p><span>&#x275D;</span> Life is pleasant. Death is peaceful. It&#8217;s the transition that&#8217;s troublesome. <span>&#x275E;</span><br>&mdash; Isaac Asimov (attributed)
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>Virtualmente tutti i programmi scritti in Python 2 avranno bisogno almeno di qualche ritocco per essere eseguiti correttamente sotto Python 3. Per aiutare con questa transizione, Python 3 comprende uno script di utilità chiamato <code>2to3</code>, che prende il vostro codice sorgente in Python 2 in ingresso e lo converte automaticamente verso Python 3 tanto quanto gli è possibile. <a href=caso-di-studio-convertire-chardet-verso-python-3.html#running2to3>Caso di studio: convertire <code>chardet</code> verso Python 3</a> descrive come eseguire lo script <code>2to3</code>, poi mostra alcune cose che esso non riesce a correggere automaticamente. Questa appendice documenta ciò che lo script <em>può</em> correggere automaticamente
<h2 id=print>L'istruzione <code>print</code></h2>
<p>In Python 2, <code>print</code> era una istruzione. Qualsiasi cosa volevate stampare semplicemente seguiva la parola chiave <code>print</code>. In Python 3, <code>print()</code> è una funzione &mdash; ogni cosa che volete stampare è passata a <code>print()</code> come qualsiasi altra funzione.
<table>
<tr>
<th class=notes>Notes</th>
<th class=python2>Python 2</th>
<th class=python3>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>print</code></td>
<td><code>print()</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>print 1</code></td>
<td><code>print(1)</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>print 1, 2</code></td>
<td><code>print(1, 2)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>print 1, 2,</code></td>
<td><code>print(1, 2, end=' ')</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>print >>sys.stderr, 1, 2, 3</code></td>
<td><code>print(1, 2, 3, file=sys.stderr)</code></td></tr>
</table>
<ol>
<li>Per stampare una riga vuota, invocate <code>print()</code> senza alcun argomento.
<li>Per stampare un singolo valore, invocate <code>print()</code> con un argomento.
<li>Per stampare due valori separati da uno spazio, invocate <code>print()</code> con due argomenti.
<li>Questo è un po' complicato. In Python 2, se concludevate una istruzione <code>print</code> con una virgola, avrebbe stampato i valori separati da spazi, poi stampato uno spazio finale, e si sarebbe fermata senza stampare un ritorno a capo. In Python 3, il modo per fare questo è passare <code>end=' '</code> come un <span class=wtf>keyword argument</span> alla funzione <code>print()</code>. L'argomento <code>end</code> assume <code>'\n'</code> (un ritorno a capo) come valore di default, quindi <span class=wtf>overriding it</span> sopprimerà il ritorno a capo dopo la stampa degli altri argomenti.
<li>In Python 2, potevate redirigere l'output verso una pipe &mdash; come <code>sys.stderr</code> &mdash; utilizzando la sintassi <code>>>pipe_name</code>. In Python 3, il modo di fare questo è passare la pipe come valore al <span class=wtf>keyword argument</span> <code>file</code>. L'argomento <code>file</code> assume <code>sys.stdout</code> (standard output) come valore di default, quindi <span class=wtf>overriding it</span> produrrà l'output su una pipe differente.
</ol>
<h2 id=unicodeliteral>Letterali stringa Unicode</h2>
<p>Python 2 aveva due tipi di stringa: stringhe Unicode e stringhe non Unicode. Python 3 ha un solo tipo di stringa: stringhe Unicode.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>u"PapayaWhip"</code></td>
<td><code>"PapayaWhip"</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>ur"PapayaWhip\foo"</code></td>
<td><code>r"PapayaWhip\foo"</code></td></tr>
</table>
<ol>
<li>I letterali stringa Unicode sono semplicemente convertiti in letterali stringa, che, in Python 3, sono sempre di tipo Unicode.
<li>Le <span class=wtf>raw strings</span> Unicode (in cui Python non effettua l'escape automatico dei backslash) sono convertite a <span class=wtf>raw strings</span>. In Python 3, le <span class=wtf>raw strings</span> sono sempre di tipo Unicode.
</ol>
<h2 id=unicode>La funzione globale <code>unicode()</code></h2>
<p>Python 2 aveva due funzioni globali per forzare oggetti in stringhe: <code>unicode()</code> per forzarli a stringhe Unicode, e <code>str()</code> per forzarli a stringhe non Unicode. Python 3 ha un solo tipo di stringhe, stringhe Unicode, quindi la funzione <code>str()</code> è tutto quello che vi serve. (La funzione <code>unicode()</code> non esiste più.)
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>unicode(anything)</code></td>
<td><code>str(anything)</code></td></tr>
</table>
<h2 id=long>Il tipo di dato <code>long</code></h2>
<p>Python 2 aveva tipi <code>int</code> e <code>long</code> separati per i numeri non in virgola mobile. Un <code>int</code> non poteva essere più grande di <a href=#renames><code>sys.maxint</code></a>, che variava a seconda della piattaforma. I <code>long</code> erano definiti aggiungendo una <code>L</code> alla fine del numero, e potevano essere, be', più lunghi degli <code>int</code>. In Python 3, c'è solo un tipo di numeri interi, chiamato <code>int</code>, che per la maggior parte si comporta come il tipo <code>long</code> in Python 2. Dato che non ci sono più due tipi, non c'è alcun bisogno di una speciale sintassi per distinguerli.
<p>Lettura di approfondimento: <a href=http://www.python.org/dev/peps/pep-0237/><abbr>PEP</abbr> 237: Unifying Long Integers and Integers</a>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>x = 1000000000000L</code></td>
<td><code>x = 1000000000000</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>x = 0xFFFFFFFFFFFFL</code></td>
<td><code>x = 0xFFFFFFFFFFFF</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>long(x)</code></td>
<td><code>int(x)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>type(x) is long</code></td>
<td><code>type(x) is int</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>isinstance(x, long)</code></td>
<td><code>isinstance(x, int)</code></td></tr>
</table>
<ol>
<li>I letterali <code>long</code> in base 10 diventano letterali <code>int</code> in base 10.
<li>I letterali <code>long</code> in base 16 diventano letterali <code>int</code> in base 16.
<li>In Python 3, la vecchia funzione <code>long()</code> non esiste più, dato che i <code>long</code> non esistono più. Per forzare una variabile a un intero, usate la funzione <code>int()</code>.
<li>Per controllare se una variabile è un intero, recuperatene il tipo e confrontatelo con <code>int</code>, non con <code>long</code>.
<li>Potete anche usare la funzione <code>isinstance()</code> per controllare i tipi di dato; ancora, usate <code>int</code>, non <code>long</code>, per controllare gli interi.
</ol>
<h2 id=ne>Il confronto di disuguaglianza con &lt;></h2>
<p>Python 2 supportava <code>&lt;></code> come sinonimo per <code>!=</code>, l'operatore per il confronto di disuguaglianza. Python 3 supporta l'operatore <code>!=</code>, ma non <code>&lt;></code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>if x &lt;> y:</code></td>
<td><code>if x != y:</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>if x &lt;> y &lt;> z:</code></td>
<td><code>if x != y != z:</code></td></tr>
</table>
<ol>
<li>Un semplice confronto.
<li>Un confronto più complesso tra tre valori.
</ol>
<h2 id=has_key>Il metodo <code>has_key()</code> per i dizionari</h2>
<p>In Python 2, i dizionari avevano un metodo <code>has_key()</code> per verificare che il dizionario contenesse una certa chiave. In Python 3, questo metodo non esiste più. Al suo posto, dovete usare l'operatore <code>in</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>a_dictionary.has_key("PapayaWhip")</code></td>
<td><code>"PapayaWhip" in a_dictionary</code></td></tr>
<tr><th>&#x2461;</th >
<td><code>a_dictionary.has_key(x) or a_dictionary.has_key(y)</code></td>
<td><code>x in a_dictionary or y in a_dictionary</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>a_dictionary.has_key(x or y)</code></td>
<td><code>(x or y) in a_dictionary</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>a_dictionary.has_key(x + y)</code></td>
<td><code>(x + y) in a_dictionary</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>x + a_dictionary.has_key(y)</code></td>
<td><code>x + (y in a_dictionary)</code></td></tr>
</table>
<ol>
<li>La forma più semplice.
<li>L'operatore <code>or</code> ha la precedenza sull'operatore <code>in</code>, quindi non c'è alcun bisogno di usare le parentesi qui.
<li>D'altra parte, <em>avete</em> bisogno di usare le parentesi qui, per lo stesso motivo &mdash; <code>or</code> ha la precedenza su <code>in</code>.
<li>L'operatore <code>in</code> ha la precedenza sull'operatore <code>+</code>, quindi anche questa forma necessita di parentesi.
<li>Ancora con le parentesi, per la stessa ragione.
</ol>
<h2 id=dict>Metodi dei dizionari che restituiscono liste</h2>
<p>In Python 2, molti metodi dei dizionari restituivano liste. I metodi più frequentemente usati erano <code>keys()</code>, <code>items()</code>, e <code>values()</code>. In Python 3, tutti questi metodi ritornano viste dinamiche. In alcuni contesti, questo non è un problema. Se il valore di ritorno del metodo è passato immediatamente a un'altra funzione che itera attraverso l'intera sequenza, non fa alcuna differenza che il tipo reale sia una lista o una vista. In altri contesti, ha invece molta importanza. Se vi stavate aspettando una lista completa con elementi accessibili individualmente, il vostro codice si bloccherà, perché le viste non supportano l'accesso basato su indici.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>a_dictionary.keys()</code></td>
<td><code>list(a_dictionary.keys())</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_dictionary.items()</code></td>
<td><code>list(a_dictionary.items())</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>a_dictionary.iterkeys()</code></td>
<td><code>iter(a_dictionary.keys())</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>[i for i in a_dictionary.iterkeys()]</code></td>
<td><code>[i for i in a_dictionary.keys()]</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>min(a_dictionary.keys())</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li><code>2to3</code> pecca per eccesso di sicurezza, convertendo il valore di ritorno di <code>keys()</code> a una lista statica tramite la funzione <code>list()</code>. Questo funzionerà sempre, ma sarà meno efficiente che usare una vista. Dovreste esaminare il codice convertito per vedere se una lista è assolutamente necessaria, o una vista sarebbe sufficiente.
<li>Un'altra conversione da vista a lista, con il metodo <code>items()</code>. <code>2to3</code> farà la stessa cosa con il metodo <code>values()</code>.
<li>Python 3 non supporta più il metodo <code>iterkeys()</code> Usate <code>keys()</code>, e se necessario, convertite la vista in un iteratore con la funzione <code>iter()</code>.
<li><code>2to3</code> riconosce quando il metodo <code>iterkeys()</code> viene usato in una <span class=wtf>list comprehension</span>, e lo converte al metodo <code>keys()</code> (senza circondarlo in una chiamata extra a <code>iter()</code>). Questo funziona perché le viste sono iterabili.
<li><code>2to3</code> riconosce che il metodo <code>keys()</code> è immediatamente passato a una funzione che itera su una intera sequenza, così non c'è bisogno di convertire prima il valore di ritorno a una lista. La funzione <code>min()</code> itererà allegramente attraverso la vista. Questo si applica alle funzioni <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>list()</code>, <code>tuple()</code>, <code>set()</code>, <code>sorted()</code>, <code>any()</code>, e <code>all()</code>.
</ol>
<h2 id=imports>Moduli che sono stati rinominati o riorganizzati</h2>
<p>Diversi moduli nella libreria standard di Python sono stati rinominati. Diversi altri moduli in relazione tra loro sono stati combinati o riorganizzati per rendere le loro associazioni più logiche.
<h3 id=http><code>http</code></h3>
<p>In Python 3, molti moduli relativi al protocollo <abbr>HTTP</abbr> sono stati combinati in un unico pacchetto, <code>http</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>import httplib</code></td>
<td><code>import http.client</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>import Cookie</code></td>
<td><code>import http.cookies</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>import cookielib</code></td>
<td><code>import http.cookiejar</code></td></tr>
<tr><th>&#x2463;</th>
<td><pre><code>import BaseHTTPServer
import SimpleHTTPServer
import CGIHttpServer</code></pre></td>
<td><code>import http.server</code></td></tr>
</table>
<ol>
<li>Il modulo <code>http.client</code> implementa una libreria di basso livello che può richiedere risorse <abbr>HTTP</abbr> e interpretare le risposte <abbr>HTTP</abbr>.
<li>Il modulo <code>http.cookies</code> fornisce una interfaccia Python ai cookie che sono inviati a un browser tramite l'intestazione <abbr>HTTP</abbr> <code>Set-Cookie:</code>.
<li>Il modulo <code>http.cookiejar</code> manipola i file effettivi che i browser web più popolari usano per memorizzare i cookie.
<li>Il modulo <code>http.server</code> fornisce un server <abbr>HTTP</abbr> di base.
</ol>
<h3 id=urllib><code>urllib</code></h3>
<p>Python 2 aveva una <span class=wtf>rat's nest</span> di moduli sovrapposti per riconoscere, codificare, e recuperare gli <abbr>URL</abbr>. In Python 3, tutti questi metodi sono stati fattorizzati e combinati in un singolo pacchetto, <code>urllib</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>import urllib</code></td>
<td><code>import urllib.request, urllib.parse, urllib.error</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>import urllib2</code></td>
<td><code>import urllib.request, urllib.error</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>import urlparse</code></td>
<td><code>import urllib.parse</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>import robotparser</code></td>
<td><code>import urllib.robotparser</code></td></tr>
<tr><th>&#x2464;</th>
<td><pre><code>from urllib import FancyURLopener
from urllib import urlencode</code></pre></td>
<td><pre><code>from urllib.request import FancyURLopener
from urllib.parse import urlencode</code></pre></td></tr>
<tr><th>&#x2465;</th>
<td><pre><code>from urllib2 import Request
from urllib2 import HTTPError</code></pre></td>
<td><pre><code>from urllib.request import Request
from urllib.error import HTTPError</code></pre></td></tr>
</table>
<ol>
<li>Il vecchio modulo <code>urllib</code> di Python 2 aveva una varietà di funzioni, comprese <code>urlopen()</code> per recuperare dati e <code>splittype()</code>, <code>splithost()</code>, e <code>splituser()</code> per dividere un <abbr>URL</abbr> nelle sue parti costituenti. Queste funzioni sono state riorganizzate più logicamente nell'ambito del nuovo pacchetto <code>urllib</code>. <code>2to3</code> cambierà anche tutte le chiamate a queste funzioni in modo da usare il nuovo schema di nomi.
<li>Il vecchio modulo <code>urllib2</code> di Python 2 è stato ripiegato nel pacchetto <code>urllib</code> in Python 3. Tutte le vostre funzionalità preferite di <code>urllib2</code> &mdash; il metodo <code>build_opener()</code> method, gli oggetti <code>Request</code>, e <code>HTTPBasicAuthHandler</code> e compagnia &mdash; sono ancora disponibili.
<li>Il modulo <code>urllib.parse</code> di Python 3 contiene tutte le funzioni di riconoscimento del vecchio modulo <code>urlparse</code> di Python 2.
<li>Il modulo <code>urllib.robotparser</code> riconosce i <a href=http://www.robotstxt.org/>file <code>robots.txt</code></a>.
<li>La classe <code>FancyURLopener</code>, che gestisce le redirezioni <abbr>HTTP</abbr> e altri codici di stato, è ancora disponibile nel nuovo modulo <code>urllib.request</code>. La funzione <code>urlencode()</code> è stata spostata in <code>urllib.parse</code>.
<li>L'oggetto <code>Request</code> è ancora disponibile in <code>urllib.request</code>, ma costanti come <code>HTTPError</code> sono state spostate in <code>urllib.error</code>.
</ol>
<h3 id=dbm><code>dbm</code></h3>
<p>Tutti i vari cloni di <abbr>DBM</abbr> si trovano ora in un singolo pacchetto, <code>dbm</code>. Se avete bisogno di una specifica variante come <abbr>GNU</abbr> <abbr>DBM</abbr>, potete importare il modulo appropriate nell'ambito del pacchetto <code>dbm</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>import dbm</code></td>
<td><code>import dbm.ndbm</code></td></tr>
<tr><th></th>
<td><code>import gdbm</code></td>
<td><code>import dbm.gnu</code></td></tr>
<tr><th></th>
<td><code>import dbhash</code></td>
<td><code>import dbm.bsd</code></td></tr>
<tr><th></th>
<td><code>import dumbdbm</code></td>
<td><code>import dbm.dumb</code></td></tr>
<tr><th></th>
<td><pre><code>import anydbm
import whichdb</code></pre></td>
<td><code>import dbm</code></td></tr>
</table>
<h3 id=xmlrpc><code>xmlrpc</code></h3>
<p><abbr>XML-RPC</abbr> è un metodo leggero per eseguire chiamate <abbr>RPC</abbr> remote su <abbr>HTTP</abbr>. La libreria client di <abbr>XML-RPC</abbr> e diverse implementazioni di server <abbr>XML-RPC</abbr> sono ora combinate in un singolo pacchetto, <code>xmlrpc</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>import xmlrpclib</code></td>
<td><code>import xmlrpc.client</code></td></tr>
<tr><th></th>
<td><pre><code>import DocXMLRPCServer
import SimpleXMLRPCServer</code></pre></td>
<td><code>import xmlrpc.server</code></td></tr>
</table>
<h3 id=othermodules>Altri moduli</h3>
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><pre><code>try:
    import cStringIO as StringIO
except ImportError:
    import StringIO</code></pre></td>
<td><code>import io</code></td></tr>
<tr><th>&#x2461;</th>
<td><pre><code>try:
    import cPickle as pickle
except ImportError:
    import pickle</code></pre></td>
<td><code>import pickle</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>import __builtin__</code></td>
<td><code>import builtins</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>import copy_reg</code></td>
<td><code>import copyreg</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>import Queue</code></td>
<td><code>import queue</code></td></tr>
<tr><th>&#x2465;</th>
<td><code>import SocketServer</code></td>
<td><code>import socketserver</code></td></tr>
<tr><th>&#x2466;</th>
<td><code>import ConfigParser</code></td>
<td><code>import configparser</code></td></tr>
<tr><th>&#x2467;</th>
<td><code>import repr</code></td>
<td><code>import reprlib</code></td></tr>
<tr><th>&#x2468;</th>
<td><code>import commands</code></td>
<td><code>import subprocess</code></td></tr>
</table>
<ol>
<li>Un idioma comune in Python 2 era quello di importare <code>cStringIO as StringIO</code>, e se questo falliva, importare <code>StringIO</code> al suo posto. Non fatelo in Python 3; il modulo <code>io</code> lo fa per voi. Troverà l'implementazione più veloce disponibile e la utilizzerà automaticamente.
<li>Un simile idioma veniva usato per importare l'implementazione di <span class=wtf>pickle</span> più veloce. Non fatelo in Python 3; il modulo <code>pickle</code> lo fa per voi.
<li>Il modulo <code>builtins</code> contiene le funzioni globali, le classi e le costanti usate in tutto il linguaggio Python. Ridefinire un funzione nel modulo <code>builtins</code> ridefinirà la funzione globale ovunque. Questo è esattamente tanto potente e spaventoso quanto sembra.
<li>Il modulo <code>copyreg</code> aggiunge il supporto per pickle ai tipi personalizzati definiti in C.
<li>Il modulo <code>queue</code> implementa una coda con supporto per produttori e consumatori multipli.
<li>Il modulo <code>socketserver</code> fornisce classi basi generiche per implementare differenti tipi di server per le socket.
<li>Il modulo <code>configparser</code> riconosce i file di configurazione sullo stile dei file <abbr>INI</abbr>.
<li>Il modulo <code>reprlib</code> reimplementa la funzione built-in <code>repr()</code>, introducendo dei limiti su quanti valori sono rappresentati.
<li>Il modulo <code>subprocess</code> vi permette di creare processi, connetterli alle loro pipe, e ottenere i loro codici di ritorno.
</ol>
<h2 id=import>Importazioni relative nell'ambito di un pacchetto</h2>
<p>Un pacchetto è un gruppo di moduli correlati che funziona come una singola entità. In Python 2, quando i moduli all'interno di un pacchetto devono fare riferimento gli uni agli altri, si usa l'idioma <code>import foo</code> oppure <code>from foo import Bar</code>. L'interprete Python 2 prima cerca nell'ambito del pacchetto corrente per trovare <code>foo.py</code>, e poi si sposta nelle altre directory contenute nel percorso di ricerca di Python (<code>sys.path</code>). Python 3 funziona in modo leggermente diverso. Invece di cercare nel pacchetto corrente, si sposta direttamente al percorso di ricerca di Python. Se volete che un modulo in un pacchetto importi un altro modulo nello stesso pacchetto, dovete esplicitamente fornire il percorso relativo tra i due moduli.
<p>Supponete di avere questo pacchetto, con più file nella stessa directory:
<pre>chardet/
|
+--__init__.py
|
+--constants.py
|
+--mbcharsetprober.py
|
+--universaldetector.py</pre>
<p>Ora supponete che <code>universaldetector.py</code> abbia bisogno di importare l'intero file <code>constants.py</code> e una classe da <code>mbcharsetprober.py</code>. Come fareste?
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>import constants</code></td>
<td><code>from . import constants</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>from mbcharsetprober import MultiByteCharSetProber</code></td>
<td><code>from .mbcharsetprober import MultiByteCharsetProber</code></td></tr>
</table>
<ol>
<li>Quando dovete importare un intero modulo da qualche parte nel vostro pacchetto, usate la nuova sintassi <code>from . import</code>. Il punto è in realtà il percorso relativo da questo file (<code>universaldetector.py</code>) al file che volete importare (<code>constants.py</code>). In questo caso, sono nella stessa directory, quindi è sufficiente un singolo punto. Potete anche importare dalla directory genitore (<code>from .. import anothermodule</code>) o da una sottodirectory.
<li>Per importare una specifica classe o funzione da un altro modulo direttamente nello spazio di nomi del vostro modulo, prefissate il modulo obiettivo con un percorso relativo, meno lo slash finale. In questo caso, <code>mbcharsetprober.py</code> è nella stessa directory di <code>universaldetector.py</code>, quindi il percorso è un singolo punto. Potete anche importare dalla directory genitore (<code>from ..anothermodule import AnotherClass</code>) o da una sottodirectory.
</ol>
<h2 id=next>Il metodo <code>next()</code> degli iteratori</h2>
<p>In Python 2, gli iteratori hanno un metodo <code>next()</code> che restituisce l'elemento successivo nella sequenza. Questo è ancora vero in Python 3, ma c'è anche una funzione globale <code>next()</code> che prende un iteratore come argomento.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>anIterator.next()</code></td>
<td><code>next(anIterator)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_function_that_returns_an_iterator().next()</code></td>
<td><code>next(a_function_that_returns_an_iterator())</code></td></tr>
<tr><th>&#x2462;</th>
<td><pre><code>class A:
    def next(self):
        pass</code></pre></td>
<td><pre><code>class A:
    def __next__(self):
        pass</code></pre></td></tr>
<tr><th>&#x2463;</th>
<td><pre><code>class A:
    def next(self, x, y):
        pass</code></pre></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2464;</th>
<td><pre><code>next = 42
for an_iterator in a_sequence_of_iterators:
    an_iterator.next()</code></pre></td>
<td><pre><code>next = 42
for an_iterator in a_sequence_of_iterators:
    an_iterator.__next__()</code></pre></td></tr>
</table>
<ol>
<li>Nel caso più semplice, invece di chiamare il metodo <code>next()</code> di un iteratore, ora passate l'iteratore stesso alla funzione globale <code>next()</code>.
<li>Se avete una funzione che restituisce un iteratore, chiamate la funzione e passate il risultato alla funzione <code>next(). (Lo script <code>2to3</code> è abbastanza intelligente da convertire questo in maniera appropriata.)
<li>Se definite la vostra classe e volete usarla come un iteratore, definite il metodo speciale <code>__next__()</code>.
<li>Se definite la vostra classe e vi capita che abbia un metodo chiamato <code>next()</code> che prende uno o più argomenti, <code>2to3</code> non lo toccherà. Questa classe non può essere usata come un iteratore, perché il suo metodo <code>next()</code> accetta degli argomenti.
<li>Questo è un po' complicato. Se avete una variabile locale chiamata <var>next</var>, allora essa ha precedenza sulla funzione globale <code>next()</code>. In questo caso, dovete chiamare il metodo speciale <code>__next__()</code> dell'iteratore per ottenere l'elemento successivo nella sequenza. (Alternativamente, potreste anche modificare il codice in modo che la variabile locale non sia più chiamata <var>next</var>, ma <code>2to3</code> non lo farà automaticamente per voi.)
</ol>
<h2 id=filter>La funzione globale <code>filter()</code></h2>
<p>In Python 2, la funzione <code>filter()</code> restituiva una lista, il risultato di filtrare una sequenza attraverso una funzione che restituiva <code>True</code> o <code>False</code> per ogni elemento della sequenza. In Python 3, la funzione <code>filter()</code> restituisce un iteratore, non una lista.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>filter(a_function, a_sequence)</code></td>
<td><code>list(filter(a_function, a_sequence))</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>list(filter(a_function, a_sequence))</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2462;</th>
<td><code>filter(None, a_sequence)</code></td>
<td><code>[i for i in a_sequence if i]</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>for i in filter(None, a_sequence):</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2464;</th>
<td><code>[i for i in filter(a_function, a_sequence)]</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Nel caso più basilare, <code>2to3</code> circonderà la chiamata a <code>filter()</code> con una chiamata a <code>list()</code>, che semplicemente itera attraverso il suo argomento e restituisce una vera lista.
<li>Comunque, se la chiamata a <code>filter()</code> è <em>già</em> circondata da <code>list()</code>, <code>2to3</code> non farà nulla, dato che il fatto che <code>filter()</code> restituisca un iteratore è irrilevante.
<li>Per la sintassi speciale di <code>filter(None, ...)</code>, <code>2to3</code> trasformerà la chiamata in una <span class=wtf>list comprehension</span> semanticamente equivalente.
<li>In contesti come i cicli <code>for</code>, che iterano comunque attraverso l'intera sequenza, non sono necessari cambiamenti.
<li>Ancora, non sono necessari cambiamenti, perché la <span class=wtf>list comprehension</span> itererà attraverso l'intera sequenza, e lo può fare altrettanto bene sia che <code>filter()</code> restituisca un iteratore sia che restituisca una lista.
</ol>
<h2 id=map>La funzione globale <code>map()</code></h2>
<p>In maniera molto simile a <a href=#filter><code>filter()</code></a>, la funzione <code>map()</code> ora restituisce un iteratore. (In Python 2, restituiva una lista.)
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>map(a_function, 'PapayaWhip')</code></td>
<td><code>list(map(a_function, 'PapayaWhip'))</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>map(None, 'PapayaWhip')</code></td>
<td><code>list('PapayaWhip')</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>map(lambda x: x+1, range(42))</code></td>
<td><code>[x+1 for x in range(42)]</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>for i in map(a_function, a_sequence):</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2464;</th>
<td><code>[i for i in map(a_function, a_sequence)]</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Come con <code>filter()</code>, nel caso più basilare, <code>2to3</code> circonderà la chiamata a <code>map()</code> con una chiamata a <code>list()</code>.
<li>Per la sintassi speciale di <code>map(None, ...)</code>, la funzione identità, <code>2to3</code> la convertirà in una equivalente chiamata a <code>list()</code>.
<li>Se il primo argomento di <code>map()</code> è una funzine lambda, <code>2to3</code> la convertirà in una <span class=wtf>list comprehension</span> semanticamente equivalente.
<li>In contesti come i cicli <code>for</code>, che iterano comunque attraverso l'intera sequenza, non sono necessari cambiamenti.
<li>Ancora, non sono necessari cambiamenti, perché la <span class=wtf>list comprehension</span> itererà attraverso l'intera sequenza, e lo può fare altrettanto bene sia che <code>map()</code> restituisca un iteratore sia che restituisca una lista.
</ol>
<h2 id=reduce>La funzione globale <code>reduce()</code> (3.1+)</h2>
<p>In Python 3, la funzione <code>reduce()</code> è stata rimossa dallo spazio di nomi globale e piazzata nel modulo <code>functools</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>reduce(a, b, c)</code></td>
<td><pre><code>from functtools import reduce
reduce(a, b, c)</code></pre></td></tr>
</table>
<blockquote>
<p><span>&#x261E;</span>La versione di <code>2to3</code> rilasciata con Python 3.0 non correggerà la funzione <code>reduce()</code> automaticamente. La correzione è apparsa per la prima volta nello script <code>2to3</code> che verrà rilasciato con Python 3.1.
</blockquote>
<h2 id=apply>La funzione globale <code>apply()</code></h2>
<p>Python 2 ha una funzione globale chiamata <code>apply()</code>, che prende una funzione <var>f</var> e una lista <code>[a, b, c]</code> e restituisce <code>f(a, b, c)</code>. In Python 3, la funzione <code>apply()</code> non esiste più. Al suo posto, c'è una nuova sintassi per la chiamata a funzione che vi permette di passare una lista e avere Python che applica la lista come gli argomenti della funzione.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>apply(a_function, a_list_of_args)</code></td>
<td><code>a_function(*a_list_of_args)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>apply(a_function, a_list_of_args, a_dictionary_of_named_args)</code></td>
<td><code>a_function(*a_list_of_args, **a_dictionary_of_named_args)</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>apply(a_function, a_list_of_args + z)</code></td>
<td><code>a_function(*a_list_of_args + z)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>apply(aModule.a_function, a_list_of_args)</code></td>
<td><code>aModule.a_function(*a_list_of_args)</code></td></tr>
</table>
<ol>
<li>Nella forma più semplice, potete chiamare una funzione con una lista di argomenti (una lista reale come <code>[a, b, c]</code>) facendo precedere la lista da un asterisco (<code>*</code>). Questo è esattamente equivalente alla vecchia funzione <code>apply()</code> di Python 2.
<li>In Python 2, la funzione <code>apply()</code> poteva in realtà accettare tre parametri: una funzione, una lista di argomenti, e un dizionario di argomenti con nomi. In Python 3, potete ottenere la stessa cosa facendo precedere la lista di argomenti da un asterisco (<code>*</code>) e il dizionario di argomenti con nomi da due asterischi (<code>**</code>).
<li>L'operatore <code>+</code>, usato qui per concatenare liste, ha precedenza sull'operatore <code>*</code>, quindi non c'è bisogno di parentesi aggiuntive attorno a <code>a_list_of_args + z</code>.
<li>Lo script <code>2to3</code> è abbastanza scaltro da convertire chiamate complesse ad <code>apply()</code>, comprese chiamate a funzioni contenute in moduli importati.
</ol>
<h2 id=intern>La funzione globale <code>intern()</code></h2>
<p>In Python 2, potete chiamare la funzione <code>intern()</code> su una stringa per <span class=wtf>intern</span>arla come una ottimizzazione delle prestazioni. In Python 3, la funzione <code>intern()</code> è stata spostata nel modulo <code>sys</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>intern(aString)</code></td>
<td><code>sys.intern(aString)</code></td></tr>
</table>
<h2 id=exec>L'istruzione <code>exec</code></h2>
<p>Esattamente come <a href=#print>l'istruzione <code>print</code></a> è diventata una funzione in Python 3, così è successo anche all'istruzione <code>exec</code>. La funzione <code>exec()</code> prende una stringa che contiene codice Python arbitrario e la esegue come se fosse solo un'altra istruzione o espressione.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>exec codeString</code></td>
<td><code>exec(codeString)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>exec codeString in a_global_namespace</code></td>
<td><code>exec(codeString, a_global_namespace)</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>exec codeString in a_global_namespace, a_local_namespace</code></td>
<td><code>exec(codeString, a_global_namespace, a_local_namespace)</code></td></tr>
</table>
<ol>
<li>Nella sua forma più semplice, lo script <code>2to3</code> racchiude semplicemente tra parentesi il codice sotto forma di stringa, dato che <code>exec()</code> è ora una funzione invece di una istruzione.
<li>La vecchia istruzione <code>exec</code> poteva prendere uno spazio di nomi, un ambiente privato di nomi globali in cui il codice sotto forma di stringa sarebbe stato eseguito. Anche Python 3 può farlo; basta passare lo spazio di nomi come secondo argomento alla funzione <code>exec()</code>.
<li>In maniera ancora più elaborata, la vecchia istruzione <code>exec</code> poteva anche prendere uno spazio di nomi locali (come le variabili definite nell'ambito di una funzione). In Python 3, la funzione <code>exec()</code> può fare anche questo.
</ol>
<h2 id=execfile>L'istruzione <code>execfile</code> (3.1+)</h2>
<p>Come la vecchia <a href=#exec>istruzione <code>exec</code></a>, la vecchia istruzione <code>execfile</code> esegue stringhe come se fossero codice Python. Laddove <code>exec</code> prendeva una stringa, <code>execfile</code> prende un nome di file. In Python 3, l'istruzione <code>execfile</code> è stata eliminata. Se avete davvero bisogno di prendere un file di codice Python e di eseguirlo (ma non siete disposti semplicemente a importarlo), potete ottenere lo stesso effetto aprendo il file, leggendone il contenuto, chiamando la funzione globale <code>compile()</code> per obbligare l'interprete Python a compilare il codice, e poi chiamare la nuova funzione <code>exec()</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>execfile("a_filename")</code></td>
<td><code>exec(compile(open("a_filename").read(), "a_filename", "exec"))</code></td></tr>
</table>
<blockquote>
<p><span>&#x261E;</span>La versione di 2to3 rilasciata con Python 3.0 non corregge l'istruzione <code>execfile</code> automaticamente. La correzione è apparsa per la prima volta nello script <code>2to3</code> che verrà rilasciato con Python 3.1.
</blockquote>
<h2 id=repr>I letterali <code>repr</code> (i backtick)</h2>
<p>In Python 2, c'era una speciale sintassi per racchiudere qualsiasi oggetto tra <span class=wtf>backticks</span> (come <code>`x`</code>) per ottenere una rappresentazione di quell'oggetto. In Python 3, questa possibilità esiste ancora, ma non potete più usare i <span class=wtf>backtick</span> per averla. Invece, usate la funzione globale <code>repr()</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>`x`</code></td>
<td><code>repr(x)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>`"PapayaWhip" + `2``</code></td>
<td><code>repr("PapayaWhip" + repr(2))</code></td></tr>
</table>
<ol>
<li>Ricordate, <var>x</var> può essere qualsiasi cosa &mdash; una class, una funzione, un modulo, un tipo di dati primitivi, etc. La funzione <code>repr()</code> lavora su tutto.
<li>In Python 2, i backtick potevano essere annidati, producendo questo tipo di espressioni confuse (ma valide). Lo strumento <code>2to3</code> è abbastanza scaltro da convertire questo in chiamate annidate a <code>repr()</code>.
</ol>
<h2 id=except>L'istruzione <code>try...except</code></h2>
<p>La sintassi per catturare le eccezioni è leggermente cambiata tra Python 2 e Python 3.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><pre><code>try:
    import mymodule
except ImportError, e
    pass</code></pre></td>
<td><pre><code>try:
    import mymodule
except ImportError as e:
    pass</code></pre></td></tr>
<tr><th>&#x2461;</th>
<td><pre><code>try:
    import mymodule
except (RuntimeError, ImportError), e
    pass</code></pre></td>
<td><pre><code>try:
    import mymodule
except (RuntimeError, ImportError) as e:
    pass</code></pre></td></tr>
<tr><th>&#x2462;</th>
<td><pre><code>try:
    import mymodule
except ImportError:
    pass</code></pre></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2463;</th>
<td><pre><code>try:
    import mymodule
except:
    pass</code></pre></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Invece di una virgola dopo il tipo della eccezione, Python 3 usa una nuova parola chiave, <code>as</code>.
<li>La parola chiave <code>as</code> funziona anche per catturare più tipi di eccezioni alla volta.
<li>Se catturate una eccezione ma in realtà non vi interessa accedere all'oggetto eccezione di per sé, la sintassi è identica tra Python 2 e Python 3.
<li>Similmente, se usate un <span class=wtf>fallback</span> per catturare <em>tutte</em> le eccezioni, la sintassi è identica.
</ol>
<blockquote class=note>
<p><span>&#x261E;</span>Non dovreste mai usare un <span class=wtf>fallback</span> per catturare <em>tutte</em> le eccezioni quando importate moduli (o nella maggior parte delle altre occasioni). Fare così catturerà cose come <code>KeyboardInterrupt</code> (se l'utente ha premuto <kbd>Ctrl-C</kbd> per interrompere il programma) è può rendere molto più difficile il debug degli errori.
</blockquote>
<h2 id=raise>L'istruzione <code>raise</code></h2>
<p>La sintassi per sollevare le vostre eccezioni è leggermente cambiata tra Python 2 e Python 3.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>raise MyException</code></td>
<td><i>unchanged</i></td></tr>
<tr><th>&#x2461;</th>
<td><code>raise MyException, "error message"</code></td>
<td><code>raise MyException("error message")</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>raise MyException, "error message", a_traceback</code></td>
<td><code>raise MyException("error message").with_traceback(a_traceback)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>raise "error message"</code></td>
<td><i>unsupported</i></td></tr>
</table>
<ol>
<li>Nella sua forma più semplice, sollevare una eccezione senza un messaggio personalizzato, la sintassi è rimasta invariata.
<li>Il cambiamento si nota quando volete sollevare una eccezione con un messaggio personalizzato. Python 2 separava la classe della eccezione e il messaggio con una virgola; Python 3 passa il messaggio di errore come un parametro.
<li>Python 2 supportava una sintassi più complessa per sollevare una eccezione con un <span class=wtf>traceback</span> (la traccia dello stack di esecuzione) personalizzato. Potete farlo anche in Python 3, ma la sintassi è abbastanza differente.
<li>In Python 2, potevate sollevare una eccezione senza alcuna classe, semplicemente un messaggio di errore. In Python 3, questo non è più possibile. <code>2to3</code> vi avvertirà che non è in grado di correggere questo automaticamente.
</ol>
<h2 id=throw>Il metodo <code>throw</code> dei generatori</h2>
<p>In Python 2, i generatori hanno un metodo <code>throw()</code>. Chiamare <code>a_generator.throw()</code> solleva una eccezione nel punto in cui il generatore è stato sospeso, poi restituisce il valore successivo prodotto dalla funzione generatrice. In Python 3 questa funzionalità è ancora disponibile, ma la sintassi è leggermente diversa.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>a_generator.throw(MyException)</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_generator.throw(MyException, "error message")</code></td>
<td><code>a_generator.throw(MyException("error message"))</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>a_generator.throw("error message")</code></td>
<td><i>unsupported</i></td></tr>
</table>
<ol>
<li>Nella sua forma più semplice, un generatore lancia una eccezione senza un messaggio di errore personalizzato. In questo caso, la sintassi non è cambiata nel passaggio da Python 2 a Python 3.
<li>Se il generatore lancia una eccezione <em>con</em> un messaggio di errore personalizzato, dovete passare la stringa di errore all'eccezione quando la create.
<li>Python 2 supportava anche il lancio di una eccezione con <em>solo</em> un messaggio di errore personalizzato. Python 3 non supporta questo, e lo script <code>2to3</code> visualizzerà un avvertimento dicendovi che avrete bisogno di correggere manualmente questo codice.
</ol>
<h2 id=xrange>La funzione globale <code>xrange()</code></h2>
<p>In Python 2, c'erano due modi per ottenere una lista di numeri: <code>range()</code>, che restituiva una lista, e <code>xrange()</code>, che restituiva un iteratore. In Python 3, <code>range()</code> restituisce un iteratore, e <code>xrange()</code> non esiste più.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>xrange(10)</code></td>
<td><code>range(10)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_list = range(10)</code></td>
<td><code>a_list = list(range(10))</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>[i for i in xrange(10)]</code></td>
<td><code>[i for i in range(10)]</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>for i in range(10):</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2464;</th>
<td><code>sum(range(10))</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Nel caso più semplice, lo script <code>2to3</code> semplicemente convertirà <code>xrange()</code> in <code>range()</code>.
<li>Se il vostro codice in Python 2 usava <code>range()</code>, lo script <code>2to3</code> non sa se avete bisogno di una lista, o se un iteratore potrebbe bastare. Pecca per eccesso di prudenza e forza il valore di ritorno a una lista chiamando la funzione <code>list()</code>.
<li>Se la funzione <code>xrange()</code> è in una <span class=wtf>list comprehension</span>, non c'è bisogno di forzare il risultato a una lista, perché la <span class=wtf>list comprehension</span> lavora altrettanto bene con un iteratore.
<li>Similmente, un ciclo <code>for</code> lavora altrettanto bene con un iteratore, quindi non c'è bisogno di cambiare nulla qui.
<li>Anche la funzione <code>sum()</code> lavora altrettanto bene con un iteratore, quindi <code>2to3</code> non effettua alcun cambiamento neanche qui. Come per <a href=#dict>i metodi dei dizionari che restituiscono viste invece di liste</a>, questo si applica a <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>list()</code>, <code>tuple()</code>, <code>set()</code>, <code>sorted()</code>, <code>any()</code>, e <code>all()</code>.
</ol>
<h2 id=raw_input>Le funzioni globali <code>raw_input()</code> e <code>input()</code></h2>
<p>Python 2 aveva due funzioni globali per chiedere all'utente un input dalla linea di comando. La prima, chiamata <code>input()</code>, si aspettava che l'utente inserisse una espressione Python (e ne restituiva il risultato). La seconda, chiamata <code>raw_input()</code>, semplicemente restituiva qualsiasi cosa l'utente avesse digitato. Questo era selvaggiamente confuso per i principianti e largamente considerato come un &#8220;neo&#8221; nel linguaggio. Python 3 asporta questo neo rinominando <code>raw_input()</code> a <code>input()</code>, in modo che funzioni nel modo in cui ognuno si aspetta ingenuamente che funzioni.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>raw_input()</code></td>
<td><code>input()</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>raw_input("prompt")</code></td>
<td><code>input("prompt")</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>input()</code></td>
<td><code>eval(input())</code></td></tr>
</table>
<ol>
<li>Nella sua forma più semplice, <code>raw_input()</code> diventa <code>input()</code>.
<li>In Python 2, la funzione <code>raw_input()</code> poteva prendere un prompt come parametro. Questo è stato mantenuto in Python 3.
<li>Se avete effettivamente bisogno di chiedere all'utente una espressione Python da valutare, usate la funzione <code>input()</code> e passatene il risultato a <code>eval()</code>.
</ol>
<h2 id=funcattrs>Le proprietà <code>func_*</code> delle funzioni</h2>
<p>In Python 2, il codice all'interno delle funzioni può accedere a speciali proprietà della funzione stessa. In Python 3, queste proprietà speciali di una funzione sono state rinominate per renderle consistenti con altre proprietà.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>a_function.func_name</code></td>
<td><code>a_function.__name__</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_function.func_doc</code></td>
<td><code>a_function.__doc__</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>a_function.func_defaults</code></td>
<td><code>a_function.__defaults__</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>a_function.func_dict</code></td>
<td><code>a_function.__dict__</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>a_function.func_closure</code></td>
<td><code>a_function.__closure__</code></td></tr>
<tr><th>&#x2465;</th>
<td><code>a_function.func_globals</code></td>
<td><code>a_function.__globals__</code></td></tr>
<tr><th>&#x2466;</th>
<td><code>a_function.func_code</code></td>
<td><code>a_function.__code__</code></td></tr>
</table>
<ol>
<li>La proprietà <code>__name__</code> (precedentemente <code>func_name</code>) contiene il nome della funzione.
<li>La proprietà <code>__doc__</code> (precedentemente <code>func_doc</code>) contiene la <i>docstring</i> che avete definito nel codice sorgente della funzione.
<li>La proprietà <code>__defaults__</code> (precedentemente <code>func_defaults</code>) è una tupla contenente i valori di default degli argomenti per quegli argomenti che hanno un valore di default.
<li>La proprietà <code>__dict__</code> (precedentemente <code>func_dict</code>) è lo spazio di nomi che supporta la gestione di proprietà arbitrarie per la funzione.
<li>La proprietà <code>__closure__</code> (precedentemente <code>func_closure</code>) è una tupla di celle che contengono i legami per le variabili libere della funzione.
<li>La proprietà <code>__globals__</code> (precedentemente <code>func_globals</code>) è un riferimento allo spazio di nomi globale del modulo in cui la funzione è stata definita.
<li>La proprietà <code>__code__</code> (precedentemente <code>func_code</code>) è un oggetto codice che rappresenta il corpo della funzione compilata.
</ol>
<h2 id=xreadlines>Il metodo di I/O <code>xreadlines()</code></h2>
<p>In Python 2, gli oggetti file avevano un metodo <code>xreadlines()</code> che restituiva un iteratore per leggere il file una riga alla volta. Questo era utile nei cicli <code>for</code>, insieme ad altri posti. In effetti, era così utile che le ultime versioni di Python 2 hanno aggiunto questa capacità agli oggetti file stessi.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>for line in a_file.xreadlines():</code></td>
<td><code>for line in a_file:</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>for line in a_file.xreadlines(5):</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Se eravate soliti chiamare <code>xreadlines()</code> senza argomenti, <code>2to3</code> la convertirà solo all'oggetto file. In Python 3, questo fa compiere la stessa cosa: leggere il file una riga alla volta ed eseguire il corpo del ciclo <code>for</code>.
<li>Se eravate soliti chiamare <code>xreadlines()</code> con un argomento (il numero di righe da leggere alla volta), continuate a farlo. Funziona ancora in Python 3, e <code>2to3</code> non lo cambierà.
</ol>
<p class=c><span style="font-size:56px;line-height:0.88">&#x2603;</span>
<h2 id=tuple_params>Funzioni <code>lambda</code> che accettano una tupla invece di parametri multipli</h2>
<p>In Python 2, potevate definire funzioni <code>lambda</code> anonime che accettavano parametri multipli definendola in modo che accettasse una tupla con uno specifico numero di elementi. In effetti, Python 2 avrebbe &#8220;spacchettato&#8221; la tupla negli argomenti con nome, che poi avreste potuto riferire (attraverso il nome) all'interno dalla funzione <code>lambda</code>. In Python 3, potete ancora passare una tupla a una funzione <code>lambda</code>, ma l'interprete Python non spacchetterà la tupla in argomenti con nome. Invece, dovrete riferirvi ad ogni argomento tramite l'indice della sua posizione.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>lambda (x,): x + f(x)</code></td>
<td><code>lambda x1: x1[0] + f(x1[0])</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>lambda (x, y): x + f(y)</code></td>
<td><code>lambda x_y: x_y[0] + f(x_y[1])</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>lambda (x, (y, z)): x + y + z</code></td>
<td><code>lambda x_y_z: x_y_z[0] + x_y_z[1][0] + x_y_z[1][1]</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>lambda x, y, z: x + y + z</code></td>
<td><i>unchanged</i></td></tr>
</table>
<ol>
<li>Se avete definito una funzione <code>lambda</code> che accetta una tupla composta da un elemento, in Python 3 questa diventerebbe una <code>lambda</code> con riferimenti a <var>x1[0]</var>. Il nome <var>x1</var> viene generato automaticamente dallo script <code>2to3</code>, sulla base degli argomenti con nome nella tupla originale.
<li>Una funzione <code>lambda</code> con una tupla <var>(x, y)</var> di due elementi viene convertita a <var>x_y</var> con argomenti posizionali <var>x_y[0]</var> e <var>x_y[1]</var>.
<li>Lo script <code>2to3</code> può perfino gestire funzioni <code>lambda</code> con tuple innestate di argomenti con nome. Il codice Python 3 risultante è leggermente illeggibile, ma funziona allo stesso modo in cui funzionava in Python 2.
<li>Potete definire funzioni <code>lambda</code> che accettano più argomenti. Senza parentesi attorno agli argomenti, Python 2 la tratta semplicemente come una funzione <code>lambda</code> con argomenti multipli; all'interno della funzione <code>lambda</code>, fate semplicemente riferimento agli argomenti tramite il loro nome, esattamente come avviene per ogni altra funzione. Questa sintassi funziona ancora in Python 3.
</ol>
<h2 id=methodattrs>Proprietà speciali dei metodi</h2>
<p>In Python 2, i metodi di classe possono riferirsi all'oggetto classe in cui sono definiti, così come all'oggetto metodo stesso. <code>im_self</code> è l'istanza dell'oggetto classe; la classe <code>im_func</code> rappresenta l'oggetto funzione; <code>im_class</code> è la classe di <code>im_self</code> (per metodi legati) o la classe che ha chiesto quel metodo (per metodi non legati). In Python 3, queste proprietà speciali dei metodi sono state rinominate per seguire le convenzioni sui nomi delle altre proprietà.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>aClassInstance.aClassMethod.im_func</code></td>
<td><code>aClassInstance.aClassMethod.__func__</code></td></tr>
<tr><th></th>
<td><code>aClassInstance.aClassMethod.im_self</code></td>
<td><code>aClassInstance.aClassMethod.__self__</code></td></tr>
<tr><th></th>
<td><code>aClassInstance.aClassMethod.im_class</code></td>
<td><code>aClassInstance.aClassMethod.self.__class__</code></td></tr>
</table>
<h2 id=nonzero>La proprietà speciale <code>__nonzero__</code> delle classi</h2>
<p>In Python 2, potevate costruire una vostra classe che potesse essere usata in un contesto booleano. Per esempio, potevate istanziare la classe e poi usare l'istanza in una istruzione <code>if</code>. Per fare questo, definivate un metodo speciale <code>__nonzero__()</code> che restituiva <code>True</code> o <code>False</code>, e veniva chiamato ogni volta che l'istanza veniva usata in un contesto booleano. In Python 3 potete ancora farlo, ma il nome del metodo è stato cambiato in <code>__bool__()</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><pre><code>class A:
    def __nonzero__(self):
        pass</code></pre></td>
<td><pre><code>class A:
    def __bool__(self):
        pass</code></pre></td></tr>
<tr><th>&#x2461;</th>
<td><pre><code>class A:
    def __nonzero__(self, x, y):
        pass</code></pre></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Al posto di <code>__nonzero__()</code>, Python 3 chiama il metodo <code>__bool__()</code> per valutare una istanza in un contesto booleano.
<li>Comunque, se avete un metodo <code>__nonzero__()</code> che accetta argomenti, lo strumento <code>2to3</code> presumerà che lo steste usando per qualche altro scopo, e non effettuerà alcun cambiamento.
</ol>
<h2 id=numliterals>Letterali in base otto</h2>
<p>La sintassi per definire numeri in base 8 (ottali) è leggermente cambiata nel passaggio da Python 2 a Python 3.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>x = 0755</code></td>
<td><code>x = 0o755</code></td></tr>
</table>
<h2 id=renames><code>sys.maxint</code></h2>
<p>A causa della integrazione dei tipi <code>long</code> e <code>int</code>, la costante <code>sys.maxint</code> non è più accurata. Dato che il valore potrebbe ancora essere utile per determinare le capacità di una specifica piattaforma, è stata mantenuta ma rinominata in <code>sys.maxsize</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>from sys import maxint</code></td>
<td><code>from sys import maxsize</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_function(sys.maxint)</code></td>
<td><code>a_function(sys.maxsize)</code></td></tr>
</table>
<ol>
<li><code>maxint</code> diventa <code>maxsize</code>.
<li>Ogni uso di <code>sys.maxint</code> diventa <code>sys.maxsize</code>.
</ol>
<h2 id=callable>La funzione globale <code>callable()</code></h2>
<p>In Python 2, potevate contollare se un oggetto era chiamabile (come una funzione) con la funzione globale <code>callable()</code>. In Python 3, questa funzione globale è stata eliminata. Per controllare se un oggetto è invocabile, controllate l'esistenza del metodo speciale <code>__call__()</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>callable(anything)</code></td>
<td><code>hasattr(anything, "__call__")</code></td></tr>
</table>
<h2 id=zip>La funzione globale <code>zip()</code></h2>
<p>In Python 2, la funzione globale <code>zip()</code> prendeva un qualsiasi numero di sequenze e restituiva una lista di tuple. La prima tupla conteneva il primo elemento di ogni sequenza; la seconda tupla conteneva il secondo elemento di ogni sequenza; e così via. In Python 3, <code>zip()</code> restituisce un iteratore invece di una lista.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>zip(a, b, c)</code></td>
<td><code>list(zip(a, b, c))</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>d.join(zip(a, b, c))</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Nella forma più semplice, potete ottenere il vecchio comportamento della funzione <code>zip()</code> circondandone il valore di ritorno con una chiamata a <code>list()</code>, che correrà lungo l'iteratore che restituito da <code>zip()</code> e restituisce una lista reale dei risultati.
<li>In contesti che iterano già attraverso tutti gli elementi di una sequenza (come questa chiamata al metodo <code>join()</code>) l'iteratore che <code>zip()</code> restituisce funzionerà adeguatamente. Lo script <code>2to3</code> è abbastanza scaltro da riconoscere questi casi e non fare alcun cambiamento al vostro codice.
</ol>
<h2 id=standarderror>L'eccezione di tipo <code>StandardError</code></h2>
<p>In Python 2, <code>StandardError</code> era la classe base per tutte le eccezioni built-in tranne <code>StopIteration</code>, <code>GeneratorExit</code>, <code>KeyboardInterrupt</code>, e <code>SystemExit</code>. In Python 3, la classe <code>StandardError</code> è stata eliminata; usate <code>Exception</code> al suo posto.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>x = StandardError()</code></td>
<td><code>x = Exception()</code></td></tr>
<tr><th></th>
<td><code>x = StandardError(a, b, c)</code></td>
<td><code>x = Exception(a, b, c)</code></td></tr>
</table>
<h2 id=types>Le costanti del modulo <code>types</code></h2>
<p>Il modulo <code>types</code> contiene una varietà di costanti per aiutarvi a determinare il tipo di un oggetto. In Python 2, conteneva costanti per tutti i tipi primitivi come <code>dict</code> e <code>int</code>. In Python 3, queste constanti sono state eliminate; vi basta usare il nome del tipo primitivo.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>types.StringType</code></td>
<td><code>bytes</code></td></tr>
<tr><th></th>
<td><code>types.DictType</code></td>
<td><code>dict</code></td></tr>
<tr><th></th>
<td><code>types.IntType</code></td>
<td><code>int</code></td></tr>
<tr><th></th>
<td><code>types.LongType</code></td>
<td><code>int</code></td></tr>
<tr><th></th>
<td><code>types.ListType</code></td>
<td><code>list</code></td></tr>
<tr><th></th>
<td><code>types.NoneType</code></td>
<td><code>type(None)</code></td></tr>
</table>
<h2 id=isinstance>La funzione globale <code>isinstance()</code> (3.1+)</h2>
<p>La funzione <code>isinstance()</code> controlla se un oggetto è una istanza di una particolare classe o tipo. In Python 2, potevate passare una tupla di tipi, e <code>isinstance()</code> avrebbe restituito <code>True</code> se l'oggetto fosse stato di uno di quei tipi. In Python 3, potete ancora farlo, ma passare lo stesso tipo due volte è deprecato.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>isinstance(x, (int, float, int))</code></td>
<td><code>isinstance(x, (int, float))</code></td></tr>
</table>
<blockquote>
<p><span>&#x261E;</span>La versione di 2to3 rilasciata con Python 3.0 non corregge automaticamente questi casi di <code>isinstance()</code>. La correzione è apparsa per la prima volta nello script 2to3 che verrà rilasciato con Python 3.1.
</blockquote>
<h2 id=basestring>Il tipo di dato <code>basestring</code></h2>
<p>Python 2 aveva due tipi di stringhe: Unicode e non Unicode. Ma c'era anche un altro tipo, <code>basestring</code>. Era un tipo astratto, una superclasse per entrambi i tipi <code>str</code> e <code>unicode</code>. Non poteva essere chiamata o istanziata direttamente, ma potevate passarla alla funzione globale <code>isinstance()</code> per controllare che un oggetto fosse una stringa Unicode o una stringa non Unicode. In Python 3, c'è un solo tipo di stringhe, quindi <code>basestring</code> non ha ragione di esistere.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>isinstance(x, basestring)</code></td>
<td><code>isinstance(x, str)</code></td></tr>
</table>
<h2 id=itertools>Il modulo <code>itertools</code></h2>
<p>Python 2.3 ha introdotto il modulo <code>itertools</code>, che definiva varianti delle funzioni globali <code>zip()</code>, <code>map()</code>, e <code>filter()</code> che restituivano iteratori invece di liste. In Python 3, quelle funzioni globali restituiscono iteratori, quindi quelle funzioni nel modulo <code>itertools</code> sono state eliminate.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>itertools.izip(a, b)</code></td>
<td><code>zip(a, b)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>itertools.imap(a, b)</code></td>
<td><code>map(a, b)</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>itertools.ifilter(a, b)</code></td>
<td><code>filter(a, b)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>from itertools import imap, izip, foo</code></td>
<td><code>from itertools import foo</code></td></tr>
</table>
<ol>
<li>Invece di <code>itertools.izip()</code>, usate semplicemente la funzione globale <code>zip()</code>.
<li>Invece di <code>itertools.imap()</code>, usate semplicemente <code>map()</code>.
<li><code>itertools.ifilter()</code> diventa <code>filter()</code>.
<li>Il modulo <code>itertools</code> esiste ancora in Python 3, gli mancano solo le funzioni che sono state spostate nello spazio di nomi globale. Lo script <code>2to3</code> è abbastanza scaltro da rimuovere le specifiche istruzioni di <code>import</code> per moduli che non esistono più, lasciando le altre intatte.
</ol>
<h2 id=sys_exc><code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code></h2>
<p>Python 2 aveva tre variabili nel modulo <code>sys</code> che potevate accedere mentre una eccezione veniva gestita: <code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code>. (In realtà, queste risalgono a Python 1.) Fin da Python 1.5, queste variabili sono state deprecate a favore di <code>sys.exc_info</code>, che è una tupla che contiene tutti e tre i valori. In Python 3, queste singole variabili sono infine sparite; dovete usare <code>sys.exc_info</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>sys.exc_type</code></td>
<td><code>sys.exc_info()[0]</code></td></tr>
<tr><th></th>
<td><code>sys.exc_value</code></td>
<td><code>sys.exc_info()[1]</code></td></tr>
<tr><th></th>
<td><code>sys.exc_traceback</code></td>
<td><code>sys.exc_info()[2]</code></td></tr>
</table>
<h2 id=paren><span class=wtf>List comprehensions</span> sulle tuple</h2>
<p>In Python 2, se volevate implementare una <span class=wtf>list comprehension</span> che iterasse su una tupla, non avevate bisogno di mettere le parentesi attorno ai valori della tupla. In Python 3, le parentesi esplicite sono obbligatorie.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>[i for i in 1, 2]</code></td>
<td><code>[i for i in (1, 2)]</code></td></tr>
</table>
<h2 id=getcwdu>La funzione <code>os.getcwdu()</code></h2>
<p>Python 2 aveva una funzione chiamata <code>os.getcwd()</code>, che restituiva la directory di lavoro sotto forma di una stringa (non Unicode). Dato che i moderni file system possono gestire i nomi di directory in qualsiasi codifica di carattere, Python 2.3 ha introdotto <code>os.getcwdu()</code>. La funzione <code>os.getcwdu()</code> restituisce la directory di lavoro corrente come una stringa Unicode. In Python 3, c'è un solo tipo di stringhe (Unicode), quindi <code>os.getcwd()</code> è tutto quello di cui avete bisogno.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>os.getcwdu()</code></td>
<td><code>os.getcwd()</code></td></tr>
</table>
<h2 id=metaclass>Metaclassi</h2>
<p>In Python 2, potevate creare metaclassi definendo l'argomento <code>metaclass</code> nella dichiarazione della classe, oppure definendo uno speciale attributo <code>__metaclass__</code> a livello di classe. In Python 3, questo attributo a livello di classe è stato eliminato.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><pre><code>class C(metaclass=PapayaMeta):
    pass</code></pre></td>
<td><i>unchanged</i></td></tr>
<tr><th>&#x2461;</th>
<td><pre><code>class Whip:
    __metaclass__ = PapayaMeta</code></pre></td>
<td><pre><code>class Whip(metaclass=PapayaMeta):
    pass</code></pre></td></tr>
<tr><th>&#x2462;</th>
<td><pre><code>class C(Whipper, Beater):
    __metaclass__ = PapayaMeta</code></pre></td>
<td><pre><code>class C(Whipper, Beater, metaclass=PapayaMeta):
    pass</code></pre></td></tr>
</table>
<ol>
<li>Dichiarare la metaclasse nella dichiarazione della classe funzionava in Python 2, e funziona ancora allo stesso modo in Python 3.
<li>Dichiarare la metaclasse in un attributo di classe funzionava in Python 2, ma non funziona in Python 3.
<li>Lo script <code>2to3</code> è abbastanza potente da costruire una dichiarazione di classe valida, anche se la classe eredita da una o più classi base.
</ol>
<h2 id=nitpick>Questioni di stile</h2>
<p>Il resto delle &#8220;correzioni&#8221; elencate qui non sono realmente correzioni di per sé. Vale a dire che le cose che modificano sono questioni di stile, non di sostanza. Funzionano altrettanto bene in Python 3 come funzionavano in Python 2, ma gli svilupptori di Python hanno un legittimo interesse nel rendere il codice Python più uniforme possibile. A questo scopo, esiste una <a href=http://www.python.org/dev/peps/pep-0008/>guida ufficiale allo stile in Python</a> che delinea &mdash; in doloroso dettaglio &mdash; tutti quei tipi di particolari minuziosi e pedanti di cui quasi certamente non vi interessa. E dato che <code>2to3</code> fornisce una infrastruttura così buona per la conversione di codice Python da una cosa a un'altra, gli autori si sono presi la briga di aggiungere alcune caratteristiche opzionali per migliorare la leggibilità dei vostri programmi Python.
<h3 id=set_literal>Letterali <code>set()</code> (esplicita)</h3>
<p>In Python 2, l'unico modo di definire un letterale insieme nel vostro codice era chiamare <code>set(a_sequence)</code>. Questo funziona ancora in Python 3, ma un modo più chiaro di farlo è usare la nuova notazione per i letterali insieme: le parentesi graffe. (Anche i dizionari sono definiti con parentesi graffe, che ha senso una volta che ci pensate, perché i dizionari sono esattamente insiemi di coppie chiave-valore.)
<blockquote class=note>
<p><span>&#x261E;</span>Lo script <code>2to3</code> non correggerà i letterali <code>set()</code> di default. Per abilitare questa correzione, specificate <kbd>-f set_literal</kbd> sulla linea di comando quando chiamate <code>2to3</code>.
</blockquote>
<table>
<tr><th>Notes</th>
<th>Before</th>
<th>After</th>
</tr>
<tr><th></th>
<td><code>set([1, 2, 3])</code></td>
<td><code>{1, 2, 3}</code></td></tr>
<tr><th></th>
<td><code>set((1, 2, 3))</code></td>
<td><code>{1, 2, 3}</code></td></tr>
<tr><th></th>
<td><code>set([i for i in a_sequence])</code></td>
<td><code>{i for i in a_sequence}</code></td></tr>
</table>
<h3 id=buffer>La funzione globale <code>buffer()</code> (esplicita)</h3>
<p>Gli oggetti Python implementati in C possono esportare una &#8220;interfaccia di buffer,&#8221; che è un blocco di memoria che è direttamente leggibile e scrivibile senza copiare. (Questo è esattamente potente e spaventoso quanto sembra.) In Python 3, <code>buffer()</code> è stata rinominata a <code>memoryview()</code>. (&Egrave; un po' più complicato di così, ma potete quasi certamente ignorare le differenze.)
<blockquote class=note>
<p><span>&#x261E;</span>Lo script <code>2to3</code> non correggerà la funzione <code>buffer()</code> di default. Per abilitare questa correzione, specificate <kbd>-f buffer</kbd> sulla linea di comando quando chiamate <code>2to3</code>.
</blockquote>
<table>
<tr><th>Notes</th>
<th>Before</th>
<th>After</th>
</tr>
<tr><th></th>
<td><code>x = buffer(y)</code></td>
<td><code>x = memoryview(y)</code></td></tr>
</table>
<h3 id=wscomma>Gli spazi bianhi attorno alle virgole (esplicita)</h3>
<p>Nonostante sia draconiano a riguardo degli spazi bianchi per l'indentazione del codice, Python è in realtà piuttosto liberale a proposito degli spazi bianchi in altre aree. Nell'ambito di liste, tuple, insiemi, e dizionari, gli spazi bianchi possono apparire prima e dopo le virgole senza sortire alcun effetto negativo. Comunque, la guida di stile in Python afferma che le virgole dovrebbero essere precedeute da zero spazi e seguite da uno spazio. Sebbene questo sia un problema puramente estetico (il codice funziona in ogni modo, sia in Python 2 che in Python 3) lo script <code>2to3</code> può opzionalmente correggere questo per voi.
<blockquote class=note>
<p><span>&#x261E;</span>Lo script <code>2to3</code> non correggerà gli spazi bianchi attorno alle virgole di default. Per abilitare questa correzione, specificate <kbd>-f wscomma</kbd> sulla linea di comando quando chiamate <code>2to3</code>.
</blockquote>
<table>
<tr><th>Notes</th>
<th>Before</th>
<th>After</th>
</tr>
<tr><th></th>
<td><code>a ,b</code></td>
<td><code>a, b</code></td></tr>
<tr><th></th>
<td><code>{a :b}</code></td>
<td><code>{a: b}</code></td></tr>
</table>
<h3 id=idioms>Idiomi comuni (esplicita)</h3>
<p>C'erano un numero di idiomi comuni accumulati dalla comunità Python. Alcuni, come il ciclo <code>while 1:</code>, risalgono a Python 1. (Python non ha avuto un vero tipo boolean fino alla versione 2.3, così gli sviluppatori usavano <code>1</code> e <code>0</code>.) I moderni programmatori Python dovrebbero allenare i loro cervelli all'uso delle moderne versioni di questi idiomi.
<blockquote class=note>
<p><span>&#x261E;</span>Lo script <code>2to3</code> non correggerà gli idiomi comuni di default. Per abilitare questa correzione, specificate <kbd>-f idioms</kbd> sulla linea di comando quando chiamate <code>2to3</code>.
</blockquote>
<table>
<tr><th>Notes</th>
<th>Before</th>
<th>After</th>
</tr>
<tr><th></th>
<td><pre><code>while 1:
    do_stuff()</code></pre></td>
<td><pre><code>while True:
    do_stuff()</code></pre></td></tr>
<tr><th></th>
<td><code>type(x) == T</code></td>
<td><code>isinstance(x, T)</code></td></tr>
<tr><th></th>
<td><code>type(x) is T</code></td>
<td><code>isinstance(x, T)</code></td></tr>
<tr><th></th>
<td><pre><code>a_list = list(a_sequence)
a_list.sort()
do_stuff(a_list)</code></pre></td>
<td><pre><code>a_list = sorted(a_sequence)
do_stuff(a_list)</code></pre></td></tr>
</table>
<p><span class=fixme>FIXME: once the rest of the book is written, this appendix should contain copious links back to any chapter or section that touches on these features.</span>
<p class=nav><a rel=prev href=caso-di-studio-convertire-chardet-verso-python-3.html title="indietro a &#8220;Caso di studio: convertire chardet verso Python 3&#8221;"><span>&#x261C;</a> <a rel=next class=todo><span>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;9 <a href=about.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=translation.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
