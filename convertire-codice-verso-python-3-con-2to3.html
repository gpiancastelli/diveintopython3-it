<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Convertire codice verso Python 3 con 2to3 - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
h1:before{counter-increment:h1;content:"Appendix A. "}
h2:before{counter-increment:h2;content:"A." counter(h2) ". "}
h3:before{counter-increment:h3;content:"A." counter(h2) "." counter(h3) ". "}
tr + tr th:first-child{font:medium 'Arial Unicode MS',FreeSerif,OpenSymbol,'DejaVu Sans',sans-serif}
table{width:100%;border-collapse:collapse}
th,td{width:45%;padding:0 0.5em;border:1px solid #bbb}
th{text-align:left;vertical-align:baseline}
td{vertical-align:top}
th:first-child{width:10%;text-align:center}
th,td,td pre{margin:0}
td pre{padding:0;border:0}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#porting-code-to-python-3-with-2to3>Dive Into Python 3</a> <span>&#8227;</span>
<h1>Convertire codice verso Python 3 con <code>2to3</code></h1>
<blockquote class=q>
<p><span>&#x275D;</span> Life is pleasant. Death is peaceful. It&#8217;s the transition that&#8217;s troublesome. <span>&#x275E;</span><br>&mdash; Isaac Asimov (attributed)
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>Virtualmente tutti i programmi scritti in Python 2 avranno bisogno almeno di qualche ritocco per essere eseguiti correttamente sotto Python 3. Per aiutare con questa transizione, Python 3 comprende uno script di utilità chiamato <code>2to3</code>, che prende il vostro codice sorgente in Python 2 in ingresso e lo converte automaticamente verso Python 3 tanto quanto gli è possibile. <a href=caso-di-studio-convertire-chardet-verso-python-3.html#running2to3>Caso di studio: convertire <code>chardet</code> verso Python 3</a> descrive come eseguire lo script <code>2to3</code>, poi mostra alcune cose che esso non riesce a correggere automaticamente. Questa appendice documenta ciò che lo script <em>può</em> correggere automaticamente
<h2 id=print>Istruzione <code>print</code></h2>
<p>In Python 2, <code>print</code> era una istruzione. Qualsiasi cosa volevate stampare semplicemente seguiva la parola chiave <code>print</code>. In Python 3, <code>print()</code> è una funzione &mdash; ogni cosa che volete stampare è passata a <code>print()</code> come qualsiasi altra funzione.
<table>
<tr>
<th class=notes>Notes</th>
<th class=python2>Python 2</th>
<th class=python3>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>print</code></td>
<td><code>print()</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>print 1</code></td>
<td><code>print(1)</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>print 1, 2</code></td>
<td><code>print(1, 2)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>print 1, 2,</code></td>
<td><code>print(1, 2, end=' ')</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>print >>sys.stderr, 1, 2, 3</code></td>
<td><code>print(1, 2, 3, file=sys.stderr)</code></td></tr>
</table>
<ol>
<li>Per stampare una riga vuota, invocate <code>print()</code> senza alcun argomento.
<li>Per stampare un singolo valore, invocate <code>print()</code> con un argomento.
<li>Per stampare due valori separati da uno spazio, invocate <code>print()</code> con due argomenti.
<li>Questo è un po' complicato. In Python 2, se concludevate una istruzione <code>print</code> con una virgola, avrebbe stampato i valori separati da spazi, poi stampato uno spazio finale, e si sarebbe fermata senza stampare un ritorno a capo. In Python 3, il modo per fare questo è passare <code>end=' '</code> come un <span class=wtf>keyword argument</span> alla funzione <code>print()</code>. L'argomento <code>end</code> assume <code>'\n'</code> (un ritorno a capo) come valore di default, quindi <span class=wtf>overriding it</span> sopprimerà il ritorno a capo dopo la stampa degli altri argomenti.
<li>In Python 2, potevate redirigere l'output verso una pipe &mdash; come <code>sys.stderr</code> &mdash; utilizzando la sintassi <code>>>pipe_name</code>. In Python 3, il modo di fare questo è passare la pipe come valore al <span class=wtf>keyword argument</span> <code>file</code>. L'argomento <code>file</code> assume <code>sys.stdout</code> (standard output) come valore di default, quindi <span class=wtf>overriding it</span> produrrà l'output su una pipe differente.
</ol>
<h2 id=unicodeliteral>Letterali stringa Unicode</h2>
<p>Python 2 aveva due tipi di stringa: stringhe Unicode e stringhe non Unicode. Python 3 ha un solo tipo di stringa: stringhe Unicode.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>u"PapayaWhip"</code></td>
<td><code>"PapayaWhip"</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>ur"PapayaWhip\foo"</code></td>
<td><code>r"PapayaWhip\foo"</code></td></tr>
</table>
<ol>
<li>I letterali stringa Unicode sono semplicemente convertiti in letterali stringa, che, in Python 3, sono sempre di tipo Unicode.
<li>Le <span class=wtf>raw strings</span> Unicode (in cui Python non effettua l'escape automatico dei backslash) sono convertite a <span class=wtf>raw strings</span>. In Python 3, le <span class=wtf>raw strings</span> sono sempre di tipo Unicode.
</ol>
<h2 id=unicode>La funzione globale <code>unicode()</code></h2>
<p>Python 2 aveva due funzioni globali per forzare oggetti in stringhe: <code>unicode()</code> per forzarli a stringhe Unicode, e <code>str()</code> per forzarli a stringhe non Unicode. Python 3 ha un solo tipo di stringhe, stringhe Unicode, quindi la funzione <code>str()</code> è tutto quello che vi serve. (La funzione <code>unicode()</code> non esiste più.)
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>unicode(anything)</code></td>
<td><code>str(anything)</code></td></tr>
</table>
<h2 id=long>Il tipo di dato <code>long</code></h2>
<p>Python 2 aveva tipi <code>int</code> e <code>long</code> separati per i numeri non in virgola mobile. Un <code>int</code> non poteva essere più grande di <a href=#renames><code>sys.maxint</code></a>, che variava a seconda della piattaforma. I <code>long</code> erano definiti aggiungendo una <code>L</code> alla fine del numero, e potevano essere, be', più lunghi degli <code>int</code>. In Python 3, c'è solo un tipo di numeri interi, chiamato <code>int</code>, che per la maggior parte si comporta come il tipo <code>long</code> in Python 2. Dato che non ci sono più due tipi, non c'è alcun bisogno di una speciale sintassi per distinguerli.
<p>Lettura di approfondimento: <a href=http://www.python.org/dev/peps/pep-0237/><abbr>PEP</abbr> 237: Unifying Long Integers and Integers</a>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>x = 1000000000000L</code></td>
<td><code>x = 1000000000000</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>x = 0xFFFFFFFFFFFFL</code></td>
<td><code>x = 0xFFFFFFFFFFFF</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>long(x)</code></td>
<td><code>int(x)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>type(x) is long</code></td>
<td><code>type(x) is int</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>isinstance(x, long)</code></td>
<td><code>isinstance(x, int)</code></td></tr>
</table>
<ol>
<li>I letterali <code>long</code> in base 10 diventano letterali <code>int</code> in base 10.
<li>I letterali <code>long</code> in base 16 diventano letterali <code>int</code> in base 16.
<li>In Python 3, la vecchia funzione <code>long()</code> non esiste più, dato che i <code>long</code> non esistono più. Per forzare una variabile a un intero, usate la funzione <code>int()</code>.
<li>Per controllare se una variabile è un intero, recuperatene il tipo e confrontatelo con <code>int</code>, non con <code>long</code>.
<li>Potete anche usare la funzione <code>isinstance()</code> per controllare i tipi di dato; ancora, usate <code>int</code>, non <code>long</code>, per controllare gli interi.
</ol>
<h2 id=ne>Il confronto di disuguaglianza con &lt;></h2>
<p>Python 2 supportava <code>&lt;></code> come sinonimo per <code>!=</code>, l'operatore per il confronto di disuguaglianza. Python 3 supporta l'operatore <code>!=</code>, ma non <code>&lt;></code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>if x &lt;> y:</code></td>
<td><code>if x != y:</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>if x &lt;> y &lt;> z:</code></td>
<td><code>if x != y != z:</code></td></tr>
</table>
<ol>
<li>Un semplice confronto.
<li>Un confronto più complesso tra tre valori.
</ol>
<h2 id=has_key>Il metodo <code>has_key()</code> per i dizionari</h2>
<p>In Python 2, i dizionari avevano un metodo <code>has_key()</code> per verificare che il dizionario contenesse una certa chiave. In Python 3, questo metodo non esiste più. Al suo posto, dovete usare l'operatore <code>in</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>a_dictionary.has_key("PapayaWhip")</code></td>
<td><code>"PapayaWhip" in a_dictionary</code></td></tr>
<tr><th>&#x2461;</th >
<td><code>a_dictionary.has_key(x) or a_dictionary.has_key(y)</code></td>
<td><code>x in a_dictionary or y in a_dictionary</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>a_dictionary.has_key(x or y)</code></td>
<td><code>(x or y) in a_dictionary</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>a_dictionary.has_key(x + y)</code></td>
<td><code>(x + y) in a_dictionary</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>x + a_dictionary.has_key(y)</code></td>
<td><code>x + (y in a_dictionary)</code></td></tr>
</table>
<ol>
<li>La forma più semplice.
<li>L'operatore <code>or</code> ha la precedenza sull'operatore <code>in</code>, quindi non c'è alcun bisogno di usare le parentesi qui.
<li>D'altra parte, <em>avete</em> bisogno di usare le parentesi qui, per lo stesso motivo &mdash; <code>or</code> ha la precedenza su <code>in</code>.
<li>L'operatore <code>in</code> ha la precedenza sull'operatore <code>+</code>, quindi anche questa forma necessita di parentesi.
<li>Ancora con le parentesi, per la stessa ragione.
</ol>
<h2 id=dict>Metodi dei dizionari che restituiscono liste</h2>
<p>In Python 2, molti metodi dei dizionari restituivano liste. I metodi più frequentemente usati erano <code>keys()</code>, <code>items()</code>, e <code>values()</code>. In Python 3, tutti questi metodi ritornano viste dinamiche. In alcuni contesti, questo non è un problema. Se il valore di ritorno del metodo è passato immediatamente a un'altra funzione che itera attraverso l'intera sequenza, non fa alcuna differenza che il tipo reale sia una lista o una vista. In altri contesti, ha invece molta importanza. Se vi stavate aspettando una lista completa con elementi accessibili individualmente, il vostro codice si bloccherà, perché le viste non supportano l'accesso basato su indici.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>a_dictionary.keys()</code></td>
<td><code>list(a_dictionary.keys())</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_dictionary.items()</code></td>
<td><code>list(a_dictionary.items())</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>a_dictionary.iterkeys()</code></td>
<td><code>iter(a_dictionary.keys())</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>[i for i in a_dictionary.iterkeys()]</code></td>
<td><code>[i for i in a_dictionary.keys()]</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>min(a_dictionary.keys())</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li><code>2to3</code> pecca per eccesso di sicurezza, convertendo il valore di ritorno di <code>keys()</code> a una lista statica tramite la funzione <code>list()</code>. Questo funzionerà sempre, ma sarà meno efficiente che usare una vista. Dovreste esaminare il codice convertito per vedere se una lista è assolutamente necessaria, o una vista sarebbe sufficiente.
<li>Un'altra conversione da vista a lista, con il metodo <code>items()</code>. <code>2to3</code> farà la stessa cosa con il metodo <code>values()</code>.
<li>Python 3 non supporta più il metodo <code>iterkeys()</code> Usate <code>keys()</code>, e se necessario, convertite la vista in un iteratore con la funzione <code>iter()</code>.
<li><code>2to3</code> riconosce quando il metodo <code>iterkeys()</code> viene usato in una <span class=wtf>list comprehension</span>, e lo converte al metodo <code>keys()</code> (senza circondarlo in una chiamata extra a <code>iter()</code>). Questo funziona perché le viste sono iterabili.
<li><code>2to3</code> riconosce che il metodo <code>keys()</code> è immediatamente passato a una funzione che itera su una intera sequenza, così non c'è bisogno di convertire prima il valore di ritorno a una lista. La funzione <code>min()</code> itererà allegramente attraverso la vista. Questo si applica alle funzioni <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>list()</code>, <code>tuple()</code>, <code>set()</code>, <code>sorted()</code>, <code>any()</code>, e <code>all()</code>.
</ol>
<h2 id=imports>Moduli che sono stati rinominati o riorganizzati</h2>
<p>Diversi moduli nella libreria standard di Python sono stati rinominati. Diversi altri moduli in relazione tra loro sono stati combinati o riorganizzati per rendere le loro associazioni più logiche.
<h3 id=http><code>http</code></h3>
<p>In Python 3, molti moduli relativi al protocollo <abbr>HTTP</abbr> sono stati combinati in un unico pacchetto, <code>http</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>import httplib</code></td>
<td><code>import http.client</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>import Cookie</code></td>
<td><code>import http.cookies</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>import cookielib</code></td>
<td><code>import http.cookiejar</code></td></tr>
<tr><th>&#x2463;</th>
<td><pre><code>import BaseHTTPServer
import SimpleHTTPServer
import CGIHttpServer</code></pre></td>
<td><code>import http.server</code></td></tr>
</table>
<ol>
<li>Il modulo <code>http.client</code> implementa una libreria di basso livello che può richiedere risorse <abbr>HTTP</abbr> e interpretare le risposte <abbr>HTTP</abbr>.
<li>Il modulo <code>http.cookies</code> fornisce una interfaccia Python ai cookie che sono inviati a un browser tramite l'intestazione <abbr>HTTP</abbr> <code>Set-Cookie:</code>.
<li>Il modulo <code>http.cookiejar</code> manipola i file effettivi che i browser web più popolari usano per memorizzare i cookie.
<li>Il modulo <code>http.server</code> fornisce un server <abbr>HTTP</abbr> di base.
</ol>
<h3 id=urllib><code>urllib</code></h3>
<p>Python 2 aveva una <span class=wtf>rat's nest</span> di moduli sovrapposti per riconoscere, codificare, e recuperare gli <abbr>URL</abbr>. In Python 3, tutti questi metodi sono stati fattorizzati e combinati in un singolo pacchetto, <code>urllib</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>import urllib</code></td>
<td><code>import urllib.request, urllib.parse, urllib.error</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>import urllib2</code></td>
<td><code>import urllib.request, urllib.error</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>import urlparse</code></td>
<td><code>import urllib.parse</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>import robotparser</code></td>
<td><code>import urllib.robotparser</code></td></tr>
<tr><th>&#x2464;</th>
<td><pre><code>from urllib import FancyURLopener
from urllib import urlencode</code></pre></td>
<td><pre><code>from urllib.request import FancyURLopener
from urllib.parse import urlencode</code></pre></td></tr>
<tr><th>&#x2465;</th>
<td><pre><code>from urllib2 import Request
from urllib2 import HTTPError</code></pre></td>
<td><pre><code>from urllib.request import Request
from urllib.error import HTTPError</code></pre></td></tr>
</table>
<ol>
<li>The old <code>urllib</code> module in Python 2 had a variety of functions, including <code>urlopen()</code> for fetching data and <code>splittype()</code>, <code>splithost()</code>, and <code>splituser()</code> for splitting a <abbr>URL</abbr> into its constituent parts. These functions have been reorganized more logically within the new <code>urllib</code> package. <code>2to3</code> will also change all calls to these functions so they use the new naming scheme.
<li>The old <code>urllib2</code> module in Python 2 has been folded into into the <code>urllib</code> package in Python 3. All your <code>urllib2</code> favorites &mdash; the <code>build_opener()</code> method, <code>Request</code> objects, and <code>HTTPBasicAuthHandler</code> and friends &mdash; are still available.
<li>The <code>urllib.parse</code> module in Python 3 contains all the parsing functions from the old <code>urlparse</code> module in Python 2.
<li>The <code>urllib.robotparser</code> module parses <a href=http://www.robotstxt.org/><code>robots.txt</code> files</a>.
<li>The <code>FancyURLopener</code> class, which handles <abbr>HTTP</abbr> redirects and other status codes, is still available in the new <code>urllib.request</code> module. The <code>urlencode</code> function has moved to <code>urllib.parse</code>.
<li>The <code>Request</code> object is still available in <code>urllib.request</code>, but constants like <code>HTTPError</code> have been moved to <code>urllib.error</code>.
</ol>
<h3 id=dbm><code>dbm</code></h3>
<p>All the various <abbr>DBM</abbr> clones are now in a single package, <code>dbm</code>. If you need a specific variant like <abbr>GNU</abbr> <abbr>DBM</abbr>, you can import the appropriate module within the <code>dbm</code> package.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>import dbm</code></td>
<td><code>import dbm.ndbm</code></td></tr>
<tr><th></th>
<td><code>import gdbm</code></td>
<td><code>import dbm.gnu</code></td></tr>
<tr><th></th>
<td><code>import dbhash</code></td>
<td><code>import dbm.bsd</code></td></tr>
<tr><th></th>
<td><code>import dumbdbm</code></td>
<td><code>import dbm.dumb</code></td></tr>
<tr><th></th>
<td><pre><code>import anydbm
import whichdb</code></pre></td>
<td><code>import dbm</code></td></tr>
</table>
<h3 id=xmlrpc><code>xmlrpc</code></h3>
<p><abbr>XML-RPC</abbr> is a lightweight method of performing remote <abbr>RPC</abbr> calls over <abbr>HTTP</abbr>. The <abbr>XML-RPC</abbr> client library and several <abbr>XML-RPC</abbr> server implementations are now combined in a single package, <code>xmlrpc</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>import xmlrpclib</code></td>
<td><code>import xmlrpc.client</code></td></tr>
<tr><th></th>
<td><pre><code>import DocXMLRPCServer
import SimpleXMLRPCServer</code></pre></td>
<td><code>import xmlrpc.server</code></td></tr>
</table>
<h3 id=othermodules>Other modules</h3>
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><pre><code>try:
    import cStringIO as StringIO
except ImportError:
    import StringIO</code></pre></td>
<td><code>import io</code></td></tr>
<tr><th>&#x2461;</th>
<td><pre><code>try:
    import cPickle as pickle
except ImportError:
    import pickle</code></pre></td>
<td><code>import pickle</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>import __builtin__</code></td>
<td><code>import builtins</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>import copy_reg</code></td>
<td><code>import copyreg</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>import Queue</code></td>
<td><code>import queue</code></td></tr>
<tr><th>&#x2465;</th>
<td><code>import SocketServer</code></td>
<td><code>import socketserver</code></td></tr>
<tr><th>&#x2466;</th>
<td><code>import ConfigParser</code></td>
<td><code>import configparser</code></td></tr>
<tr><th>&#x2467;</th>
<td><code>import repr</code></td>
<td><code>import reprlib</code></td></tr>
<tr><th>&#x2468;</th>
<td><code>import commands</code></td>
<td><code>import subprocess</code></td></tr>
</table>
<ol>
<li>A common idiom in Python 2 was to try to import <code>cStringIO as StringIO</code>, and if that failed, to import <code>StringIO</code> instead. Do not do this in Python 3; the <code>io</code> module does it for you. It will find the fastest implementation available and use it automatically.
<li>A similar idiom was used to import the fastest pickle implementation. Do not do this in Python 3; the <code>pickle</code> module does it for you.
<li>The <code>builtins</code> module contains the global functions, classes, and constants used throughout the Python language. Redefining a function in the <code>builtins</code> module will redefine the global function everywhere. That is exactly as powerful and scary as it sounds.
<li>The <code>copyreg</code> module adds pickle support for custom types defined in C.
<li>The <code>queue</code> module implements a multi-producer, multi-consumer queue.
<li>The <code>socketserver</code> module provides generic base classes for implementing different kinds of socket servers.
<li>The <code>configparser</code> module parses <abbr>INI</abbr>-style configuration files.
<li>The <code>reprlib</code> module reimplements the built-in <code>repr()</code> function, but with limits on how many values are represented.
<li>The <code>subprocess</code> module allows you to spawn processes, connect to their pipes, and obtain their return codes.
</ol>
<h2 id=import>Relative imports within a package</h2>
<p>A package is a group of related modules that function as a single entity. In Python 2, when modules within a package need to reference each other, you use <code>import foo</code> or <code>from foo import Bar</code>. The Python 2 interpreter first searches within the current package to find <code>foo.py</code>, and then moves on to the other directories in the Python search path (<code>sys.path</code>). Python 3 works a bit differently. Instead of searching the current package, it goes directly to the Python search path. If you want one module within a package to import another module in the same package, you need to explicitly provide the relative path between the two modules.
<p>Suppose you had this package, with multiple files in the same directory:
<pre>chardet/
|
+--__init__.py
|
+--constants.py
|
+--mbcharsetprober.py
|
+--universaldetector.py</pre>
<p>Now suppose that <code>universaldetector.py</code> needs to import the entire <code>constants.py</code> file and one class from <code>mbcharsetprober.py</code>. How do you do it?
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>import constants</code></td>
<td><code>from . import constants</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>from mbcharsetprober import MultiByteCharSetProber</code></td>
<td><code>from .mbcharsetprober import MultiByteCharsetProber</code></td></tr>
</table>
<ol>
<li>When you need to import an entire module from elsewhere in your package, use the new <code>from . import</code> syntax. The period is actually a relative path from this file (<code>universaldetector.py</code>) to the file you want to import (<code>constants.py</code>). In this case, they are in the same directory, thus the single period. You can also import from the parent directory (<code>from .. import anothermodule</code>) or a subdirectory.
<li>To import a specific class or function from another module directly into your module's namespace, prefix the target module with a relative path, minus the trailing slash. In this case, <code>mbcharsetprober.py</code> is in the same directory as <code>universaldetector.py</code>, so the path is a single period. You can also import form the parent directory (<code>from ..anothermodule import AnotherClass</code>) or a subdirectory.
</ol>
<h2 id=next><code>next()</code> iterator method</h2>
<p>In Python 2, iterators had a <code>next()</code> method which returned the next item in the sequence. That's still true in Python 3, but there is now also a global <code>next()</code> function that takes an iterator as an argument.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>anIterator.next()</code></td>
<td><code>next(anIterator)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_function_that_returns_an_iterator().next()</code></td>
<td><code>next(a_function_that_returns_an_iterator())</code></td></tr>
<tr><th>&#x2462;</th>
<td><pre><code>class A:
    def next(self):
        pass</code></pre></td>
<td><pre><code>class A:
    def __next__(self):
        pass</code></pre></td></tr>
<tr><th>&#x2463;</th>
<td><pre><code>class A:
    def next(self, x, y):
        pass</code></pre></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2464;</th>
<td><pre><code>next = 42
for an_iterator in a_sequence_of_iterators:
    an_iterator.next()</code></pre></td>
<td><pre><code>next = 42
for an_iterator in a_sequence_of_iterators:
    an_iterator.__next__()</code></pre></td></tr>
</table>
<ol>
<li>In the simplest case, instead of calling an iterator's <code>next()</code> method, you now pass the iterator itself to the global <code>next()</code> function.
<li>If you have a function that returns an iterator, call the function and pass the result to the <code>next()</code> function. (The <code>2to3</code> script is smart enough to convert this properly.)
<li>If you define your own class and mean to use it as an iterator, define the <code>__next__()</code> special method.
<li>If you define your own class and just happen to have a method named <code>next()</code> that takes one or more arguments, <code>2to3</code> will not touch it. This class can not be used as an iterator, because its <code>next()</code> method takes arguments.
<li>This one is a bit tricky. If you have a local variable named <var>next</var>, then it takes precedence over the new global <code>next()</code> function. In this case, you need to call the iterator's special <code>__next()__</code> method to get the next item in the sequence. (Alternatively, you could also refactor the code so the local variable wasn't named <var>next</var>, but <code>2to3</code> will not do that for you automatically.)
</ol>
<h2 id=filter><code>filter()</code> global function</h2>
<p>In Python 2, the <code>filter()</code> function returned a list, the result of filtering a sequence through a function that returned <code>True</code> or <code>False</code> for each item in the sequence. In Python 3, the <code>filter()</code> function returns an iterator, not a list.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>filter(a_function, a_sequence)</code></td>
<td><code>list(filter(a_function, a_sequence))</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>list(filter(a_function, a_sequence))</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2462;</th>
<td><code>filter(None, a_sequence)</code></td>
<td><code>[i for i in a_sequence if i]</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>for i in filter(None, a_sequence):</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2464;</th>
<td><code>[i for i in filter(a_function, a_sequence)]</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>In the most basic case, <code>2to3</code> will wrap a call to <code>filter()</code> with a call to <code>list()</code>, which simply iterates through its argument and returns a real list.
<li>However, if the call to <code>filter()</code> is <em>already</em> wrapped in <code>list()</code>, <code>2to3</code> will do nothing, since the fact that <code>filter()</code> is returning an iterator is irrelevant.
<li>For the special syntax of <code>filter(None, ...)</code>, <code>2to3</code> will transform the call into a semantically equivalent list comprehension.
<li>In contexts like <code>for</code> loops, which iterate through the entire sequence anyway, no changes are necessary.
<li>Again, no changes are necessary, because the list comprehension will iterate through the entire sequence, and it can do that just as well if <code>filter()</code> returns an iterator as if it returns a list.
</ol>
<h2 id=map><code>map()</code> global function</h2>
<p>In much the same way as <a href=#filter><code>filter()</code></a>, the <code>map()</code> function now returns an iterator. (In Python 2, it returned a list.)
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>map(a_function, 'PapayaWhip')</code></td>
<td><code>list(map(a_function, 'PapayaWhip'))</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>map(None, 'PapayaWhip')</code></td>
<td><code>list('PapayaWhip')</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>map(lambda x: x+1, range(42))</code></td>
<td><code>[x+1 for x in range(42)]</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>for i in map(a_function, a_sequence):</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2464;</th>
<td><code>[i for i in map(a_function, a_sequence)]</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>As with <code>filter()</code>, in the most basic case, <code>2to3</code> will wrap a call to <code>map()</code> with a call to <code>list()</code>.
<li>For the special syntax of <code>map(None, ...)</code>, the identity function, <code>2to3</code> will convert it to an equivalent call to <code>list()</code>.
<li>If the first argument to <code>map()</code> is a lambda function, <code>2to3</code> will convert it to an equivalent list comprehension.
<li>In contexts like <code>for</code> loops, which iterate through the entire sequence anyway, no changes are necessary.
<li>Again, no changes are necessary, because the list comprehension will iterate through the entire sequence, and it can do that just as well if <code>map()</code> returns an iterator as if it returns a list.
</ol>
<h2 id=reduce><code>reduce()</code> global function (3.1+)</h2>
<p>In Python 3, the <code>reduce()</code> function has been removed from the global namespace and placed in the <code>functools</code> module.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>reduce(a, b, c)</code></td>
<td><pre><code>from functtools import reduce
reduce(a, b, c)</code></pre></td></tr>
</table>
<blockquote>
<p><span>&#x261E;</span>The version of <code>2to3</code> that shipped with Python 3.0 would not fix the <code>reduce()</code> function automatically. The fix first appeared in the <code>2to3</code> script that shipped with Python 3.1.
</blockquote>
<h2 id=apply><code>apply()</code> global function</h2>
<p>Python 2 had a global function called <code>apply()</code>, which took a function <var>f</var> and a list <code>[a, b, c]</code> and returned <code>f(a, b, c)</code>. In Python 3, the <code>apply()</code> function no longer exists. Instead, there is a new function calling syntax that allows you to pass a list and have Python apply the list as the function's arguments.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>apply(a_function, a_list_of_args)</code></td>
<td><code>a_function(*a_list_of_args)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>apply(a_function, a_list_of_args, a_dictionary_of_named_args)</code></td>
<td><code>a_function(*a_list_of_args, **a_dictionary_of_named_args)</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>apply(a_function, a_list_of_args + z)</code></td>
<td><code>a_function(*a_list_of_args + z)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>apply(aModule.a_function, a_list_of_args)</code></td>
<td><code>aModule.a_function(*a_list_of_args)</code></td></tr>
</table>
<ol>
<li>In the simplest form, you can call a function with a list of arguments (an actual list like <code>[a, b, c]</code>) by prepending the list with an asterisk (<code>*</code>). This is exactly equivalent to the old <code>apply()</code> function in Python 2.
<li>In Python 2, the <code>apply()</code> function could actually take three parameters: a function, a list of arguments, and a dictionary of named arguments. In Python 3, you can accomplish the same thing by prepending the list of arguments with an asterisk (<code>*</code>) and the dictionary of named arguments with two asterisks (<code>**</code>).
<li>The <code>+</code> operator, used here for list concatenation, takes precedence over the <code>*</code> operator, so there is no need for extra parentheses around <code>a_list_of_args + z</code>.
<li>The <code>2to3</code> script is smart enough to convert complex <code>apply()</code> calls, including calling functions within imported modules.
</ol>
<h2 id=intern><code>intern()</code> global function</h2>
<p>In Python 2, you could call the <code>intern()</code> function on a string to intern it as a performance optimization. In Python 3, the <code>intern()</code> function has been moved to the <code>sys</code> module.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>intern(aString)</code></td>
<td><code>sys.intern(aString)</code></td></tr>
</table>
<h2 id=exec><code>exec</code> statement</h2>
<p>Just as <a href=#print>the <code>print</code> statement</a> became a function in Python 3, so too has the <code>exec</code> statement. The <code>exec()</code> function takes a string which contains arbitrary Python code and executes it as if it were just another statement or expression.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>exec codeString</code></td>
<td><code>exec(codeString)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>exec codeString in a_global_namespace</code></td>
<td><code>exec(codeString, a_global_namespace)</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>exec codeString in a_global_namespace, a_local_namespace</code></td>
<td><code>exec(codeString, a_global_namespace, a_local_namespace)</code></td></tr>
</table>
<ol>
<li>In the simplest form, the <code>2to3</code> script simply encloses the code-as-a-string in parentheses, since <code>exec()</code> is now a function instead of a statement.
<li>The old <code>exec</code> statement could take a namespace, a private environment of globals in which the code-as-a-string would be executed. Python 3 can also do this; just pass the namespace as the second argument to the <code>exec()</code> function.
<li>Even fancier, the old <code>exec</code> statement could also take a local namespace (like the variables defined within a function). In Python 3, the <code>exec()</code> function can do that too.
</ol>
<h2 id=execfile><code>execfile</code> statement (3.1+)</h2>
<p>Like the old <a href=#exec><code>exec</code> statement</a>, the old <code>execfile</code> statement will execute strings as if they were Python code. Where <code>exec</code> took a string, <code>execfile</code> took a filename. In Python 3, the <code>execfile</code> statement has been eliminated. If you really need to take a file of Python code and execute it (but you're not willing to simply import it), you can accomplish the same thing by opening the file, reading its contents, calling the global <code>compile()</code> function to force the Python interpreter to compile the code, and then call the new <code>exec()</code> function.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>execfile("a_filename")</code></td>
<td><code>exec(compile(open("a_filename").read(), "a_filename", "exec"))</code></td></tr>
</table>
<blockquote>
<p><span>&#x261E;</span>The version of <code>2to3</code> that shipped with Python 3.0 would not fix the <code>execfile</code> statement automatically. The fix first appeared in the <code>2to3</code> script that shipped with Python 3.1.
</blockquote>
<h2 id=repr><code>repr</code> literals (backticks)</h2>
<p>In Python 2, there was a special syntax of wrapping any object in backticks (like <code>`x`</code>) to get a representation of the object. In Python 3, this capability still exists, but you can no longer use backticks to get it. Instead, use the global <code>repr()</code> function.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>`x`</code></td>
<td><code>repr(x)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>`"PapayaWhip" + `2``</code></td>
<td><code>repr("PapayaWhip" + repr(2))</code></td></tr>
</table>
<ol>
<li>Remember, <var>x</var> can be anything &mdash; a class, a function, a module, a primitive data type, etc. The <code>repr()</code> function works on everything.
<li>In Python 2, backticks could be nested, leading to this sort of confusing (but valid) expression. The <code>2to3</code> tool is smart enough to convert this into nested calls to <code>repr()</code>.
</ol>
<h2 id=except><code>try...except</code> statement</h2>
<p>The syntax for catching exceptions has changed slightly between Python 2 and Python 3.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><pre><code>try:
    import mymodule
except ImportError, e
    pass</code></pre></td>
<td><pre><code>try:
    import mymodule
except ImportError as e:
    pass</code></pre></td></tr>
<tr><th>&#x2461;</th>
<td><pre><code>try:
    import mymodule
except (RuntimeError, ImportError), e
    pass</code></pre></td>
<td><pre><code>try:
    import mymodule
except (RuntimeError, ImportError) as e:
    pass</code></pre></td></tr>
<tr><th>&#x2462;</th>
<td><pre><code>try:
    import mymodule
except ImportError:
    pass</code></pre></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2463;</th>
<td><pre><code>try:
    import mymodule
except:
    pass</code></pre></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Instead of a comma after the exception type, Python 3 uses a new keyword, <code>as</code>.
<li>The <code>as</code> keyword also works for catching multiple types of exceptions at once.
<li>If you catch an exception but don't actually care about accessing the exception object itself, the syntax is identical between Python 2 and Python 3.
<li>Similarly, if you use a fallback to catch <em>all</em> exceptions, the syntax is identical.
</ol>
<blockquote class=note>
<p><span>&#x261E;</span>You should never use a fallback to catch <em>all</em> exceptions when importing modules (or most other times). Doing so will catch things like <code>KeyboardInterrupt</code> (if the user pressed <kbd>Ctrl-C</kbd> to interrupt the program) and can make it more difficult to debug errors.
</blockquote>
<h2 id=raise><code>raise</code> statement</h2>
<p>The syntax for raising your own exceptions has changed slightly between Python 2 and Python 3.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>raise MyException</code></td>
<td><i>unchanged</i></td></tr>
<tr><th>&#x2461;</th>
<td><code>raise MyException, "error message"</code></td>
<td><code>raise MyException("error message")</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>raise MyException, "error message", a_traceback</code></td>
<td><code>raise MyException("error message").with_traceback(a_traceback)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>raise "error message"</code></td>
<td><i>unsupported</i></td></tr>
</table>
<ol>
<li>In the simplest form, raising an exception without a custom error message, the syntax is unchanged.
<li>The change becomes noticeable when you want to raise an exception with a custom error message. Python 2 separated the exception class and the message with a comma; Python 3 passes the error message as a parameter.
<li>Python 2 supported a more complex syntax to raise an exception with a custom traceback (stack trace). You can do this in Python 3 as well, but the syntax is quite different.
<li>In Python 2, you could raise an exception with no exception class, just an error message. In Python 3, this is no longer possible. <code>2to3</code> will warn you that it was unable to fix this automatically.
</ol>
<h2 id=throw><code>throw</code> method on generators</h2>
<p>In Python 2, generators have a <code>throw()</code> method. Calling <code>a_generator.throw()</code> raises an exception at the point where the generator was paused, then returns the next value yielded by the generator function. In Python 3, this functionality is still available, but the syntax is slightly different.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>a_generator.throw(MyException)</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_generator.throw(MyException, "error message")</code></td>
<td><code>a_generator.throw(MyException("error message"))</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>a_generator.throw("error message")</code></td>
<td><i>unsupported</i></td></tr>
</table>
<ol>
<li>In the simplest form, a generator throws an exception without a custom error message. In this case, the syntax has not changed between Python 2 and Python 3.
<li>If the generator throws an exception <em>with</em> a custom error message, you need to pass the error string to the exception when you create it.
<li>Python 2 also supported throwing an exception with <em>only</em> a custom error message. Python 3 does not support this, and the <code>2to3</code> script will display a warning telling you that you will need to fix this code manually.
</ol>
<h2 id=xrange><code>xrange()</code> global function</h2>
<p>In Python 2, there were two ways to get a range of numbers: <code>range()</code>, which returned a list, and <code>xrange()</code>, which returned an iterator. In Python 3, <code>range()</code> returns an iterator, and <code>xrange()</code> doesn't exist.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>xrange(10)</code></td>
<td><code>range(10)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_list = range(10)</code></td>
<td><code>a_list = list(range(10))</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>[i for i in xrange(10)]</code></td>
<td><code>[i for i in range(10)]</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>for i in range(10):</code></td>
<td><i>no change</i></td></tr>
<tr><th>&#x2464;</th>
<td><code>sum(range(10))</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>In the simplest case, the <code>2to3</code> script will simply convert <code>xrange()</code> to <code>range()</code>.
<li>If your Python 2 code used <code>range()</code>, the <code>2to3</code> script does not know whether you needed a list, or whether an iterator would do. It errs on the side of caution and coerces the return value into a list by calling the <code>list()</code> function.
<li>If the <code>xrange()</code> function was inside a list comprehension, there is no need to coerce the result to a list, since the list comprehension will work just fine with an iterator.
<li>Similarly, a <code>for</code> loop will work just fine with an iterator, so there is no need to change anything here.
<li>The <code>sum()</code> function will also work with an iterator, so <code>2to3</code> makes no changes here either. Like <a href=#dict>dictionary methods that return views instead of lists</a>, this applies to <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>list()</code>, <code>tuple()</code>, <code>set()</code>, <code>sorted()</code>, <code>any()</code>, and <code>all()</code>.
</ol>
<h2 id=raw_input><code>raw_input()</code> and <code>input()</code> global functions</h2>
<p>Python 2 had two global functions for asking the user for input on the command line. The first, called <code>input()</code>, expected the user to enter a Python expression (and returned the result). The second, called <code>raw_input()</code>, just returned whatever the user typed. This was wildly confusing for beginners and widely regarded as a &#8220;wart&#8221; in the language. Python 3 excises this wart by renaming <code>raw_input()</code> to <code>input()</code>, so it works the way everyone naively expects it to work.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>raw_input()</code></td>
<td><code>input()</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>raw_input("prompt")</code></td>
<td><code>input("prompt")</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>input()</code></td>
<td><code>eval(input())</code></td></tr>
</table>
<ol>
<li>In the simplest form, <code>raw_input()</code> becomes <code>input()</code>.
<li>In Python 2, the <code>raw_input()</code> function could take a prompt as a parameter. This has been retained in Python 3.
<li>If you actually need to ask the user for a Python expression to evaluate, use the <code>input()</code> function and pass the result to <code>eval()</code>.
</ol>
<h2 id=funcattrs><code>func_*</code> function attributes</h2>
<p>In Python 2, code within functions can access special attributes about the function itself. In Python 3, these special function attributes have been renamed for consistency with other attributes.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>a_function.func_name</code></td>
<td><code>a_function.__name__</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_function.func_doc</code></td>
<td><code>a_function.__doc__</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>a_function.func_defaults</code></td>
<td><code>a_function.__defaults__</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>a_function.func_dict</code></td>
<td><code>a_function.__dict__</code></td></tr>
<tr><th>&#x2464;</th>
<td><code>a_function.func_closure</code></td>
<td><code>a_function.__closure__</code></td></tr>
<tr><th>&#x2465;</th>
<td><code>a_function.func_globals</code></td>
<td><code>a_function.__globals__</code></td></tr>
<tr><th>&#x2466;</th>
<td><code>a_function.func_code</code></td>
<td><code>a_function.__code__</code></td></tr>
</table>
<ol>
<li>The <code>__name__</code> attribute (previously <code>func_name</code>) contains the function's name.
<li>The <code>__doc__</code> attribute (previously <code>func_doc</code>) contains the <i>docstring</i> that you defined in the function's source code.
<li>The <code>__defaults__</code> attribute (previously <code>func_defaults</code>) is a tuple containing default argument values for those arguments that have default values.
<li>The <code>__dict__</code> attribute (previously <code>func_dict</code>) is the namespace supporting arbitrary function attributes.
<li>The <code>__closure__</code> attribute (previously <code>func_closure</code>) is a tuple of cells that contain bindings for the function's free variables.
<li>The <code>__globals__</code> attribute (previously <code>func_globals</code>) is a reference to the global namespace of the module in which the function was defined.
<li>The <code>__code__</code> attribute (previously <code>func_code</code>) is a code object representing the compiled function body.
</ol>
<h2 id=xreadlines><code>xreadlines()</code> I/O method</h2>
<p>In Python 2, file objects had an <code>xreadlines()</code> method which returned an iterator that would read the file one line at a time. This was useful in <code>for</code> loops, among other places. In fact, it was so useful, later versions of Python 2 added the capability to file objects themselves.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>for line in a_file.xreadlines():</code></td>
<td><code>for line in a_file:</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>for line in a_file.xreadlines(5):</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>If you used to call <code>xreadlines()</code> with no arguments, <code>2to3</code> will convert it to just the file object. In Python 3, this will accomplish the same thing: read the file one line at a time and execute the body of the <code>for</code> loop.
<li>If you used to call <code>xreadlines()</code> with an argument (the number of lines to read at a time), keep doing that. It still works in Python 3, and <code>2to3</code> will not change it.
</ol>
<p class=c><span style="font-size:56px;line-height:0.88">&#x2603;</span>
<h2 id=tuple_params><code>lambda</code> functions that take a tuple instead of multiple parameters</h2>
<p>In Python 2, you could define anonymous <code>lambda</code> functions which took multiple parameters by defining the function as taking a tuple with a specific number of items. In effect, Python 2 would &#8220;unpack&#8221; the tuple into named arguments, which you could then reference (by name) within the <code>lambda</code> function. In Python 3, you can still pass a tuple to a <code>lambda</code> function, but the Python interpreter will not unpack the tuple into named arguments. Instead, you will need to reference each argument by its positional index.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>lambda (x,): x + f(x)</code></td>
<td><code>lambda x1: x1[0] + f(x1[0])</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>lambda (x, y): x + f(y)</code></td>
<td><code>lambda x_y: x_y[0] + f(x_y[1])</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>lambda (x, (y, z)): x + y + z</code></td>
<td><code>lambda x_y_z: x_y_z[0] + x_y_z[1][0] + x_y_z[1][1]</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>lambda x, y, z: x + y + z</code></td>
<td><i>unchanged</i></td></tr>
</table>
<ol>
<li>If you had defined a <code>lambda</code> function that took a tuple of one item, in Python 3 that would become a <code>lambda</code> with references to <var>x1[0]</var>. The name <var>x1</var> is autogenerated by the <code>2to3</code> script, based on the named arguments in the original tuple.
<li>A <code>lambda</code> function with a two-item tuple <var>(x, y)</var> gets converted to <var>x_y</var> with positional arguments <var>x_y[0]</var> and <var>x_y[1]</var>.
<li>The <code>2to3</code> script can even handle <code>lambda</code> functions with nested tuples of named arguments. The resulting Python 3 code is a bit unreadable, but it works the same as the old code did in Python 2.
<li>You can define <code>lambda</code> functions that take multiple arguments. Without parentheses around the arguments, Python 2 just treats it as a <code>lambda</code> function with multiple arguments; within the <code>lambda</code> function, you simply reference the arguments by name, just like any other function. This syntax still works in Python 3.
</ol>
<h2 id=methodattrs>Special method attributes</h2>
<p>In Python 2, class methods can reference the class object they are defined in, as well as the method object itself.  <code>im_self</code> is the class instance object; the class <code>im_func</code> is the function object; <code>im_class</code> is the class of <code>im_self</code> (for bound methods) or the class that asked for the method (for unbound methods). In Python 3, these special method attributes have been renamed to follow the naming conventions of other attributes.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>aClassInstance.aClassMethod.im_func</code></td>
<td><code>aClassInstance.aClassMethod.__func__</code></td></tr>
<tr><th></th>
<td><code>aClassInstance.aClassMethod.im_self</code></td>
<td><code>aClassInstance.aClassMethod.__self__</code></td></tr>
<tr><th></th>
<td><code>aClassInstance.aClassMethod.im_class</code></td>
<td><code>aClassInstance.aClassMethod.self.__class__</code></td></tr>
</table>
<h2 id=nonzero><code>__nonzero__</code> special class attribute</h2>
<p>In Python 2, you could build your own classes that could be used in a boolean context. For example, you could instantiate the class and then use the instance in an <code>if</code> statement. To do this, you defined a special <code>__nonzero__()</code> method which returned <code>True</code> or <code>False</code>, and it was called whenever the instance was used in a boolean context. In Python 3, you can still do this, but the name of the method has changed to <code>__bool__()</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><pre><code>class A:
    def __nonzero__(self):
        pass</code></pre></td>
<td><pre><code>class A:
    def __bool__(self):
        pass</code></pre></td></tr>
<tr><th>&#x2461;</th>
<td><pre><code>class A:
    def __nonzero__(self, x, y):
        pass</code></pre></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>Instead of <code>__nonzero__()</code>, Python 3 calls the <code>__bool__()</code> method when evaluating an instance in a boolean context.
<li>However, if you have a <code>__nonzero__()</code> method that takes arguments, the <code>2to3</code> tool will assume that you were using it for some other purpose, and it will not make any changes.
</ol>
<h2 id=numliterals>Octal literals</h2>
<p>The syntax for defining base 8 (octal) numbers has changed slightly between Python 2 and Python 3.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>x = 0755</code></td>
<td><code>x = 0o755</code></td></tr>
</table>
<h2 id=renames><code>sys.maxint</code></h2>
<p>Due to the <a href=#long>integration of the <code>long</code> and <code>int</code> types</a>, the <code>sys.maxint</code> constant is no longer accurate. Because the value may still be useful in determining platform-specific capabilities, it has been retained but renamed as <code>sys.maxsize</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>from sys import maxint</code></td>
<td><code>from sys import maxsize</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>a_function(sys.maxint)</code></td>
<td><code>a_function(sys.maxsize)</code></td></tr>
</table>
<ol>
<li><code>maxint</code> becomes <code>maxsize</code>.
<li>Any usage of <code>sys.maxint</code> becomes <code>sys.maxsize</code>.
</ol>
<h2 id=callable><code>callable()</code> global function</h2>
<p>In Python 2, you could check whether an object was callable (like a function) with the global <code>callable()</code> function. In Python 3, this global function has been eliminated. To check whether an object is callable, check for the existence of the <code>__call__()</code> special method.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>callable(anything)</code></td>
<td><code>hasattr(anything, "__call__")</code></td></tr>
</table>
<h2 id=zip><code>zip()</code> global function</h2>
<p>In Python 2, the global <code>zip()</code> function took any number of sequences and returned a list of tuples. The first tuple contained the first item from each sequence; the second tuple contained the second item from each sequence; and so on. In Python 3, <code>zip()</code> returns an iterator instead of a list.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>zip(a, b, c)</code></td>
<td><code>list(zip(a, b, c))</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>d.join(zip(a, b, c))</code></td>
<td><i>no change</i></td></tr>
</table>
<ol>
<li>In the simplest form, you can get the old behavior of the <code>zip()</code> function by wrapping the return value in a call to <code>list()</code>, which will run through the iterator that <code>zip()</code> returns and return a real list of the results.
<li>In contexts that already iterate through all the items of a sequence (such as this call to the <code>join()</code> method), the iterator that <code>zip()</code> returns will work just fine. The <code>2to3</code> script is smart enough to detect these cases and make no change to your code.
</ol>
<h2 id=standarderror><code>StandardError</code> exception</h2>
<p>In Python 2, <code>StandardError</code> was the base class for all built-in exceptions other than <code>StopIteration</code>, <code>GeneratorExit</code>, <code>KeyboardInterrupt</code>, and <code>SystemExit</code>. In Python 3, <code>StandardError</code> has been eliminated; use <code>Exception</code> instead.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>x = StandardError()</code></td>
<td><code>x = Exception()</code></td></tr>
<tr><th></th>
<td><code>x = StandardError(a, b, c)</code></td>
<td><code>x = Exception(a, b, c)</code></td></tr>
</table>
<h2 id=types><code>types</code> module constants</h2>
<p>The <code>types</code> module contains a variety of constants to help you determine the type of an object. In Python 2, it contained constants for all primitive types like <code>dict</code> and <code>int</code>. In Python 3, these constants have been eliminated; just use the primitive type name instead.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>types.StringType</code></td>
<td><code>bytes</code></td></tr>
<tr><th></th>
<td><code>types.DictType</code></td>
<td><code>dict</code></td></tr>
<tr><th></th>
<td><code>types.IntType</code></td>
<td><code>int</code></td></tr>
<tr><th></th>
<td><code>types.LongType</code></td>
<td><code>int</code></td></tr>
<tr><th></th>
<td><code>types.ListType</code></td>
<td><code>list</code></td></tr>
<tr><th></th>
<td><code>types.NoneType</code></td>
<td><code>type(None)</code></td></tr>
</table>
<h2 id=isinstance><code>isinstance()</code> global function (3.1+)</h2>
<p>The <code>isinstance()</code> function checks whether an object is an instance of a particular class or type. In Python 2, you could pass a tuple of types, and <code>isinstance()</code> would return <code>True</code> if the object was any of those types. In Python 3, you can still do this, but passing the same type twice is deprecated.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>isinstance(x, (int, float, int))</code></td>
<td><code>isinstance(x, (int, float))</code></td></tr>
</table>
<blockquote>
<p><span>&#x261E;</span>The version of <code>2to3</code> that shipped with Python 3.0 would not fix these cases of <code>isinstance()</code> automatically. The fix first appeared in the <code>2to3</code> script that shipped with Python 3.1.
</blockquote>
<h2 id=basestring><code>basestring</code> datatype</h2>
<p>Python 2 had two string types: Unicode and non-Unicode. But there was also another type, <code>basestring</code>. It was an abstract type, a superclass for both the <code>str</code> and <code>unicode</code> types. It couldn't be called or instantiated directly, but you could pass it to the global <code>isinstance()</code> function to check whether an object was either a Unicode or non-Unicode string. In Python 3, there is only one string type, so <code>basestring</code> has no reason to exist.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>isinstance(x, basestring)</code></td>
<td><code>isinstance(x, str)</code></td></tr>
</table>
<h2 id=itertools><code>itertools</code> module</h2>
<p>Python 2.3 introduced the <code>itertools</code> module, which defined variants of the global <code>zip()</code>, <code>map()</code>, and <code>filter()</code> functions that returned iterators instead of lists. In Python 3, those global functions return iterators, so those functions in the <code>itertools</code> module have been eliminated.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><code>itertools.izip(a, b)</code></td>
<td><code>zip(a, b)</code></td></tr>
<tr><th>&#x2461;</th>
<td><code>itertools.imap(a, b)</code></td>
<td><code>map(a, b)</code></td></tr>
<tr><th>&#x2462;</th>
<td><code>itertools.ifilter(a, b)</code></td>
<td><code>filter(a, b)</code></td></tr>
<tr><th>&#x2463;</th>
<td><code>from itertools import imap, izip, foo</code></td>
<td><code>from itertools import foo</code></td></tr>
</table>
<ol>
<li>Instead of <code>itertools.izip()</code>, just use the global <code>zip()</code> function.
<li>Instead of <code>itertools.imap()</code>, just use <code>map()</code>.
<li><code>itertools.ifilter()</code> becomes <code>filter()</code>.
<li>The <code>itertools</code> module still exists in Python 3, it just doesn't have the functions that have migrated to the global namespace. The <code>2to3</code> script is smart enough to remove the specific imports that no longer exist, while leaving other imports intact.
</ol>
<h2 id=sys_exc><code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code></h2>
<p>Python 2 had three variables in the <code>sys</code> module that you could access while an exception was being handled: <code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code>. (Actually, these date all the way back to Python 1.)  Ever since Python 1.5, these variables have been deprecated in favor of <code>sys.exc_info</code>, which is a tuple that contains all three values. In Python 3, these individual variables have finally gone away; you must use <code>sys.exc_info</code>.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>sys.exc_type</code></td>
<td><code>sys.exc_info()[0]</code></td></tr>
<tr><th></th>
<td><code>sys.exc_value</code></td>
<td><code>sys.exc_info()[1]</code></td></tr>
<tr><th></th>
<td><code>sys.exc_traceback</code></td>
<td><code>sys.exc_info()[2]</code></td></tr>
</table>
<h2 id=paren>List comprehensions over tuples</h2>
<p>In Python 2, if you wanted to code a list comprehension that iterated over a tuple, you did not need to put parentheses around the tuple values. In Python 3, explicit parentheses are required.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>[i for i in 1, 2]</code></td>
<td><code>[i for i in (1, 2)]</code></td></tr>
</table>
<h2 id=getcwdu><code>os.getcwdu()</code> function</h2>
<p>Python 2 had a function named <code>os.getcwd()</code>, which returned the current working directory as a (non-Unicode) string. Because modern file systems can handle directory names in any character encoding, Python 2.3 introduced <code>os.getcwdu()</code>. The <code>os.getcwdu()</code> function returned the current working directory as a Unicode string. In Python 3, there is only one string type (Unicode), so <code>os.getcwd()</code> is all you need.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th></th>
<td><code>os.getcwdu()</code></td>
<td><code>os.getcwd()</code></td></tr>
</table>
<h2 id=metaclass>Metaclasses</h2>
<p>In Python 2, you could create metaclasses either by defining the <code>metaclass</code> argument in the class declaration, or by defining a special class-level <code>__metaclass__</code> attribute. In Python 3, the class-level attribute has been eliminated.
<table>
<tr><th>Notes</th>
<th>Python 2</th>
<th>Python 3</th>
</tr>
<tr><th>&#x2460;</th>
<td><pre><code>class C(metaclass=PapayaMeta):
    pass</code></pre></td>
<td><i>unchanged</i></td></tr>
<tr><th>&#x2461;</th>
<td><pre><code>class Whip:
    __metaclass__ = PapayaMeta</code></pre></td>
<td><pre><code>class Whip(metaclass=PapayaMeta):
    pass</code></pre></td></tr>
<tr><th>&#x2462;</th>
<td><pre><code>class C(Whipper, Beater):
    __metaclass__ = PapayaMeta</code></pre></td>
<td><pre><code>class C(Whipper, Beater, metaclass=PapayaMeta):
    pass</code></pre></td></tr>
</table>
<ol>
<li>Declaring the metaclass in the class declaration worked in Python 2, and it still works the same in Python 3.
<li>Declaring the metaclass in a class attribute worked in Python 2, but doesn't work in Python 3.
<li>The <code>2to3</code> script is smart enough to construct a valid class declaration, even if the class is inherited from one or more base classes.
</ol>
<h2 id=nitpick>Matters of style</h2>
<p>The rest of the &#8220;fixes&#8221; listed here aren't really fixes per se. That is, the things they change are matters of style, not substance. They work just as well in Python 3 as they do in Python 2, but the developers of Python have a vested interest in making Python code as uniform as possible. To that end, there is an <a href=http://www.python.org/dev/peps/pep-0008/>official Python style guide</a> which outlines &mdash; in excruciating detail &mdash; all sorts of nitpicky details that you almost certainly don't care about. And given that <code>2to3</code> provides such a great infrastructure for converting Python code from one thing to another, the authors took it upon themselves to add a few optional features to improve the readability of your Python programs.
<h3 id=set_literal><code>set()</code> literals (explicit)</h3>
<p>In Python 2, the only way to define a literal set in your code was to call <code>set(a_sequence)</code>. This still works in Python 3, but a clearer way of doing it is to use the new set literal notation: curly braces. (Dictionaries are also defined with curly braces, which makes sense once you think about it, because dictionaries are just sets of key-value pairs.)
<blockquote class=note>
<p><span>&#x261E;</span>The <code>2to3</code> script will not fix <code>set()</code> literals by default. To enable this fix, specify <kbd>-f set_literal</kbd> on the command line when you call <code>2to3</code>.
</blockquote>
<table>
<tr><th>Notes</th>
<th>Before</th>
<th>After</th>
</tr>
<tr><th></th>
<td><code>set([1, 2, 3])</code></td>
<td><code>{1, 2, 3}</code></td></tr>
<tr><th></th>
<td><code>set((1, 2, 3))</code></td>
<td><code>{1, 2, 3}</code></td></tr>
<tr><th></th>
<td><code>set([i for i in a_sequence])</code></td>
<td><code>{i for i in a_sequence}</code></td></tr>
</table>
<h3 id=buffer><code>buffer()</code> global function (explicit)</h3>
<p>Python objects implemented in C can export a &#8220;buffer interface,&#8221; which is a block of memory that is directly readable and writeable without copying. (That is exactly as powerful and scary as it sounds.)  In Python 3, <code>buffer()</code> has been renamed to <code>memoryview()</code>. (It's a little more complicated than that, but you can almost certainly ignore the differences.)
<blockquote class=note>
<p><span>&#x261E;</span>The <code>2to3</code> script will not fix the <code>buffer()</code> function by default. To enable this fix, specify <kbd>-f buffer</kbd> on the command line when you call <code>2to3</code>.
</blockquote>
<table>
<tr><th>Notes</th>
<th>Before</th>
<th>After</th>
</tr>
<tr><th></th>
<td><code>x = buffer(y)</code></td>
<td><code>x = memoryview(y)</code></td></tr>
</table>
<h3 id=wscomma>Whitespace around commas (explicit)</h3>
<p>Despite being draconian about whitespace for indenting and outdenting, Python is actually quite liberal about whitespace in other areas. Within lists, tuples, sets, and dictionaries, whitespace can appear before and after commas with no ill effects. However, the Python style guide states that commas should be preceded by zero spaces and followed by one. Although this is purely an aesthetic issue (the code works either way, in both Python 2 and Python 3), the <code>2to3</code> script can optionally fix this for you.
<blockquote class=note>
<p><span>&#x261E;</span>The <code>2to3</code> script will not fix whitespace around commas by default. To enable this fix, specify <kbd>-f wscomma</kbd> on the command line when you call <code>2to3</code>.
</blockquote>
<table>
<tr><th>Notes</th>
<th>Before</th>
<th>After</th>
</tr>
<tr><th></th>
<td><code>a ,b</code></td>
<td><code>a, b</code></td></tr>
<tr><th></th>
<td><code>{a :b}</code></td>
<td><code>{a: b}</code></td></tr>
</table>
<h3 id=idioms>Common idioms (explicit)</h3>
<p>There were a number of common idioms built up in the Python community. Some, like the <code>while 1:</code> loop, date back to Python 1. (Python didn't have a true boolean type until version 2.3, so developers used <code>1</code> and <code>0</code> instead.)  Modern Python programmers should train their brains to use modern versions of these idioms instead.
<blockquote class=note>
<p><span>&#x261E;</span>The <code>2to3</code> script will not fix common idioms by default. To enable this fix, specify <kbd>-f idioms</kbd> on the command line when you call <code>2to3</code>.
</blockquote>
<table>
<tr><th>Notes</th>
<th>Before</th>
<th>After</th>
</tr>
<tr><th></th>
<td><pre><code>while 1:
    do_stuff()</code></pre></td>
<td><pre><code>while True:
    do_stuff()</code></pre></td></tr>
<tr><th></th>
<td><code>type(x) == T</code></td>
<td><code>isinstance(x, T)</code></td></tr>
<tr><th></th>
<td><code>type(x) is T</code></td>
<td><code>isinstance(x, T)</code></td></tr>
<tr><th></th>
<td><pre><code>a_list = list(a_sequence)
a_list.sort()
do_stuff(a_list)</code></pre></td>
<td><pre><code>a_list = sorted(a_sequence)
do_stuff(a_list)</code></pre></td></tr>
</table>
<p>FIXME: once the rest of the book is written, this appendix should contain copious links back to any chapter or section that touches on these features.
<p class=c>&copy; 2001&ndash;9 <a href=about.html>Mark Pilgrim</a>
<script src=jquery.js></script>
<script src=dip3.js></script>
