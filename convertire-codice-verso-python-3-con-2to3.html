<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Convertire codice verso Python 3 con 2to3 - Dive into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<link rel=stylesheet href=dip3-it.css>
<style>
h1:before{counter-increment:h1;content:'Appendice A. '}
h2:before{counter-increment:h2;content:'A.' counter(h2) '. '}
h3:before{counter-increment:h3;content:'A.' counter(h2) '.' counter(h3) '. '}
tr + tr th:first-child{font:medium 'Arial Unicode MS',FreeSerif,OpenSymbol,'DejaVu Sans',sans-serif}
table{width:100%;border-collapse:collapse}
th,td{width:45%;padding:0 0.5em;border:1px solid #bbb}
th{text-align:left;vertical-align:baseline}
td{vertical-align:top}
th:first-child{width:10%;text-align:center}
th,td,td pre{margin:0}
td pre{padding:0;border:0}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta content='initial-scale=1.0' name=viewport>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input name=ie type=hidden value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input name=sa type=submit value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#porting-code-to-python-3-with-2to3>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>Livello di difficoltà: <span class=u title=pro>&#x2666;&#x2666;&#x2666;&#x2666;&#x2666;</span>
<h1>Convertire codice verso Python 3 con <code>2to3</code></h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> La vita è piacevole. La morte è pacifica. &Egrave; la transizione che crea dei problemi. <span class=u>&#x275E;</span><br>&mdash; Isaac Asimov (attribuita)
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>Di fatto, tutti i programmi scritti in Python 2 avranno almeno bisogno di qualche ritocco per poter essere eseguiti correttamente sotto Python 3. Per facilitare questa transizione, Python 3 include uno script di utilità chiamato <code>2to3</code>, che prende in ingresso il vostro codice sorgente in Python 2 e lo converte automaticamente verso Python 3 tanto quanto gli è possibile. Il <a href=caso-di-studio-convertire-chardet-verso-python-3.html#running2to3>Caso di studio: convertire <code>chardet</code> verso Python 3</a> descrive come eseguire <code>2to3</code>, poi mostra alcune cose che lo script non riesce a correggere automaticamente. Questa appendice documenta ciò che lo script <em>può</em> correggere automaticamente
<h2 id=print>L'istruzione <code>print</code></h2>
<p>In Python 2, <code><dfn>print</dfn></code> era una istruzione. Per stampare una cosa qualsiasi bastava farla seguire alla parola chiave <code>print</code>. In Python 3, <code>print()</code> è una funzione &mdash; ogni cosa che volete stampare viene passata a <code>print()</code> come a qualsiasi altra funzione.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>print</code>
<td><code class=pp>print()</code>
<tr><th>&#x2461;
<td><code class=pp>print 1</code>
<td><code class=pp>print(1)</code>
<tr><th>&#x2462;
<td><code class=pp>print 1, 2</code>
<td><code class=pp>print(1, 2)</code>
<tr><th>&#x2463;
<td><code class=pp>print 1, 2,</code>
<td><code class=pp>print(1, 2, end=' ')</code>
<tr><th>&#x2464;
<td><code class=pp>print >>sys.stderr, 1, 2, 3</code>
<td><code class=pp>print(1, 2, 3, file=sys.stderr)</code>
</table>
<ol>
<li>Per stampare una riga vuota, invocate <code>print()</code> senza alcun argomento.
<li>Per stampare un singolo valore, invocate <code>print()</code> con un argomento.
<li>Per stampare due valori separati da uno spazio, invocate <code>print()</code> con due argomenti.
<li>Questo è un po' complicato. In Python 2, una istruzione <code>print</code> conclusa da una virgola avrebbe stampato i valori separati da spazi, seguiti da uno spazio finale, evitando di stampare un ritorno a capo. Per ottenere questo comportamento in Python 3, è necessario passare <code>end=' '</code> come argomento con nome alla funzione <code>print()</code>. L'argomento <code>end</code> assume <code>'\n'</code> (un ritorno a capo) come valore di default, quindi modificarlo sopprimerà il ritorno a capo dopo la stampa degli altri argomenti.
<li>In Python 2, potevate redirigere l'uscita verso una pipe &mdash; come <code>sys.stderr</code> &mdash; utilizzando la sintassi <code>>>nome_della_pipe</code>. Per ottenere la redirezione in Python 3, è necessario passare la pipe come valore all'argomento con nome <code>file</code>. L'argomento <code>file</code> assume <code>sys.stdout</code> (uscita standard) come valore di default, quindi modificarlo produrrà l'uscita su una pipe differente.
</ol>
<h2 id=unicodeliteral>Letterali stringa Unicode</h2>
<p>Python 2 aveva due tipi di stringa: stringhe <dfn>Unicode</dfn> e stringhe non Unicode. Python 3 ha un solo tipo di stringa: stringhe Unicode.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>u'PapayaWhip'</code>
<td><code class=pp>'PapayaWhip'</code>
<tr><th>&#x2461;
<td><code class=pp>ur'PapayaWhip\foo'</code>
<td><code class=pp>r'PapayaWhip\foo'</code>
</table>
<ol>
<li>I letterali stringa Unicode sono semplicemente convertiti in letterali stringa, che in Python 3 sono sempre di tipo Unicode.
<li>Le stringhe <i>raw</i> Unicode (in cui Python non effettua l'escape automatico dei backslash) vengono convertite a stringhe raw. In Python 3, le stringhe raw sono sempre di tipo Unicode.
</ol>
<h2 id=unicode>La funzione globale <code>unicode()</code></h2>
<p>Python 2 aveva due funzioni globali per convertire oggetti in stringhe: <code>unicode()</code> per convertirli a stringhe Unicode e <code>str()</code> per convertirli a stringhe non Unicode. Python 3 ha un solo tipo di stringhe, stringhe Unicode, quindi la funzione <code>str()</code> è tutto quello che vi serve. (La funzione <code>unicode()</code> non esiste più.)
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>unicode(anything)</code>
<td><code class=pp>str(anything)</code>
</table>
<h2 id=long>Il tipo di dato <code>long</code></h2>
<p>Python 2 aveva tipi <code>int</code> e <code><dfn>long</dfn></code> separati per i numeri non in virgola mobile. Un <code>int</code> non poteva essere più grande di <a href=#renames><code>sys.maxint</code></a>, il cui valore variava a seconda della piattaforma. I <code>long</code> erano definiti aggiungendo una <code>L</code> alla fine del numero e potevano essere, be', più lunghi degli <code>int</code>. In Python 3, c'è solo un tipo di numeri interi, chiamato <code>int</code>, che per la maggior parte si comporta come il tipo <code>long</code> in Python 2. Dato che non ci sono più due tipi, non c'è alcun bisogno di una sintassi speciale per distinguerli.
<p>Per approfondire l'argomento, si consiglia la lettura della <a href=http://www.python.org/dev/peps/pep-0237/><abbr>PEP</abbr> 237: Unificare gli interi lunghi e gli interi</a>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>x = 1000000000000L</code>
<td><code class=pp>x = 1000000000000</code>
<tr><th>&#x2461;
<td><code class=pp>x = 0xFFFFFFFFFFFFL</code>
<td><code class=pp>x = 0xFFFFFFFFFFFF</code>
<tr><th>&#x2462;
<td><code class=pp>long(x)</code>
<td><code class=pp>int(x)</code>
<tr><th>&#x2463;
<td><code class=pp>type(x) is long</code>
<td><code class=pp>type(x) is int</code>
<tr><th>&#x2464;
<td><code class=pp>isinstance(x, long)</code>
<td><code class=pp>isinstance(x, int)</code>
</table>
<ol>
<li>I letterali <code>long</code> in base 10 diventano letterali <code>int</code> in base 10.
<li>I letterali <code>long</code> in base 16 diventano letterali <code>int</code> in base 16.
<li>In Python 3, la vecchia funzione <code>long()</code> non esiste più, dato che i <code>long</code> non esistono più. Per convertire una variabile a un intero, usate la funzione <code>int()</code>.
<li>Per controllare se una variabile è un intero, recuperatene il tipo e confrontatelo con <code>int</code>, non con <code>long</code>.
<li>Potete anche usare la funzione <code>isinstance()</code> per controllare i tipi di dato; ancora, usate <code>int</code>, non <code>long</code>, per controllare gli interi.
</ol>
<h2 id=ne>Il confronto di disuguaglianza con &lt;></h2>
<p>Python 2 supportava <code>&lt;></code> come sinonimo di <code>!=</code>, l'operatore per il confronto di disuguaglianza. Python 3 supporta l'operatore <code>!=</code>, ma non <code>&lt;></code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>if x &lt;> y:</code>
<td><code class=pp>if x != y:</code>
<tr><th>&#x2461;
<td><code class=pp>if x &lt;> y &lt;> z:</code>
<td><code class=pp>if x != y != z:</code>
</table>
<ol>
<li>Un semplice confronto.
<li>Un confronto più complesso tra tre valori.
</ol>
<h2 id=has_key>Il metodo <code>has_key()</code> per i dizionari</h2>
<p>In Python 2, i dizionari avevano un metodo <code><dfn>has_key</dfn>()</code> per verificare che il dizionario contenesse una certa chiave. In Python 3, questo metodo non esiste più. Al suo posto dovete usare l'operatore <code>in</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>a_dictionary.has_key('PapayaWhip')</code>
<td><code class=pp>'PapayaWhip' in a_dictionary</code>
<tr><th>&#x2461;</th >
<td><code class=pp>a_dictionary.has_key(x) or a_dictionary.has_key(y)</code>
<td><code class=pp>x in a_dictionary or y in a_dictionary</code>
<tr><th>&#x2462;
<td><code class=pp>a_dictionary.has_key(x or y)</code>
<td><code class=pp>(x or y) in a_dictionary</code>
<tr><th>&#x2463;
<td><code class=pp>a_dictionary.has_key(x + y)</code>
<td><code class=pp>(x + y) in a_dictionary</code>
<tr><th>&#x2464;
<td><code class=pp>x + a_dictionary.has_key(y)</code>
<td><code class=pp>x + (y in a_dictionary)</code>
</table>
<ol>
<li>La forma più semplice.
<li>L'operatore <code>or</code> ha la precedenza sull'operatore <code>in</code>, quindi in questo caso non c'è alcun bisogno di usare le parentesi.
<li>D'altra parte, in questo caso <em>avete</em> bisogno di usare le parentesi, per lo stesso motivo &mdash; <code>or</code> ha la precedenza su <code>in</code>.
<li>L'operatore <code>in</code> ha la precedenza sull'operatore <code>+</code>, quindi questa forma non avrebbe tecnicamente bisogno delle parentesi, ma <code>2to3</code> le aggiunge comunque.
<li>Questa forma ha certamente bisogno delle parentesi, dato che l'operatore <code>in</code> ha la precedenza sull'operatore <code>+</code>.
</ol>
<h2 id=dict>Metodi dei dizionari che restituiscono liste</h2>
<p>In Python 2, molti metodi dei dizionari restituivano liste. I metodi più frequentemente usati erano <code><dfn>keys</dfn>()</code>, <code><dfn>items</dfn>()</code> e <code><dfn>values</dfn>()</code>. In Python 3, tutti questi metodi restituiscono <dfn>viste</dfn> dinamiche. In alcuni contesti questo non è un problema. Se il valore di ritorno del metodo viene immediatamente passato a un'altra funzione che itera attraverso l'intera sequenza, non fa alcuna differenza che il tipo reale di quel valore sia una lista o una vista. In altri contesti ha invece molta importanza. Se vi stavate aspettando una lista completa con elementi accessibili individualmente, il vostro programma si bloccherà perché le viste non supportano l'accesso basato su indici.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>a_dictionary.keys()</code>
<td><code class=pp>list(a_dictionary.keys())</code>
<tr><th>&#x2461;
<td><code class=pp>a_dictionary.items()</code>
<td><code class=pp>list(a_dictionary.items())</code>
<tr><th>&#x2462;
<td><code class=pp>a_dictionary.iterkeys()</code>
<td><code class=pp>iter(a_dictionary.keys())</code>
<tr><th>&#x2463;
<td><code class=pp>[i for i in a_dictionary.iterkeys()]</code>
<td><code class=pp>[i for i in a_dictionary.keys()]</code>
<tr><th>&#x2464;
<td><code class=pp>min(a_dictionary.keys())</code>
<td><i>no change</i>
</table>
<ol>
<li><code>2to3</code> pecca per eccesso di prudenza, convertendo il valore di ritorno di <code>keys()</code> a una lista statica tramite la funzione <code>list()</code>. Questo codice funzionerà sempre, ma sarà meno efficiente rispetto all'uso di una vista. Dovreste esaminare il codice convertito per controllare se una lista è assolutamente necessaria o se una vista sarebbe sufficiente.
<li>Un'altra conversione da vista a lista, questa volta con il metodo <code>items()</code>. <code>2to3</code> farà la stessa cosa con il metodo <code>values()</code>.
<li>Python 3 non supporta più il metodo <code>iterkeys()</code>. Usate <code>keys()</code> e, se necessario, convertite la vista in un iteratore tramite la funzione <code>iter()</code>.
<li><code>2to3</code> riconosce quando il metodo <code>iterkeys()</code> viene usato in una descrizione di lista e lo converte al metodo <code>keys()</code> (senza circondarlo in una chiamata aggiuntiva a <code>iter()</code>). Questa modifica funziona perché le viste sono iterabili.
<li><code>2to3</code> riconosce che il risultato restituito dal metodo <code>keys()</code> viene immediatamente passato a una funzione che itera su un'intera sequenza, così non ha bisogno di convertirne il valore a una lista. La funzione <code>min()</code> itererà tranquillamente attraverso la vista. Queste considerazioni valgono per le funzioni <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>list()</code>, <code>tuple()</code>, <code>set()</code>, <code>sorted()</code>, <code>any()</code>, e <code>all()</code>.
</ol>
<h2 id=imports>Moduli che sono stati rinominati o riorganizzati</h2>
<p>Diversi moduli nella libreria standard di Python sono stati rinominati. Diversi altri moduli in relazione tra loro sono stati combinati o riorganizzati per rendere le loro associazioni più logiche.
<h3 id=http><code>http</code></h3>
<p>In Python 3, molti moduli relativi al protocollo <abbr>HTTP</abbr> sono stati combinati in un unico package chiamato <code>http</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>import <dfn>httplib</dfn></code>
<td><code class=pp>import http.client</code>
<tr><th>&#x2461;
<td><code class=pp>import <dfn>Cookie</dfn></code>
<td><code class=pp>import http.cookies</code>
<tr><th>&#x2462;
<td><code class=pp>import <dfn>cookielib</dfn></code>
<td><code class=pp>import http.cookiejar</code>
<tr><th>&#x2463;
<td><pre><code class=pp>import <dfn>BaseHTTPServer</dfn>
import <dfn>SimpleHTTPServer</dfn>
import <dfn>CGIHttpServer</dfn></code></pre>
<td><code class=pp>import http.server</code>
</table>
<ol>
<li>Il modulo <code>http.client</code> implementa una libreria di basso livello che può richiedere risorse <abbr>HTTP</abbr> e interpretare le risposte <abbr>HTTP</abbr>.
<li>Il modulo <code>http.cookies</code> fornisce un'interfaccia Python ai cookie che sono inviati a un browser tramite l'intestazione <abbr>HTTP</abbr> <code>Set-Cookie:</code>.
<li>Il modulo <code>http.cookiejar</code> manipola gli effettivi file che i browser web più popolari utilizzano per memorizzare i cookie.
<li>Il modulo <code>http.server</code> fornisce un server <abbr>HTTP</abbr> di base.
</ol>
<h3 id=urllib><code>urllib</code></h3>
<p>Python 2 aveva un macello di moduli sovrapposti per riconoscere, codificare e recuperare gli <abbr>URL</abbr>. In Python 3, tutti questi moduli sono stati riorganizzati e combinati in un singolo package chiamato <code>urllib</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>import <dfn>urllib</dfn></code>
<td><code class=pp>import urllib.request, urllib.parse, urllib.error</code>
<tr><th>&#x2461;
<td><code class=pp>import <dfn>urllib2</dfn></code>
<td><code class=pp>import urllib.request, urllib.error</code>
<tr><th>&#x2462;
<td><code class=pp>import <dfn>urlparse</dfn></code>
<td><code class=pp>import urllib.parse</code>
<tr><th>&#x2463;
<td><code class=pp>import <dfn>robotparser</dfn></code>
<td><code class=pp>import urllib.robotparser</code>
<tr><th>&#x2464;
<td><pre><code class=pp>from urllib import <dfn>FancyURLopener</dfn>
from urllib import urlencode</code></pre>
<td><pre><code class=pp>from urllib.request import FancyURLopener
from urllib.parse import urlencode</code></pre>
<tr><th>&#x2465;
<td><pre><code class=pp>from urllib2 import <dfn>Request</dfn>
from urllib2 import <dfn>HTTPError</dfn></code></pre>
<td><pre><code class=pp>from urllib.request import Request
from urllib.error import HTTPError</code></pre>
</table>
<ol>
<li>Il vecchio modulo <code>urllib</code> di Python 2 raccoglieva una varietà di funzioni, comprese <code>urlopen()</code> per recuperare dati e <code>splittype()</code>, <code>splithost()</code> e <code>splituser()</code> per suddividere un <abbr>URL</abbr> nelle sue parti costituenti. Queste funzioni sono state riorganizzate più logicamente nell'ambito del nuovo package <code>urllib</code>. <code>2to3</code> modificherà anche tutte le chiamate a queste funzioni in modo da usare il nuovo schema di nomi.
<li>Il vecchio modulo <code>urllib2</code> di Python 2 è stato incorporato nel package <code>urllib</code> in Python 3. Tutte le vostre funzionalità preferite di <code>urllib2</code> &mdash; il metodo <code>build_opener()</code>, gli oggetti <code>Request</code>, <code>HTTPBasicAuthHandler</code> e compagnia &mdash; sono ancora disponibili.
<li>Il modulo <code>urllib.parse</code> di Python 3 contiene tutte le funzioni di riconoscimento del vecchio modulo <code>urlparse</code> di Python 2.
<li>Il modulo <code>urllib.robotparser</code> riconosce i <a href=http://www.robotstxt.org/>file <code>robots.txt</code></a>.
<li>La classe <code>FancyURLopener</code>, che gestisce le redirezioni <abbr>HTTP</abbr> e altri codici di stato, è ancora disponibile nel nuovo modulo <code>urllib.request</code>. La funzione <code>urlencode()</code> è stata spostata in <code>urllib.parse</code>.
<li>L'oggetto <code>Request</code> è ancora disponibile in <code>urllib.request</code>, ma costanti come <code>HTTPError</code> sono state spostate in <code>urllib.error</code>.
</ol>
<h3 id=dbm><code>dbm</code></h3>
<p>Tutti i vari cloni di <abbr>DBM</abbr> si trovano ora in un singolo package chiamato <code>dbm</code>. Se avete bisogno di una specifica variante come <abbr>GNU</abbr> <abbr>DBM</abbr>, potete importare il modulo appropriato nell'ambito del package <code>dbm</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>import <dfn>dbm</dfn></code>
<td><code class=pp>import dbm.ndbm</code>
<tr><th>
<td><code class=pp>import <dfn>gdbm</dfn></code>
<td><code class=pp>import dbm.gnu</code>
<tr><th>
<td><code class=pp>import <dfn>dbhash</dfn></code>
<td><code class=pp>import dbm.bsd</code>
<tr><th>
<td><code class=pp>import <dfn>dumbdbm</dfn></code>
<td><code class=pp>import dbm.dumb</code>
<tr><th>
<td><pre><code class=pp>import <dfn>anydbm</dfn>
import whichdb</code></pre>
<td><code class=pp>import dbm</code>
</table>
<h3 id=xmlrpc><code>xmlrpc</code></h3>
<p><abbr>XML-RPC</abbr> è un metodo leggero per eseguire chiamate <abbr>RPC</abbr> remote su <abbr>HTTP</abbr>. La libreria client di <abbr>XML-RPC</abbr> e diverse implementazioni di server <abbr>XML-RPC</abbr> sono ora combinate in un singolo package chiamato <code>xmlrpc</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>import <dfn>xmlrpclib</dfn></code>
<td><code class=pp>import xmlrpc.client</code>
<tr><th>
<td><pre><code class=pp>import <dfn>DocXMLRPCServer</dfn>
import <dfn>SimpleXMLRPCServer</dfn></code></pre>
<td><code class=pp>import xmlrpc.server</code>
</table>
<h3 id=othermodules>Altri moduli</h3>
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><pre><code class=pp>try:
    import <dfn>cStringIO</dfn> as <dfn>StringIO</dfn>
except ImportError:
    import StringIO</code></pre>
<td><code class=pp>import io</code>
<tr><th>&#x2461;
<td><pre><code class=pp>try:
    import cPickle as pickle
except ImportError:
    import pickle</code></pre>
<td><code class=pp>import pickle</code>
<tr><th>&#x2462;
<td><code class=pp>import <dfn>__builtin__</dfn></code>
<td><code class=pp>import builtins</code>
<tr><th>&#x2463;
<td><code class=pp>import <dfn>copy_reg</dfn></code>
<td><code class=pp>import copyreg</code>
<tr><th>&#x2464;
<td><code class=pp>import <dfn>Queue</dfn></code>
<td><code class=pp>import queue</code>
<tr><th>&#x2465;
<td><code class=pp>import <dfn>SocketServer</dfn></code>
<td><code class=pp>import socketserver</code>
<tr><th>&#x2466;
<td><code class=pp>import <dfn>ConfigParser</dfn></code>
<td><code class=pp>import configparser</code>
<tr><th>&#x2467;
<td><code class=pp>import repr</code>
<td><code class=pp>import reprlib</code>
<tr><th>&#x2468;
<td><code class=pp>import <dfn>commands</dfn></code>
<td><code class=pp>import subprocess</code>
</table>
<ol>
<li>Un idioma comune in Python 2 era quello di importare <code>cStringIO as StringIO</code> e, in caso di errore, importare <code>StringIO</code> al suo posto. Non è necessario farlo in Python 3, poiché il modulo <code>io</code> lo farà per voi. Troverà l'implementazione più veloce disponibile e la utilizzerà automaticamente.
<li>Un idioma simile veniva usato per importare l'implementazione più veloce di pickle, il protocollo di serializzazione degli oggetti. Non è necessario usare tale idioma in Python 3, poiché il modulo <code>pickle</code> lo farà per voi.
<li>Il modulo <code>builtins</code> contiene le funzioni globali, le classi e le costanti usate in tutto il linguaggio Python. Ridefinire una funzione nel modulo <code>builtins</code> ridefinirà la funzione globale ovunque. Questo è esattamente tanto potente e spaventoso quanto sembra.
<li>Il modulo <code>copyreg</code> aggiunge il supporto per la serializzazione ai vostri tipi di dato definiti in C.
<li>Il modulo <code>queue</code> implementa una coda che supporta produttori e consumatori multipli.
<li>Il modulo <code>socketserver</code> fornisce classi base generiche per implementare differenti tipi di server per le socket.
<li>Il modulo <code>configparser</code> riconosce i file di configurazione sullo stile dei file <abbr>INI</abbr>.
<li>Il modulo <code>reprlib</code> reimplementa la funzione built-in <code>repr()</code> introducendo controlli aggiuntivi su quanto possono essere lunghe le rappresentazioni prima di venire troncate.
<li>Il modulo <code>subprocess</code> vi permette di creare processi, connettervi alle loro pipe e ottenere i loro codici di ritorno.
</ol>
<h2 id=import>Importazioni relative all'interno di un package</h2>
<p>Un package è un gruppo di moduli correlati che funziona come una singola entità. In Python 2, quando i moduli all'interno di un package devono fare riferimento gli uni agli altri, si usa l'idioma <code>import foo</code> oppure <code>from foo import Bar</code>. L'interprete Python 2 prima cerca all'interno del package corrente per trovare <code>foo.py</code>, e poi si sposta nelle altre directory contenute nel percorso di ricerca di Python (<code>sys.path</code>). Python 3 funziona in modo leggermente diverso. Invece di cercare nel package corrente, si sposta direttamente al percorso di ricerca di Python. Se volete che un modulo in un package importi un altro modulo nello stesso package, dovete esplicitamente fornire il percorso relativo tra i due moduli.
<p>Supponete di avere questo package, contenente più file nella stessa directory:
<pre>chardet/
|
+--__init__.py
|
+--constants.py
|
+--mbcharsetprober.py
|
+--universaldetector.py</pre>
<p>Ora supponete che <code>universaldetector.py</code> abbia bisogno di importare l'intero file <code>constants.py</code> e una classe da <code>mbcharsetprober.py</code>. Come fareste?
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>import constants</code>
<td><code class=pp>from . import constants</code>
<tr><th>&#x2461;
<td><code class=pp>from mbcharsetprober import MultiByteCharSetProber</code>
<td><code class=pp>from .mbcharsetprober import MultiByteCharsetProber</code>
</table>
<ol>
<li>Quando dovete importare un intero modulo da qualche parte nel vostro package, usate la nuova sintassi <code>from . import</code>. Il punto è in realtà il percorso relativo da questo file (<code>universaldetector.py</code>) al file che volete importare (<code>constants.py</code>). In questo caso sono nella stessa directory, quindi è sufficiente un singolo punto. Potete anche importare dalla directory superiore (<code>from .. import anothermodule</code>) o da una sottodirectory.
<li>Per importare una specifica classe o funzione da un altro modulo direttamente nello spazio di nomi del vostro modulo, fate precedere al nome del modulo obiettivo un prefisso contenente un percorso relativo, meno lo slash finale. In questo caso <code>mbcharsetprober.py</code> è nella stessa directory di <code>universaldetector.py</code>, quindi il percorso è un singolo punto. Potete anche importare dalla directory genitore (<code>from ..anothermodule import AnotherClass</code>) o da una sottodirectory.
</ol>
<h2 id=next>Il metodo <code>next()</code> degli iteratori</h2>
<p>In Python 2, gli iteratori hanno un metodo <code><dfn>next</dfn>()</code> che restituisce l'elemento successivo nella sequenza. Questo è ancora vero in Python 3, ma esiste anche una funzione globale <code>next()</code> che prende un iteratore come argomento.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>anIterator.next()</code>
<td><code class=pp>next(anIterator)</code>
<tr><th>&#x2461;
<td><code class=pp>a_function_that_returns_an_iterator().next()</code>
<td><code class=pp>next(a_function_that_returns_an_iterator())</code>
<tr><th>&#x2462;
<td><pre><code class=pp>class A:
    def next(self):
        pass</code></pre>
<td><pre><code class=pp>class A:
    def __next__(self):
        pass</code></pre>
<tr><th>&#x2463;
<td><pre><code class=pp>class A:
    def next(self, x, y):
        pass</code></pre>
<td><i>no change</i>
<tr><th>&#x2464;
<td><pre><code class=pp>next = 42
for an_iterator in a_sequence_of_iterators:
    an_iterator.next()</code></pre>
<td><pre><code class=pp>next = 42
for an_iterator in a_sequence_of_iterators:
    an_iterator.__next__()</code></pre>
</table>
<ol>
<li>Nel caso più semplice, invece di chiamare il metodo <code>next()</code> di un iteratore ora passate l'iteratore stesso alla funzione globale <code>next()</code>.
<li>Se avete una funzione che restituisce un iteratore, chiamate la funzione e passate il risultato alla funzione <code>next()</code>. (Lo script <code>2to3</code> è abbastanza intelligente da convertire questi casi in maniera appropriata.)
<li>Se definite una vostra classe e volete usarla come un iteratore, definite il metodo speciale <code>__next__()</code>.
<li>Se definite una vostra classe e la dotate di un metodo chiamato <code>next()</code> che prende uno o più argomenti, <code>2to3</code> non lo toccherà. Questa classe non può essere usata come un iteratore, perché il suo metodo <code>next()</code> accetta degli argomenti.
<li>Questo caso è un po' complicato. Se avete una variabile locale chiamata <var>next</var>, allora essa ha precedenza sulla funzione globale <code>next()</code>. Perciò, siete obbligati a chiamare il metodo speciale <code>__next__()</code> dell'iteratore per ottenere l'elemento successivo nella sequenza. (In alternativa, potreste anche modificare il codice in modo che la variabile locale non sia più chiamata <var>next</var>, ma <code>2to3</code> non lo farà automaticamente per voi.)
</ol>
<h2 id=filter>La funzione globale <code>filter()</code></h2>
<p>In Python 2, la funzione <code><dfn>filter</dfn>()</code> restituiva una lista come risultato del filtraggio di una sequenza attraverso una funzione che restituisce <code>True</code> o <code>False</code> per ogni elemento della sequenza. In Python 3, la funzione <code>filter()</code> restituisce un iteratore, non una lista.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>filter(a_function, a_sequence)</code>
<td><code class=pp>list(filter(a_function, a_sequence))</code>
<tr><th>&#x2461;
<td><code class=pp>list(filter(a_function, a_sequence))</code>
<td><i>no change</i>
<tr><th>&#x2462;
<td><code class=pp>filter(None, a_sequence)</code>
<td><code class=pp>[i for i in a_sequence if i]</code>
<tr><th>&#x2463;
<td><code class=pp>for i in filter(None, a_sequence):</code>
<td><i>no change</i>
<tr><th>&#x2464;
<td><code class=pp>[i for i in filter(a_function, a_sequence)]</code>
<td><i>no change</i>
</table>
<ol>
<li>Nel caso più basilare, <code>2to3</code> circonderà la chiamata a <code>filter()</code> con una chiamata a <code>list()</code>, che semplicemente itera attraverso il suo argomento e restituisce una vera lista.
<li>Comunque, se la chiamata a <code>filter()</code> è <em>già</em> circondata da <code>list()</code>, <code>2to3</code> non farà nulla, dato che il fatto che <code>filter()</code> restituisca un iteratore è irrilevante.
<li>Per la sintassi speciale di <code>filter(None, ...)</code>, <code>2to3</code> trasformerà la chiamata in una descrizione di lista semanticamente equivalente.
<li>In contesti come i cicli <code>for</code>, che iterano comunque attraverso l'intera sequenza, non sono necessari cambiamenti.
<li>Anche in questo caso non sono necessari cambiamenti, perché la descrizione di lista itererà attraverso l'intera sequenza, potendolo fare altrettanto bene sia che <code>filter()</code> restituisca un iteratore sia che restituisca una lista.
</ol>
<h2 id=map>La funzione globale <code>map()</code></h2>
<p>In maniera molto simile a <a href=#filter><code>filter()</code></a>, la funzione <code><dfn>map</dfn>()</code> ora restituisce un iteratore. (In Python 2, essa restituiva una lista.)
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>map(a_function, 'PapayaWhip')</code>
<td><code class=pp>list(map(a_function, 'PapayaWhip'))</code>
<tr><th>&#x2461;
<td><code class=pp>map(None, 'PapayaWhip')</code>
<td><code class=pp>list('PapayaWhip')</code>
<tr><th>&#x2462;
<td><code class=pp>map(lambda x: x+1, range(42))</code>
<td><code class=pp>[x+1 for x in range(42)]</code>
<tr><th>&#x2463;
<td><code class=pp>for i in map(a_function, a_sequence):</code>
<td><i>no change</i>
<tr><th>&#x2464;
<td><code class=pp>[i for i in map(a_function, a_sequence)]</code>
<td><i>no change</i>
</table>
<ol>
<li>Come con <code>filter()</code>, nel caso più basilare, <code>2to3</code> circonderà la chiamata a <code>map()</code> con una chiamata a <code>list()</code>.
<li>La sintassi speciale di <code>map(None, ...)</code>, cioè la funzione identità, sarà convertita da <code>2to3</code> in una equivalente chiamata a <code>list()</code>.
<li>Se il primo argomento di <code>map()</code> è una funzione lambda, <code>2to3</code> la convertirà in una descrizione di lista semanticamente equivalente.
<li>In contesti come i cicli <code>for</code>, che iterano comunque attraverso l'intera sequenza, non sono necessari cambiamenti.
<li>Anche in questo caso non sono necessari cambiamenti, perché la descrizione di lista itererà attraverso l'intera sequenza, potendolo fare altrettanto bene sia che <code>map()</code> restituisca un iteratore sia che restituisca una lista.
</ol>
<h2 id=reduce>La funzione globale <code>reduce()</code> (3.1+)</h2>
<p>In Python 3, la funzione <code><dfn>reduce</dfn>()</code> è stata rimossa dallo spazio di nomi globale e posta nel modulo <code>functools</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>reduce(a, b, c)</code>
<td><pre><code class=pp>from functtools import reduce
reduce(a, b, c)</code></pre>
</table>
<blockquote class=note>
<p><span class=u>&#x261E;</span>La versione di <code>2to3</code> rilasciata con Python 3.0 non correggerà la funzione <code>reduce()</code> automaticamente. La correzione è apparsa per la prima volta nello script <code>2to3</code> che verrà rilasciato con Python 3.1.
</blockquote>
<h2 id=apply>La funzione globale <code>apply()</code></h2>
<p>Python 2 ha una funzione globale chiamata <code><dfn>apply</dfn>()</code>, che prende una funzione <var>f</var> e una lista <code>[a, b, c]</code> e restituisce <code>f(a, b, c)</code>. In Python 3, la funzione <code>apply()</code> non esiste più. Al suo posto, c'è una nuova sintassi per la chiamata a funzione che vi permette di passare una lista e lasciare a  Python il compito di utilizzare gli elementi della lista come argomenti della funzione.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>apply(a_function, a_list_of_args)</code>
<td><code class=pp>a_function(*a_list_of_args)</code>
<tr><th>&#x2461;
<td><code class=pp>apply(a_function, a_list_of_args, a_dictionary_of_named_args)</code>
<td><code class=pp>a_function(*a_list_of_args, **a_dictionary_of_named_args)</code>
<tr><th>&#x2462;
<td><code class=pp>apply(a_function, a_list_of_args + z)</code>
<td><code class=pp>a_function(*a_list_of_args + z)</code>
<tr><th>&#x2463;
<td><code class=pp>apply(aModule.a_function, a_list_of_args)</code>
<td><code class=pp>aModule.a_function(*a_list_of_args)</code>
</table>
<ol>
<li>Nella forma più semplice, potete chiamare una funzione con una lista di argomenti (una lista reale come <code>[a, b, c]</code>) facendo precedere la lista da un asterisco (<code>*</code>). Questa forma è esattamente equivalente alla vecchia funzione <code>apply()</code> di Python 2.
<li>In Python 2, la funzione <code>apply()</code> poteva in realtà accettare tre parametri: una funzione, una lista di argomenti, e un dizionario di argomenti con nomi. In Python 3, potete ottenere la stessa cosa facendo precedere la lista di argomenti da un asterisco (<code>*</code>) e il dizionario di argomenti con nomi da due asterischi (<code>**</code>).
<li>L'operatore <code>+</code>, usato qui per concatenare liste, ha precedenza sull'operatore <code>*</code>, quindi non c'è bisogno di parentesi aggiuntive attorno ad <code>a_list_of_args + z</code>.
<li>Lo script <code>2to3</code> è abbastanza scaltro da convertire chiamate complesse ad <code>apply()</code>, comprese chiamate a funzioni contenute in moduli importati.
</ol>
<h2 id=intern>La funzione globale <code>intern()</code></h2>
<p>In Python 2, potete chiamare la funzione <code><dfn>intern</dfn>()</code> su una stringa per memorizzarla in una tabella interna all'interprete allo scopo di ottimizzare le prestazioni. In Python 3, la funzione <code>intern()</code> è stata spostata nel modulo <code>sys</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>intern(aString)</code>
<td><code class=pp>sys.intern(aString)</code>
</table>
<h2 id=exec>L'istruzione <code>exec</code></h2>
<p>Esattamente come <a href=#print>l'istruzione <code>print</code></a> è diventata una funzione in Python 3, così è successo anche all'istruzione <code><dfn>exec</dfn></code>. La funzione <code>exec()</code> prende una stringa che contiene codice Python arbitrario e la esegue come se fosse un'altra istruzione o espressione.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>exec codeString</code>
<td><code class=pp>exec(codeString)</code>
<tr><th>&#x2461;
<td><code class=pp>exec codeString in a_global_namespace</code>
<td><code class=pp>exec(codeString, a_global_namespace)</code>
<tr><th>&#x2462;
<td><code class=pp>exec codeString in a_global_namespace, a_local_namespace</code>
<td><code class=pp>exec(codeString, a_global_namespace, a_local_namespace)</code>
</table>
<ol>
<li>Nella sua forma più semplice, lo script <code>2to3</code> racchiude semplicemente tra parentesi il codice sotto forma di stringa, dato che <code>exec()</code> è ora una funzione invece di una istruzione.
<li>La vecchia istruzione <code>exec</code> poteva utilizzare uno spazio di nomi per rappresentare un ambiente privato di nomi globali in cui il codice sotto forma di stringa sarebbe stato eseguito. Per fare la stessa cosa in Python 3 basta passare lo spazio di nomi come secondo argomento alla funzione <code>exec()</code>.
<li>In maniera ancora più elaborata, la vecchia istruzione <code>exec</code> poteva anche utilizzare uno spazio di nomi locali (come le variabili definite nell'ambito di una funzione). In Python 3, la funzione <code>exec()</code> può fare anche questo.
</ol>
<h2 id=execfile>L'istruzione <code>execfile</code> (3.1+)</h2>
<p>Come la vecchia <a href=#exec>istruzione <code>exec</code></a>, la vecchia istruzione <code>execfile</code> esegue stringhe come se fossero codice Python. Laddove <code>exec</code> prendeva una stringa, <code>execfile</code> prende un nome di file. In Python 3, l'istruzione <code>execfile</code> è stata eliminata. Se avete davvero bisogno di eseguire un file di codice Python (ma non siete disposti semplicemente a importarlo) potete ottenere lo stesso effetto aprendo il file, leggendone il contenuto, chiamando la funzione globale <code>compile()</code> per obbligare l'interprete Python a compilare il codice e infine utilizzando la nuova funzione <code>exec()</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp><dfn>execfile</dfn>('a_filename')</code>
<td><code class=pp>exec(compile(open('a_filename').read(), 'a_filename', 'exec'))</code>
</table>
<blockquote class=note>
<p><span class=u>&#x261E;</span>La versione di 2to3 rilasciata con Python 3.0 non corregge l'istruzione <code>execfile</code> automaticamente. La correzione è apparsa per la prima volta nello script <code>2to3</code> che verrà rilasciato con Python 3.1.
</blockquote>
<h2 id=repr>I letterali <code>repr</code> (i backtick)</h2>
<p>Python 2 utilizzava una speciale sintassi per ottenere una rappresentazione di qualsiasi oggetto racchiudendo quell'oggetto tra <dfn>backtick</dfn> (come <code>`x`</code>). In Python 3, questa possibilità esiste ancora, ma dovete usare la funzione globale <code>repr()</code> al posto dei backtick.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>`x`</code>
<td><code class=pp>repr(x)</code>
<tr><th>&#x2461;
<td><code class=pp>`'PapayaWhip' + `2``</code>
<td><code class=pp>repr('PapayaWhip' + repr(2))</code>
</table>
<ol>
<li>Ricordate, <var>x</var> può essere qualsiasi cosa &mdash; una classe, una funzione, un modulo, un tipo di dati primitivo, ecc. La funzione <code>repr()</code> lavora su tutto.
<li>In Python 2, i backtick potevano essere annidati, producendo questo tipo di espressioni confuse (ma valide). Lo strumento <code>2to3</code> è abbastanza scaltro da convertire questi casi in chiamate annidate a <code>repr()</code>.
</ol>
<h2 id=except>L'istruzione <code>try...except</code></h2>
<p>La sintassi per catturare le <dfn>eccezioni</dfn> è leggermente cambiata tra Python 2 e Python 3.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><pre><code class=pp>try:
    import mymodule
<dfn>except</dfn> ImportError, e
    pass</code></pre>
<td><pre><code class=pp>try:
    import mymodule
except ImportError as e:
    pass</code></pre>
<tr><th>&#x2461;
<td><pre><code class=pp>try:
    import mymodule
except (RuntimeError, ImportError), e
    pass</code></pre>
<td><pre><code class=pp>try:
    import mymodule
except (RuntimeError, ImportError) as e:
    pass</code></pre>
<tr><th>&#x2462;
<td><pre><code class=pp>try:
    import mymodule
except ImportError:
    pass</code></pre>
<td><i>no change</i>
<tr><th>&#x2463;
<td><pre><code class=pp>try:
    import mymodule
except:
    pass</code></pre>
<td><i>no change</i>
</table>
<ol>
<li>Invece di una virgola dopo il tipo della eccezione, Python 3 usa la nuova parola chiave <code>as</code>.
<li>La parola chiave <code>as</code> funziona anche per catturare più tipi di eccezioni alla volta.
<li>Se catturate una eccezione ma in realtà non vi interessa accedere all'oggetto <dfn>eccezione</dfn> di per sé, la sintassi è identica tra Python 2 e Python 3.
<li>Similmente, se usate una istruzione <code>except</code> vuota per catturare <em>tutte</em> le eccezioni, la sintassi è identica.
</ol>
<blockquote class=note>
<p><span class=u>&#x261E;</span>Non dovreste mai usare una istruzione <code>except</code> vuota per catturare <em>tutte</em> le eccezioni quando importate moduli (o nella maggior parte delle altre occasioni). Se lo fate, rischiate di catturare anche eccezioni come <code>KeyboardInterrupt</code> (se l'utente ha premuto <kbd>Ctrl-C</kbd> per interrompere il programma) rendendo in questo modo molto più difficile effettuare il debug degli errori.
</blockquote>
<h2 id=raise>L'istruzione <code>raise</code></h2>
<p>La sintassi per sollevare le vostre eccezioni è leggermente cambiata tra Python 2 e Python 3.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp><dfn>raise</dfn> MyException</code>
<td><i>unchanged</i>
<tr><th>&#x2461;
<td><code class=pp>raise MyException, 'error message'</code>
<td><code class=pp>raise MyException('error message')</code>
<tr><th>&#x2462;
<td><code class=pp>raise MyException, 'error message', a_traceback</code>
<td><code class=pp>raise MyException('error message').with_traceback(a_traceback)</code>
<tr><th>&#x2463;
<td><code class=pp>raise 'error message'</code>
<td><i>unsupported</i>
</table>
<ol>
<li>Nella sua forma più semplice, sollevare una eccezione senza un messaggio personalizzato, la sintassi è rimasta invariata.
<li>Il cambiamento si nota quando volete sollevare una eccezione con un messaggio personalizzato. Python 2 separava con una virgola la classe della eccezione e il messaggio, mentre Python 3 passa il messaggio di errore come un parametro.
<li>Python 2 supportava una sintassi più complessa per sollevare una eccezione con una <i>traceback</i> (la traccia dello stack di esecuzione) personalizzata. Potete farlo anche in Python 3, ma la sintassi è abbastanza differente.
<li>In Python 2, potevate sollevare una eccezione senza alcuna classe, utilizzando semplicemente un messaggio di errore. In Python 3, questo non è più possibile. <code>2to3</code> vi avvertirà che non è in grado di correggere questo caso automaticamente.
</ol>
<h2 id=throw>Il metodo <code>throw</code> dei generatori</h2>
<p>In Python 2, i generatori hanno un metodo <code><dfn>throw</dfn>()</code>. Chiamare <code>a_generator.throw()</code> solleva una eccezione nel punto in cui il generatore è stato sospeso, poi restituisce il valore successivo prodotto dalla funzione generatrice. In Python 3 questa funzionalità è ancora disponibile, ma la sintassi è leggermente diversa.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>a_generator.throw(MyException)</code>
<td><i>no change</i>
<tr><th>&#x2461;
<td><code class=pp>a_generator.throw(MyException, 'error message')</code>
<td><code class=pp>a_generator.throw(MyException('error message'))</code>
<tr><th>&#x2462;
<td><code class=pp>a_generator.throw('error message')</code>
<td><i>unsupported</i>
</table>
<ol>
<li>Nella sua forma più semplice, un generatore lancia una eccezione senza un messaggio di errore personalizzato. In questo caso la sintassi non è cambiata nel passaggio da Python 2 a Python 3.
<li>Se il generatore lancia una eccezione <em>con</em> un messaggio di errore personalizzato, allora dovete passare la stringa di errore all'eccezione quando la create.
<li>Python 2 supportava anche il lancio di una eccezione utilizzando <em>solo</em> un messaggio di errore personalizzato. Python 3 non lo supporta e lo script <code>2to3</code> visualizzerà un avvertimento dicendovi che avrete bisogno di correggere manualmente questo codice.
</ol>
<h2 id=xrange>La funzione globale <code>xrange()</code></h2>
<p>In Python 2, c'erano due modi per ottenere una lista di numeri: <code><dfn>range</dfn>()</code>, che restituiva una lista, e <code><dfn>xrange</dfn>()</code>, che restituiva un iteratore. In Python 3, <code>range()</code> restituisce un iteratore e <code>xrange()</code> non esiste più.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>xrange(10)</code>
<td><code class=pp>range(10)</code>
<tr><th>&#x2461;
<td><code class=pp>a_list = range(10)</code>
<td><code class=pp>a_list = list(range(10))</code>
<tr><th>&#x2462;
<td><code class=pp>[i for i in xrange(10)]</code>
<td><code class=pp>[i for i in range(10)]</code>
<tr><th>&#x2463;
<td><code class=pp>for i in range(10):</code>
<td><i>no change</i>
<tr><th>&#x2464;
<td><code class=pp>sum(range(10))</code>
<td><i>no change</i>
</table>
<ol>
<li>Nel caso più semplice, lo script <code>2to3</code> convertirà semplicemente <code>xrange()</code> in <code>range()</code>.
<li>Se il vostro programma in Python 2 usava <code>range()</code>, lo script <code>2to3</code> non sa se avete bisogno di una lista o se un iteratore potrebbe bastare. Pecca per eccesso di prudenza e converte il valore di ritorno in una lista chiamando la funzione <code>list()</code>.
<li>Se la funzione <code>xrange()</code> si trova in una descrizione di lista, non c'è bisogno di convertire il risultato in una lista, perché la descrizione di lista lavora altrettanto bene con un iteratore.
<li>Similmente, un ciclo <code>for</code> lavora altrettanto bene con un iteratore, quindi non c'è bisogno di cambiare nulla qui.
<li>Anche la funzione <code>sum()</code> lavora altrettanto bene con un iteratore, quindi <code>2to3</code> non effettua alcun cambiamento neanche qui. Come per <a href=#dict>i metodi dei dizionari che restituiscono viste invece di liste</a>, questo si applica a <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>list()</code>, <code>tuple()</code>, <code>set()</code>, <code>sorted()</code>, <code>any()</code>, e <code>all()</code>.
</ol>
<h2 id=raw_input>Le funzioni globali <code>raw_input()</code> e <code>input()</code></h2>
<p>Python 2 aveva due funzioni globali per chiedere all'utente di inserire dati in ingresso dalla linea di comando. La prima, chiamata <code>input()</code>, si aspettava che l'utente inserisse una espressione Python (e ne restituiva il risultato). La seconda, chiamata <code><dfn>raw_input</dfn>()</code>, restituiva semplicemente qualsiasi cosa l'utente avesse digitato. Questo comportamento era fonte di terribile confusione per i principianti e generalmente considerato come un &#8220;neo&#8221; del linguaggio. Python 3 asporta questo neo rinominando <code>raw_input()</code> a <code>input()</code>, in modo che funzioni come ci si aspetta intuitivamente che debba funzionare.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>raw_input()</code>
<td><code class=pp>input()</code>
<tr><th>&#x2461;
<td><code class=pp>raw_input('prompt')</code>
<td><code class=pp>input('prompt')</code>
<tr><th>&#x2462;
<td><code class=pp>input()</code>
<td><code class=pp>eval(input())</code>
</table>
<ol>
<li>Nella sua forma più semplice, <code>raw_input()</code> diventa <code>input()</code>.
<li>In Python 2, la funzione <code>raw_input()</code> poteva prendere come parametro un prompt, cioè una stringa di caratteri visualizzata per indicare l'attesa di un nuovo ingresso da parte della funzione. Questo parametro è stato mantenuto in Python 3.
<li>Se avete effettivamente bisogno di chiedere all'utente una espressione Python da valutare, usate la funzione <code>input()</code> e passatene il risultato a <code>eval()</code>.
</ol>
<h2 id=funcattrs>Le proprietà <code>func_*</code> delle funzioni</h2>
<p>In Python 2, il codice all'interno delle funzioni può accedere a particolari proprietà della funzione stessa. In Python 3, queste proprietà speciali di una funzione sono state rinominate per renderle consistenti con altre proprietà.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>a_function.<dfn>func_name</dfn></code>
<td><code class=pp>a_function.__name__</code>
<tr><th>&#x2461;
<td><code class=pp>a_function.<dfn>func_doc</dfn></code>
<td><code class=pp>a_function.__doc__</code>
<tr><th>&#x2462;
<td><code class=pp>a_function.<dfn>func_defaults</dfn></code>
<td><code class=pp>a_function.__defaults__</code>
<tr><th>&#x2463;
<td><code class=pp>a_function.<dfn>func_dict</dfn></code>
<td><code class=pp>a_function.__dict__</code>
<tr><th>&#x2464;
<td><code class=pp>a_function.<dfn>func_closure</dfn></code>
<td><code class=pp>a_function.__closure__</code>
<tr><th>&#x2465;
<td><code class=pp>a_function.<dfn>func_globals</dfn></code>
<td><code class=pp>a_function.__globals__</code>
<tr><th>&#x2466;
<td><code class=pp>a_function.<dfn>func_code</dfn></code>
<td><code class=pp>a_function.__code__</code>
</table>
<ol>
<li>La proprietà <code>__name__</code> (precedentemente <code>func_name</code>) contiene il nome della funzione.
<li>La proprietà <code>__doc__</code> (precedentemente <code>func_doc</code>) contiene la <i>docstring</i> che avete definito nel codice sorgente della funzione.
<li>La proprietà <code>__defaults__</code> (precedentemente <code>func_defaults</code>) è una tupla contenente i valori di default degli argomenti per quegli argomenti che hanno un valore di default.
<li>La proprietà <code>__dict__</code> (precedentemente <code>func_dict</code>) è lo spazio di nomi che supporta la gestione di proprietà arbitrarie per la funzione.
<li>La proprietà <code>__closure__</code> (precedentemente <code>func_closure</code>) è una tupla di celle che contengono i legami per le variabili libere della funzione.
<li>La proprietà <code>__globals__</code> (precedentemente <code>func_globals</code>) è un riferimento allo spazio di nomi globale del modulo in cui la funzione è stata definita.
<li>La proprietà <code>__code__</code> (precedentemente <code>func_code</code>) è un oggetto codice che rappresenta il corpo della funzione compilata.
</ol>
<h2 id=xreadlines>Il metodo di I/O <code>xreadlines()</code></h2>
<p>In Python 2, gli oggetti file avevano un metodo <code><dfn>xreadlines</dfn>()</code> che restituiva un iteratore per leggere il file una riga alla volta. Questo era utile nei cicli <code>for</code> e in alcuni altri casi. In effetti, era così utile che le ultime versioni di Python 2 hanno aggiunto questa capacità agli oggetti file stessi.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>for line in a_file.xreadlines():</code>
<td><code class=pp>for line in a_file:</code>
<tr><th>&#x2461;
<td><code class=pp>for line in a_file.xreadlines(5):</code>
<td><i>no change</i>
</table>
<ol>
<li>Se eravate soliti chiamare <code>xreadlines()</code> senza argomenti, <code>2to3</code> convertirà la chiamata al solo oggetto file. In Python 3, si effettua così la stessa operazione: leggere il file una riga alla volta ed eseguire il corpo del ciclo <code>for</code>.
<li>Se eravate soliti chiamare <code>xreadlines()</code> con un argomento (il numero di righe da leggere alla volta), continuate a farlo. Funziona ancora in Python 3, e <code>2to3</code> non lo cambierà.
</ol>
<p class=c><span style='font-size:56px;line-height:0.88'>&#x2603;</span>
<h2 id=tuple_params>Funzioni <code>lambda</code> che accettano una tupla invece di parametri multipli</h2>
<p>In Python 2, potevate definire una funzione <code><dfn>lambda</dfn></code> anonima che accettava parametri multipli scrivendola in modo che accettasse una tupla con uno specifico numero di elementi. In effetti, Python 2 avrebbe &#8220;spacchettato&#8221; la tupla negli argomenti con nome, a cui poi avreste potuto riferirvi (attraverso il nome) all'interno dalla funzione <code>lambda</code>. In Python 3, potete ancora passare una tupla a una funzione <code>lambda</code>, ma l'interprete Python non spacchetterà la tupla in argomenti con nome. Invece, dovrete riferirvi ad ogni argomento tramite l'indice della sua posizione.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>lambda (x,): x + f(x)</code>
<td><code class=pp>lambda x1: x1[0] + f(x1[0])</code>
<tr><th>&#x2461;
<td><code class=pp>lambda (x, y): x + f(y)</code>
<td><code class=pp>lambda x_y: x_y[0] + f(x_y[1])</code>
<tr><th>&#x2462;
<td><code class=pp>lambda (x, (y, z)): x + y + z</code>
<td><code class=pp>lambda x_y_z: x_y_z[0] + x_y_z[1][0] + x_y_z[1][1]</code>
<tr><th>&#x2463;
<td><code class=pp>lambda x, y, z: x + y + z</code>
<td><i>unchanged</i>
</table>
<ol>
<li>Se avete definito una funzione <code>lambda</code> che accetta una tupla composta da un elemento, in Python 3 questa diventerà una <code>lambda</code> con riferimenti a <var>x1[0]</var>. Il nome <var>x1</var> viene generato automaticamente dallo script <code>2to3</code>, sulla base degli argomenti con nome nella tupla originale.
<li>La tupla di due elementi <var>(x, y)</var> argomento di una funzione <code>lambda</code> viene convertita a <var>x_y</var> con argomenti posizionali <var>x_y[0]</var> e <var>x_y[1]</var>.
<li>Lo script <code>2to3</code> può perfino gestire funzioni <code>lambda</code> con tuple innestate di argomenti con nome. Il codice Python 3 risultante è leggermente illeggibile, ma funziona allo stesso modo in cui funzionava in Python 2.
<li>Potete definire funzioni <code>lambda</code> che accettano più argomenti. Senza parentesi attorno agli argomenti, Python 2 le tratta semplicemente come funzioni <code>lambda</code> con argomenti multipli, in modo che all'interno della funzione <code>lambda</code> possiate riferirvi agli argomenti tramite il loro nome, esattamente come avviene per ogni altra funzione. Questa sintassi funziona ancora in Python 3.
</ol>
<h2 id=methodattrs>Proprietà speciali dei metodi</h2>
<p>In Python 2, i metodi di classe possono fare riferimento all'oggetto classe in cui sono definiti, così come all'oggetto metodo stesso. <code>im_self</code> è l'istanza dell'oggetto classe; <code>im_func</code> rappresenta l'oggetto funzione; <code>im_class</code> è la classe di <code>im_self</code>. In Python 3, queste proprietà speciali dei metodi sono state rinominate per seguire le convenzioni sui nomi delle altre proprietà.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>aClassInstance.aClassMethod.<dfn>im_func</dfn></code>
<td><code class=pp>aClassInstance.aClassMethod.__func__</code>
<tr><th>
<td><code class=pp>aClassInstance.aClassMethod.<dfn>im_self</dfn></code>
<td><code class=pp>aClassInstance.aClassMethod.__self__</code>
<tr><th>
<td><code class=pp>aClassInstance.aClassMethod.<dfn>im_class</dfn></code>
<td><code class=pp>aClassInstance.aClassMethod.__self__.__class__</code>
</table>
<h2 id=nonzero>Il metodo speciale <code>__nonzero__</code></h2>
<p>In Python 2, potevate costruire una vostra classe permettendole di essere usata in un contesto booleano. Per esempio, potevate istanziare la classe e poi usare l'istanza in una istruzione <code>if</code>. Per fare questo, definivate un metodo speciale <code>__nonzero__()</code> che restituiva <code>True</code> o <code>False</code> e veniva chiamato ogni volta che l'istanza era usata in un contesto booleano. In Python 3 potete ancora farlo, ma il nome del metodo è stato cambiato in <code>__bool__()</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><pre><code class=pp>class A:
    def <dfn>__nonzero__</dfn>(self):
        pass</code></pre>
<td><pre><code class=pp>class A:
    def <dfn>__bool__</dfn>(self):
        pass</code></pre>
<tr><th>&#x2461;
<td><pre><code class=pp>class A:
    def __nonzero__(self, x, y):
        pass</code></pre>
<td><i>no change</i>
</table>
<ol>
<li>Al posto di <code>__nonzero__()</code>, Python 3 chiama il metodo <code>__bool__()</code> per valutare un'istanza in un contesto booleano.
<li>Comunque, se avete un metodo <code>__nonzero__()</code> che accetta argomenti, lo strumento <code>2to3</code> presumerà che lo steste usando per qualche altro scopo e non effettuerà alcun cambiamento.
</ol>
<h2 id=numliterals>Letterali in base otto</h2>
<p>La sintassi per definire numeri in base 8 (<dfn>ottali</dfn>) è leggermente cambiata nel passaggio da Python 2 a Python 3.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>x = 0755</code>
<td><code class=pp>x = 0o755</code>
</table>
<h2 id=renames><code>sys.maxint</code></h2>
<p>A causa della integrazione dei tipi <code>long</code> e <code>int</code>, la costante <code>sys.maxint</code> non è più accurata. Dato che il valore potrebbe ancora essere utile per determinare le capacità di una specifica piattaforma, è stata mantenuta ma rinominata in <code>sys.maxsize</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>from sys import <dfn>maxint</dfn></code>
<td><code class=pp>from sys import <dfn>maxsize</dfn></code>
<tr><th>&#x2461;
<td><code class=pp>a_function(<dfn>sys.maxint</dfn>)</code>
<td><code class=pp>a_function(<dfn>sys.maxsize</dfn>)</code>
</table>
<ol>
<li><code>maxint</code> diventa <code>maxsize</code>.
<li>Ogni uso di <code>sys.maxint</code> diventa <code>sys.maxsize</code>.
</ol>
<h2 id=callable>La funzione globale <code>callable()</code></h2>
<p>In Python 2, potevate contollare se un oggetto era invocabile (come una funzione) tramite la funzione globale <code><dfn>callable</dfn>()</code>. In Python 3, questa funzione globale è stata eliminata. Per controllare se un oggetto è invocabile, verificate l'esistenza del metodo speciale <code>__call__()</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>callable(anything)</code>
<td><code class=pp>hasattr(anything, '__call__')</code>
</table>
<h2 id=zip>La funzione globale <code>zip()</code></h2>
<p>In Python 2, la funzione globale <code><dfn>zip</dfn>()</code> prendeva un qualsiasi numero di sequenze e restituiva una lista di tuple. La prima tupla conteneva il primo elemento di ogni sequenza, la seconda tupla conteneva il secondo elemento di ogni sequenza e così via. In Python 3, <code>zip()</code> restituisce un iteratore invece di una lista.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>zip(a, b, c)</code>
<td><code class=pp>list(zip(a, b, c))</code>
<tr><th>&#x2461;
<td><code class=pp>d.join(zip(a, b, c))</code>
<td><i>no change</i>
</table>
<ol>
<li>Nella forma più semplice, potete ottenere il vecchio comportamento della funzione <code>zip()</code> circondandone il valore di ritorno con una chiamata a <code>list()</code>, che attraversa l'iteratore restituito da <code>zip()</code> e restituisce una lista reale dei risultati.
<li>In contesti che iterano già attraverso tutti gli elementi di una sequenza (come questa chiamata al metodo <code>join()</code>) l'iteratore che <code>zip()</code> restituisce funzionerà adeguatamente. Lo script <code>2to3</code> è abbastanza scaltro da riconoscere questi casi e non fare alcun cambiamento al vostro codice.
</ol>
<h2 id=standarderror>L'eccezione di tipo <code>StandardError</code></h2>
<p>In Python 2, <code><dfn>StandardError</dfn></code> era la classe base per tutte le eccezioni built-in tranne <code>StopIteration</code>, <code>GeneratorExit</code>, <code>KeyboardInterrupt</code> e <code>SystemExit</code>. In Python 3, la classe <code>StandardError</code> è stata eliminata; usate <code>Exception</code> al suo posto.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>x = StandardError()</code>
<td><code class=pp>x = Exception()</code>
<tr><th>
<td><code class=pp>x = StandardError(a, b, c)</code>
<td><code class=pp>x = Exception(a, b, c)</code>
</table>
<h2 id=types>Le costanti del modulo <code>types</code></h2>
<p>Il modulo <code>types</code> contiene una varietà di costanti per aiutarvi a determinare il tipo di un oggetto. In Python 2, conteneva costanti per tutti i tipi primitivi come <code>dict</code> e <code>int</code>. In Python 3, queste constanti sono state eliminate; vi basta usare il nome del tipo primitivo.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>types.<dfn>StringType</dfn></code>
<td><code class=pp>bytes</code>
<tr><th>
<td><code class=pp>types.<dfn>DictType</dfn></code>
<td><code class=pp>dict</code>
<tr><th>
<td><code class=pp>types.<dfn>IntType</dfn></code>
<td><code class=pp>int</code>
<tr><th>
<td><code class=pp>types.<dfn>LongType</dfn></code>
<td><code class=pp>int</code>
<tr><th>
<td><code class=pp>types.<dfn>ListType</dfn></code>
<td><code class=pp>list</code>
<tr><th>
<td><code class=pp>types.<dfn>NoneType</dfn></code>
<td><code class=pp>type(None)</code>
</table>
<blockquote class=note>
<p><span class=u>&#x261E;</span><code>types.StringType</code> corrisponde a <code>bytes</code> invece che a <code>str</code> perché una &#8220;stringa&#8221; (non una stringa Unicode, semplicemente una stringa normale) in Python 2 è in realtà solo una sequenza di byte in una particolare codifica di carattere.
</blockquote>
<h2 id=isinstance>La funzione globale <code>isinstance()</code> (3.1+)</h2>
<p>La funzione <code>isinstance()</code> controlla se un oggetto è una istanza di una particolare classe o tipo. In Python 2, potevate passare una tupla di tipi, e <code>isinstance()</code> avrebbe restituito <code>True</code> se l'oggetto fosse stato di uno di quei tipi. In Python 3, potete ancora farlo, ma passare lo stesso tipo due volte è deprecato.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>isinstance(x, (int, float, int))</code>
<td><code class=pp>isinstance(x, (int, float))</code>
</table>
<blockquote class=note>
<p><span class=u>&#x261E;</span>La versione di 2to3 rilasciata con Python 3.0 non corregge automaticamente questi casi di <code>isinstance()</code>. La correzione è apparsa per la prima volta nello script 2to3 che verrà rilasciato con Python 3.1.
</blockquote>
<h2 id=basestring>Il tipo di dato <code>basestring</code></h2>
<p>Python 2 aveva due tipi di stringhe: Unicode e non Unicode. Ma c'era anche un altro tipo, <code><dfn>basestring</dfn></code>. Era un tipo astratto, una superclasse per entrambi i tipi <code>str</code> e <code>unicode</code>. Non poteva essere chiamata o istanziata direttamente, ma potevate passarla alla funzione globale <code>isinstance()</code> per controllare che un oggetto fosse una stringa Unicode o una stringa non Unicode. In Python 3, c'è un solo tipo di stringhe, quindi <code>basestring</code> non ha ragione di esistere.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>isinstance(x, basestring)</code>
<td><code class=pp>isinstance(x, str)</code>
</table>
<h2 id=itertools>Il modulo <code>itertools</code></h2>
<p>Python 2.3 ha introdotto il modulo <code>itertools</code>, che definiva delle varianti per le funzioni globali <code>zip()</code>, <code>map()</code> e <code>filter()</code> che restituivano iteratori invece di liste. In Python 3, quelle funzioni globali restituiscono iteratori, quindi le corrispondenti funzioni del modulo <code>itertools</code> sono state eliminate.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>itertools.<dfn>izip</dfn>(a, b)</code>
<td><code class=pp>zip(a, b)</code>
<tr><th>&#x2461;
<td><code class=pp>itertools.<dfn>imap</dfn>(a, b)</code>
<td><code class=pp>map(a, b)</code>
<tr><th>&#x2462;
<td><code class=pp>itertools.<dfn>ifilter</dfn>(a, b)</code>
<td><code class=pp>filter(a, b)</code>
<tr><th>&#x2463;
<td><code class=pp>from itertools import imap, izip, foo</code>
<td><code class=pp>from itertools import foo</code>
</table>
<ol>
<li>Invece di <code>itertools.izip()</code> usate semplicemente la funzione globale <code>zip()</code>.
<li>Invece di <code>itertools.imap()</code> usate semplicemente <code>map()</code>.
<li><code>itertools.ifilter()</code> diventa <code>filter()</code>.
<li>Il modulo <code>itertools</code> esiste ancora in Python 3, gli mancano solo le funzioni che sono state spostate nello spazio di nomi globale. Lo script <code>2to3</code> è abbastanza scaltro da rimuovere le specifiche istruzioni di <code>import</code> per moduli che non esistono più, lasciando intatte le altre.
</ol>
<h2 id=sys_exc><code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code></h2>
<p>Python 2 aveva tre variabili nel modulo <code>sys</code> che potevate accedere durante la gestione di una eccezione: <code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code>. (In realtà, esse risalgono a Python 1.) Fin da Python 1.5, queste variabili sono state deprecate a favore di <code>sys.exc_info</code>, che è una tupla contenente tutti e tre i valori. In Python 3, queste singole variabili sono infine sparite; dovete usare <code>sys.exc_info</code>.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp><dfn>sys.exc_type</dfn></code>
<td><code class=pp>sys.exc_info()[0]</code>
<tr><th>
<td><code class=pp><dfn>sys.exc_value</dfn></code>
<td><code class=pp>sys.exc_info()[1]</code>
<tr><th>
<td><code class=pp><dfn>sys.exc_traceback</dfn></code>
<td><code class=pp>sys.exc_info()[2]</code>
</table>
<h2 id=paren>Descrizioni di lista sulle tuple</h2>
<p>In Python 2, se volevate implementare una descrizione di lista che iterasse su una tupla, non avevate bisogno di mettere le parentesi attorno ai valori della tupla. In Python 3, le parentesi esplicite sono obbligatorie.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>[i for i in 1, 2]</code>
<td><code class=pp>[i for i in (1, 2)]</code>
</table>
<h2 id=getcwdu>La funzione <code>os.getcwdu()</code></h2>
<p>Python 2 aveva una funzione chiamata <code>os.getcwd()</code>, che restituiva la directory di lavoro sotto forma di una stringa (non Unicode). Dato che i moderni file system possono gestire i nomi di directory in qualsiasi codifica di carattere, Python 2.3 ha introdotto <code>os.getcwdu()</code>. La funzione <code>os.getcwdu()</code> restituisce la directory di lavoro corrente come una stringa Unicode. In Python 3, c'è un solo tipo di stringhe (Unicode), quindi <code>os.getcwd()</code> è tutto quello di cui avete bisogno.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp><dfn>os.getcwdu</dfn>()</code>
<td><code class=pp>os.getcwd()</code>
</table>
<h2 id=metaclass>Metaclassi</h2>
<p>In Python 2, potevate creare metaclassi definendo l'argomento <code>metaclass</code> nella dichiarazione della classe, oppure definendo uno speciale attributo <code><dfn>__metaclass__</dfn></code> a livello di classe. In Python 3, questo attributo a livello di classe è stato eliminato.
<table>
<tr><th>Note
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><pre><code class=pp>class C(metaclass=PapayaMeta):
    pass</code></pre>
<td><i>unchanged</i>
<tr><th>&#x2461;
<td><pre><code class=pp>class Whip:
    __metaclass__ = PapayaMeta</code></pre>
<td><pre><code class=pp>class Whip(metaclass=PapayaMeta):
    pass</code></pre>
<tr><th>&#x2462;
<td><pre><code class=pp>class C(Whipper, Beater):
    __metaclass__ = PapayaMeta</code></pre>
<td><pre><code class=pp>class C(Whipper, Beater, metaclass=PapayaMeta):
    pass</code></pre>
</table>
<ol>
<li>Dichiarare la metaclasse nella dichiarazione della classe funzionava in Python 2 e funziona ancora allo stesso modo in Python 3.
<li>Dichiarare la metaclasse in un attributo di classe funzionava in Python 2 ma non funziona in Python 3.
<li>Lo script <code>2to3</code> è abbastanza potente da costruire una dichiarazione di classe valida anche se la classe eredita da una o più classi base.
</ol>
<h2 id=nitpick>Questioni di stile</h2>
<p>Il resto delle &#8220;correzioni&#8221; elencate qui di seguito non sono realmente correzioni vere e proprie. Vale a dire che le cose che modificano sono considerate questioni di stile, non di sostanza. Funzionano tanto bene in Python 3 quanto funzionavano in Python 2, ma gli sviluppatori di Python hanno un legittimo interesse nel rendere il codice Python più uniforme possibile. A questo scopo, esiste una <a href=http://www.python.org/dev/peps/pep-0008/>guida ufficiale allo stile in Python</a> che delinea &mdash; dolorosamente in dettaglio &mdash; tutti quei tipi di particolari minuziosi e pedanti di cui quasi certamente non vi interessa sapere nulla. E dato che <code>2to3</code> fornisce una infrastruttura così buona per la conversione di codice Python da una forma a un'altra, gli autori si sono presi la briga di aggiungere alcune caratteristiche opzionali per migliorare la leggibilità dei vostri programmi Python.
<h3 id=set_literal>Letterali <code>set()</code> (esplicita)</h3>
<p>In Python 2, l'unico modo di definire un letterale insieme nel vostro codice era chiamare <code>set(a_sequence)</code>. In Python 3, questo funziona ancora, ma un modo più chiaro di farlo è usare la nuova notazione per i letterali insieme: le parentesi graffe. (Anche i dizionari sono definiti con parentesi graffe, che ha senso una volta che ci pensate, perché i dizionari sono esattamente insiemi di coppie chiave-valore.)
<blockquote class=note>
<p><span class=u>&#x261E;</span>Lo script <code>2to3</code> non correggerà i letterali <code>set()</code> di default. Per abilitare questa correzione, specificate <kbd>-f set_literal</kbd> sulla linea di comando quando chiamate <code>2to3</code>.
</blockquote>
<table>
<tr><th>Note
<th>Prima
<th>Dopo
<tr><th>
<td><code class=pp>set([1, 2, 3])</code>
<td><code class=pp>{1, 2, 3}</code>
<tr><th>
<td><code class=pp>set((1, 2, 3))</code>
<td><code class=pp>{1, 2, 3}</code>
<tr><th>
<td><code class=pp>set([i for i in a_sequence])</code>
<td><code class=pp>{i for i in a_sequence}</code>
</table>
<h3 id=buffer>La funzione globale <code>buffer()</code> (esplicita)</h3>
<p>Gli oggetti Python implementati in C possono esportare una &#8220;interfaccia di buffer,&#8221; che permette ad altro codice Python di leggere e scrivere direttamente un blocco di memoria. (Questo è esattamente potente e spaventoso quanto sembra.) In Python 3, <code>buffer()</code> è stata rinominata a <code>memoryview()</code>. (&Egrave; un po' più complicato di così, ma potete quasi certamente ignorare le differenze.)
<blockquote class=note>
<p><span class=u>&#x261E;</span>Lo script <code>2to3</code> non correggerà la funzione <code>buffer()</code> di default. Per abilitare questa correzione, specificate <kbd>-f buffer</kbd> sulla linea di comando quando chiamate <code>2to3</code>.
</blockquote>
<table>
<tr><th>Note
<th>Prima
<th>Dopo
<tr><th>
<td><code class=pp>x = <dfn>buffer</dfn>(y)</code>
<td><code class=pp>x = <dfn>memoryview</dfn>(y)</code>
</table>
<h3 id=wscomma>Gli spazi bianchi attorno alle virgole (esplicita)</h3>
<p>Nonostante Python sia draconiano a riguardo degli spazi bianchi per l'indentazione del codice, il linguaggio è in realtà piuttosto liberale a proposito degli spazi bianchi in altre aree. Nell'ambito di liste, tuple, insiemi e dizionari, gli spazi bianchi possono apparire prima e dopo le virgole senza sortire alcun effetto negativo. Comunque, la guida allo stile in Python afferma che le virgole dovrebbero essere precedeute da zero spazi e seguite da uno spazio. Sebbene questo sia un problema puramente estetico (il codice funziona in ogni modo, sia in Python 2 che in Python 3) lo script <code>2to3</code> può opzionalmente correggerlo per voi.
<blockquote class=note>
<p><span class=u>&#x261E;</span>Lo script <code>2to3</code> non correggerà gli spazi bianchi attorno alle virgole di default. Per abilitare questa correzione, specificate <kbd>-f wscomma</kbd> sulla linea di comando quando chiamate <code>2to3</code>.
</blockquote>
<table>
<tr><th>Note
<th>Prima
<th>Dopo
<tr><th>
<td><code class=pp>a ,b</code>
<td><code class=pp>a, b</code>
<tr><th>
<td><code class=pp>{a :b}</code>
<td><code class=pp>{a: b}</code>
</table>
<h3 id=idioms>Idiomi comuni (esplicita)</h3>
<p>Esiste un certo numero di idiomi comuni accumulati dalla comunità Python. Alcuni, come il ciclo <code>while 1:</code>, risalgono a Python 1. (Python non ha avuto un vero tipo boolean fino alla versione 2.3, così gli sviluppatori usavano <code>1</code> e <code>0</code>.) I moderni programmatori Python dovrebbero allenare i loro cervelli all'uso delle moderne versioni di questi idiomi.
<blockquote class=note>
<p><span class=u>&#x261E;</span>Lo script <code>2to3</code> non correggerà gli idiomi comuni di default. Per abilitare questa correzione, specificate <kbd>-f idioms</kbd> sulla linea di comando quando chiamate <code>2to3</code>.
</blockquote>
<table>
<tr><th>Note
<th>Prima
<th>Dopo
<tr><th>
<td><pre><code class=pp>while 1:
    do_stuff()</code></pre>
<td><pre><code class=pp>while True:
    do_stuff()</code></pre>
<tr><th>
<td><code class=pp>type(x) == T</code>
<td><code class=pp>isinstance(x, T)</code>
<tr><th>
<td><code class=pp>type(x) is T</code>
<td><code class=pp>isinstance(x, T)</code>
<tr><th>
<td><pre><code class=pp>a_list = list(a_sequence)
a_list.sort()
do_stuff(a_list)</code></pre>
<td><pre><code class=pp>a_list = sorted(a_sequence)
do_stuff(a_list)</code></pre>
</table>
<p><span class=fixme>FIXME: once the rest of the book is written, this appendix should contain copious links back to any chapter or section that touches on these features.</span>
<p class=nav><a rel=prev class=todo><span class=u>&#x261C;</span></a> <a rel=next href=nomi-dei-metodi-speciali.html title='avanti a &#8220;Nomi dei metodi speciali&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;9 <a href=informazioni-sul-libro.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
