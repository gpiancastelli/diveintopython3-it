<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>XML - Dive into Python 3</title>
<!--[if IE]><script src=html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<link rel=stylesheet href=dip3-it.css>
<style>
body{counter-reset:h1 13}
mark{display:inline}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=root value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#xml>Dive Into Python 3</a> <span>&#8227;</span>
<p id=level>Livello di difficoltà: <span title=advanced>&#x2666;&#x2666;&#x2666;&#x2666;&#x2662;</span>
<h1>XML</h1>
<blockquote class=q>
<p><span>&#x275D;</span> Sotto l'arcontato di Aristecmo, Dracone stabilì le sue leggi. <span>&#x275E;</span><br>&mdash; <a href="http://www.perseus.tufts.edu/cgi-bin/ptext?doc=Perseus:text:1999.01.0046;query=chapter%3D%235;layout=;loc=3.1">Aristotele</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione!</h2>
<p class=f>La maggior parte dei capitoli in questo libro si sono centrati attorno a un pezzo di codice d'esempio. Ma <abbr>XML</abbr> non è a proposito di codice; è a proposito di dati. Uno degli usi più comuni di <abbr>XML</abbr> è il &#8220;syndication feed&#8221; che elenca gli ultimi articoli di un blog, un forum, o un altro sito web frequentemente aggiornato. La maggior parte dei software <span class=wtf>di blogging</span> più popolari è in grado di produrre un feed e aggiornarla ogni volta che nuovi articoli, <span class=wtf>thread di discussione</span>, o <span class=wtf>blog post</span> vengono pubblicati. Potete seguire un blog &#8220;sottoscrivendo&#8221; il suo feed, e potete seguire blog multipli con un &#8220;<a href=http://en.wikipedia.org/wiki/List_of_feed_aggregators>aggregatore di feed</a>&#8221; dedicato come <a href=http://www.google.com/reader/>Google Reader</a>.

<p>Qui, dunque, ci sono i dati <abbr>XML</abbr> con cui lavoreremo in questo capitolo. &Egrave; un feed &mdash; nello specifico, un <a class=wtf href=http://atompub.org/rfc4287.html>syndication feed Atom</a>.

<p class=d>[<a href=esempi/feed.xml>scarica <code>feed.xml</code></a>]
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?>
&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  &lt;title>dive into mark&lt;/title>
  &lt;subtitle>currently between addictions&lt;/subtitle>
  &lt;id>tag:diveintomark.org,2001-07-29:/&lt;/id>
  &lt;updated>2009-03-27T21:56:07Z&lt;/updated>
  &lt;link rel="alternate" type="text/html" href="http://diveintomark.org/"/>
  &lt;link rel="self" type="application/atom+xml" href="http://diveintomark.org/feed/"/>
  &lt;entry>
    &lt;author>
      &lt;name>Mark&lt;/name>
      &lt;uri>http://diveintomark.org/&lt;/uri>
    &lt;/author>
    &lt;title>Dive into history, 2009 edition&lt;/title>
    &lt;link rel="alternate" type="text/html"
      href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition"/>
    &lt;id>tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id>
    &lt;updated>2009-03-27T21:56:07Z&lt;/updated>
    &lt;published>2009-03-27T17:20:42Z&lt;/published>
    &lt;category scheme="http://diveintomark.org" term="diveintopython"/>
    &lt;category scheme="http://diveintomark.org" term="docbook"/>
    &lt;category scheme="http://diveintomark.org" term="html"/>
  &lt;summary type="html">Putting an entire chapter on one page sounds
    bloated, but consider this &amp;amp;mdash; my longest chapter so far
    would be 75 printed pages, and it loads in under 5 seconds&amp;amp;hellip;
    On dialup.&lt;/summary>
  &lt;/entry>
  &lt;entry>
    &lt;author>
      &lt;name>Mark&lt;/name>
      &lt;uri>http://diveintomark.org/&lt;/uri>
    &lt;/author>
    &lt;title>Accessibility is a harsh mistress&lt;/title>
    &lt;link rel="alternate" type="text/html"
      href="http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress"/>
    &lt;id>tag:diveintomark.org,2009-03-21:/archives/20090321200928&lt;/id>
    &lt;updated>2009-03-22T01:05:37Z&lt;/updated>
    &lt;published>2009-03-21T20:09:28Z&lt;/published>
    &lt;category scheme="http://diveintomark.org" term="accessibility"/>
    &lt;summary type="html">The accessibility orthodoxy does not permit people to
      question the value of features that are rarely useful and rarely used.&lt;/summary>
  &lt;/entry>
  &lt;entry>
    &lt;author>
      &lt;name>Mark&lt;/name>
    &lt;/author>
    &lt;title>A gentle introduction to video encoding, part 1: container formats&lt;/title>
    &lt;link rel="alternate" type="text/html"
      href="http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats"/>
    &lt;id>tag:diveintomark.org,2008-12-18:/archives/20081218155422&lt;/id>
    &lt;updated>2009-01-11T19:39:22Z&lt;/updated>
    &lt;published>2008-12-18T15:54:22Z&lt;/published>
    &lt;category scheme="http://diveintomark.org" term="asf"/>
    &lt;category scheme="http://diveintomark.org" term="avi"/>
    &lt;category scheme="http://diveintomark.org" term="encoding"/>
    &lt;category scheme="http://diveintomark.org" term="flv"/>
    &lt;category scheme="http://diveintomark.org" term="GIVE"/>
    &lt;category scheme="http://diveintomark.org" term="mp4"/>
    &lt;category scheme="http://diveintomark.org" term="ogg"/>
    &lt;category scheme="http://diveintomark.org" term="video"/>
    &lt;summary type="html">These notes will eventually become part of a
      tech talk on video encoding.&lt;/summary>
  &lt;/entry>
&lt;/feed></code></pre>
 
<h2 id=xml-intro class=wtf>A 5-Minute Crash Course in XML</h2>

<p>Se conoscete già <abbr>XML</abbr>, potete saltare questa sezione.

<p><abbr>XML</abbr> è un modo generalizzato di descrivere strutture dati gerarchiche. Un <i>documento</i> <abbr>XML</abbr> contiene uno o più <i>elementi</i>, che sono delimitati da <i>tag di apertura e di chiusura</i>. Questo è un documento <abbr>XML</abbr> completo (sebbene noioso):

<pre class=nd><code><a>&lt;foo>   <span>&#x2460;</span></a>
<a>&lt;/foo>  <span>&#x2461;</span></a></code></pre>
<ol>
<li>Questo è il <i>tag di apertura</i> dell'elemento <code>foo</code>.
<li>Questo è il corrispondente <i>tag di chiusura</i> dell'elemento <code>foo</code>. Allo stesso modo in cui si bilanciano le parentesi nella scrittura, in matematica, o in programmazione, ogni tag di apertura deve essere <i>chiuso</i> da un corrispondente tag di chiusura.
</ol>

<p>Gli elementi possono essere <i>innestati</i> senza alcun limite di profondità. Un elemento <code>bar</code> all'interno di un elemento <code>foo</code> si definisce come un <i>sottoelemento</i> o un elemento <i>figlio</i> di <code>foo</code>.

<pre class=nd><code>&lt;foo>
  <mark>&lt;bar>&lt;/bar></mark>
&lt;/foo>
</code></pre>

<p>Il primo elemento di ogni documento <abbr>XML</abbr> si chiama <i>elemento radice</i>. Un documento <abbr>XML</abbr> può avere un solo elemento radice. Il documento che segue <strong>non è un documento <abbr>XML</abbr></strong>, perché possiede due elementi radice:

<pre class=nd><code>&lt;foo>&lt;/foo>
&lt;bar>&lt;/bar></code></pre>

<p>Gli elementi possono avere <i>attributi</i>, che sono coppie nome-valore. Gli attributi sono elencati all'interno del tag di apertura di un elemento e separati da spazi bianchi. I <i>nomi degli attributi</i> non posso essere ripetuti nell'ambito di uno stesso elemento. I <i>valori degli attributi</i> devono essere racchiusi tra virgolette.

<pre class=nd><code><a>&lt;foo <mark>lang="en"</mark>>          <span>&#x2460;</span></a>
<a>  &lt;bar <mark>lang="fr"</mark>>&lt;/bar>  <span>&#x2461;</span></a>
&lt;/foo>
</code></pre>
<ol>
<li>L'elemento <code>foo</code> possiede un attributo, chiamato <code>lang</code>. Il valore del suo attributo <code>lang</code> è <code>en</code>.
<li>L'elemento <code>bar</code> possiede un attributo, chiamato <code>lang</code>. Il valore del suo attributo <code>lang</code> è <code>fr</code>. Questo non crea conflitti in alcun modo con l'elemento <code>foo</code>. Ogni elemento possied il proprio insieme di attributi.
</ol>

<p>Nel caso un elemento possegga più di un attributo, l'ordine degli attributi non è significativo. Gli attributi di un elemento formano un insieme non ordinato di chiavi e valori, come un dizionario Python. 

<p>Gli elementi possono avere <i>contenuto testuale</i>.

<pre class=nd><code>&lt;foo lang="en">
  &lt;bar lang="fr"><mark>PapayaWhip</mark>&lt;/bar>
&lt;/foo>
</code></pre>

<p>Gli elementi che non contengono testo e non hanno figli si dicono <i>vuoti</i>.

<pre class=nd><code>&lt;foo>&lt;/foo></code></pre>

<p>Esiste un'abbreviazione per scrivere elementi vuoti. Inserendo un carattere <code>/</code> nel tag di apertura, potete <span class=wtf>skip</span> completamente il tag di chiusura. Il documento <abbr>XML</abbr> nell'esempio precedente potrebbe anche essere scritto in questo modo:

<pre class=nd><code>&lt;foo<mark>/</mark>></code></pre>

<p>Così come le funzioni Python possono essere dichiarate in <i>moduli</i> differenti, gli elementi <abbr>XML</abbr> possono essere dichiarati in <i>spazi di nomi</i> differenti. Gli spazi di nomi generalmente <span class=wtf>look like</span> URL. Potete usare una dichiarazione <code>xmlns</code> per definire uno <i>spazio di nomi di default</i>. Una dichiarazione di spazio di nomi <span class=wtf>look</span> simile a un attributo, ma ha uno scopo differente.

<pre class=nd><code><a>&lt;feed <mark>xmlns="http://www.w3.org/2005/Atom"</mark>>  <span>&#x2460;</span></a>
<a>  &lt;title>dive into mark&lt;/title>             <span>&#x2461;</span></a>
&lt;/feed>
</code></pre>
<ol>
<li>L'elemento <code>feed</code> è nello spazio di nomi <code>http://www.w3.org/2005/Atom</code>.
<li>Anche l'elemento <code>title</code> si trova nello spazio di nomi <code>http://www.w3.org/2005/Atom</code>. La dichiarazione dello spazio di nomi ha effetto sull'elemento in cui è dichiarata, più tutti gli elementi figli.
</ol>

<p>Potete anche usare una dichiarazione <code>xmlns:<var>prefisso</var></code> per definire uno spazio di nomi e associarlo a un <i>prefisso</i>. Quindi ogni elemento in quello spazio di nomi deve essere esplicitamente dichiarato con il prefisso.

<pre class=nd><code><a>&lt;atom:feed <mark>xmlns:atom="http://www.w3.org/2005/Atom"</mark>>  <span>&#x2460;</span></a>
<a>  &lt;atom:title>dive into mark&lt;/atom:title>             <span>&#x2461;</span></a>
&lt;/atom:feed></code></pre>
<ol>
<li>L'elemento <code>feed</code> è nello spazio di nomi <code>http://www.w3.org/2005/Atom</code>.
<li>Anche l'elemento <code>title</code> si trova nello spazio di nomi <code>http://www.w3.org/2005/Atom</code>.
</ol>

<p>Per quanto riguarda un riconoscitore <abbr>XML</abbr>, i due documenti <abbr>XML</abbr> precedenti sono <em>identici</em>. <span class=wtf>Namespace + element name = <abbr>XML</abbr> identity</span>. I prefissi esistono solamente per fare riferimento agli spazi di nomi, così l'effettivo nome del prefisso (<code>atom:</code>) è irrilevante. Gli spazi di nomi corrispondono, i nomi degli elementi corrispondono, gli attributi (o l'assenza di attributi) corrisponde, e il contenuto testuale di ogni elemento corrisponde, quindi i documenti <abbr>XML</abbr> sono uguali.

<p>Infine, i documenti <abbr>XML</abbr> possono contentere <a href=stringhe.html#one-ring-to-rule-them-all>informazioni sulla codifica di carattere</a> nella prima riga, prima dell'elemento radice. (Se siete curiosi di sapere come fa un documento a contenere informazioni che è necessario conoscere prima di poter <span class=wtf>parse</span> il documento, la <a href=http://www.w3.org/TR/REC-xml/#sec-guessing-no-ext-info>Sezione F della specifica <abbr>XML</abbr></a> descrive in dettaglio come risolvere questa <span class=wtf>Catch-22</span>.)

<pre class=nd><code>&lt;?xml version="1.0" <mark>encoding="utf-8"</mark>?></code></pre>

<p>E ora conoscete quel tanto di <abbr>XML</abbr> che vi serve per poter essere pericolosi!

<h2 id=xml-structure>La struttura di un feed Atom</h2>

<p>Pensate a un weblog, o in effetti a qualsiasi sito web il cui contenuto venga frequentemente aggiornato, come <a href=http://www.cnn.com/>CNN.com</a>. Il sito ha un titolo (&#8220;CNN.com&#8221;), un sottotitolo (&#8220;Breaking News, U.S., World, Weather, Entertainment <i class=baa>&amp;</i> Video News&#8221;), una data per l'ultimo aggiornamento (&#8220;updated 12:43 p.m. EDT, Sat May 16, 2009&#8221;), e una lista di articoli pubblicati in tempi differenti. Anche ogni articolo ha un titolo, una data di prima pubblicazione (e magari anche una data per l'ultimo aggiornamento, se ne è stata pubblicata una modifica oppure è stato corretto un errore di battitura), e un URL unico.

<p>Il formato di syndication Atom è progettato per catturare tutte queste informazioni in un formato standard. Il mio weblog e CNN.com sono <span class=wtf>wildly</span> differenti nel design, ambito, e pubblico, ma entrambi hanno la stessa struttura di base. CNN.com ha un titolo; il mio blog ha un titolo; CNN.com pubblica articoli; io pubblico articoli.

<p>Al livello più alto si trova l'<i>elemento radice</i>, che è lo stesso per ogni feed Atom: l'elemento <code>feed</code> nello spazio di nomi <code>http://www.w3.org/2005/Atom</code>.

<pre><code><a>&lt;feed xmlns="http://www.w3.org/2005/Atom"  <span>&#x2460;</span></a>
<a>      xml:lang="en">                       <span>&#x2461;</span></a></code></pre>
<ol>
<li><code>http://www.w3.org/2005/Atom</code> è lo spazio di nomi Atom.
<li>Qualsiasi elemento può contenere un attributo <code>xml:lang</code>, che dichiara la lingua di quell'elemento e dei suoi figli. In questo caso, l'attributo <code>xml:lang</code> è dichiarato una sola volta nell'elemento radice, il che significa che l'intero feed è in inglese.
</ol>

<p>Un feed Atom contiene diversi pezzi di informazione sul feed stesso. Questi sono dichiarati come figli dell'elemento <code>feed</code> a livello di radice.

<pre><code>&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<a>  &lt;title>dive into mark&lt;/title>                                             <span>&#x2460;</span></a>
<a>  &lt;subtitle>currently between addictions&lt;/subtitle>                         <span>&#x2461;</span></a>
<a>  &lt;id>tag:diveintomark.org,2001-07-29:/&lt;/id>                                <span>&#x2462;</span></a>
<a>  &lt;updated>2009-03-27T21:56:07Z&lt;/updated>                                   <span>&#x2463;</span></a>
<a>  &lt;link rel="alternate" type="text/html" href="http://diveintomark.org/"/>  <span>&#x2464;</span></a></code></pre>
<ol>
<li>Il titolo di questo feed è <code>dive into mark</code>. 
<li>Il sottotitolo di questo feed è <code>currently between addictions</code>.
<li>Ogni feed necessita di un identificatore unico. Leggete la <a href=http://www.ietf.org/rfc/rfc4151.txt>RFC 4151</a> per sapre come crearne uno.
<li>Questo feed è stata aggiornata per l'ultima volta il 27 marzo 2009, alle 21:56 GMT. Di solito, questa data è equivalente alla data dell'ultima modifica dell'articolo più recente.
<li>Ora le cose cominciano a diventare interessanti. Questo elemento <code>link</code> non ha contenuto testuale, ma ha tre attributi: <code>rel</code>, <code>type</code> e <code>href</code>. Il valore di <code>rel</code> vi dice che tipo di collegamento è questo; <code>rel="alternate"</code> significa che è un collegamento a una rappresentazione alternativa per questo feed. L'attributo <code>type="text/html"</code> significa che questo è un collegamento a una pagina <abbr>HTML</abbr>. E la destinazione del collegamento viene fornita nell'attributo <code>href</code>.
</ol>

<p>Ora sappiamo che questo è un feed per un sito chiamato &#8220;dive into mark&#8220; che è disponibile all'indirizzo <a href=http://diveintomark.org/><code>http://diveintomark.org/</code></a> e che è stato aggiornato per l'ultima volta il 27 marzo 2009.

<blockquote class=note>
<p><span>&#x261E;</span>Sebbene l'ordine degli elementi possa essere rilevante in alcuni documenti <abbr>XML</abbr>, non lo è in un feed Atom.
</blockquote>

<p>Dopo i metadati a livello di feed si trova la lista degli articoli più recenti. Un articolo <span class=wtf>looks like this</span>:

<pre><code>&lt;entry>
<a>  &lt;author>                                                                 <span>&#x2460;</span></a>
    &lt;name>Mark&lt;/name>
    &lt;uri>http://diveintomark.org/&lt;/uri>
  &lt;/author>
<a>  &lt;title>Dive into history, 2009 edition&lt;/title>                           <span>&#x2461;</span></a>
<a>  &lt;link rel="alternate" type="text/html"                                   <span>&#x2462;</span></a>
    href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition"/>
<a>  &lt;id>tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id>        <span>&#x2463;</span></a>
<a>  &lt;updated>2009-03-27T21:56:07Z&lt;/updated>                                  <span>&#x2464;</span></a>
  &lt;published>2009-03-27T17:20:42Z&lt;/published>        
<a>  &lt;category scheme="http://diveintomark.org" term="diveintopython"/>       <span>&#x2465;</span></a>
  &lt;category scheme="http://diveintomark.org" term="docbook"/>
  &lt;category scheme="http://diveintomark.org" term="html"/>
<a>  &lt;summary type="html">Putting an entire chapter on one page sounds        <span>&#x2466;</span></a>
    bloated, but consider this &amp;amp;mdash; my longest chapter so far
    would be 75 printed pages, and it loads in under 5 seconds&amp;amp;hellip;
    On dialup.&lt;/summary>
<a>&lt;/entry>                                                                   <span>&#x2467;</span></a></code></pre>
<ol>
<li>L'elemento <code>author</code> vi dice chi ha scritto questo articolo: un certo tizio di nome Mark, che potete trovare a bighellonare all'indirizzo <code>http://diveintomark.org/</code>. (Questo è lo stesso indirizzo del collegamento alternativo contenuto nei metadati del feed, ma non deve per forza esserlo. Molti weblog hanno più di un autore, ognuno col proprio sito personale.)
<li>L'elemento <code>title</code> vi dà il titolo dell'articolo, &#8220;Dive into history, 2009 edition&#8221;.
<li>Come per il collegamento alternativo a livello di feed, questo elemento <code>link</code> vi dà l'indirizzo della versione <abbr>HTML</abbr> di questo articolo.
<li>Ogni voce, come ogni feed, necessita di un identificatore unico.
<li>Ogni voce ha due date: la data di prima pubblicazione (<code>published</code>) e la data di ultima modifica (<code>updated</code>).
<li>Ogni voce può avere un numero arbitrario di categorie. Questo articolo è classificato sotto le categorie <code>diveintopython</code>, <code>docbook</code> e <code>html</code>.
<li>L'elemento <code>summary</code> fornisce un breve riepilogo dell'articolo. (Esiste anche un elemento <code>content</code>, che qui non viene mostrato, da utilizzare se volete includere il testo completo dell'articolo nel vostro feed.) Questo elemento <code>summary</code> possiede l'attributo <code>type="html"</code> specifico di Atom, che specifica che questo riepilogo è un frammento di <abbr>HTML</abbr>, non testo semplice. Questo è importante, dato che contiene entità specifiche di <abbr>HTML</abbr> (<code>&amp;mdash;</code> e <code>&amp;hellip;</code>) che dovrebbero essere rappresentate come &#8220;&mdash;&#8221; e &#8220;&hellip;&#8221; piuttosto che visualizzate direttamente.
<li>Infine, il tag di chiusura per l'elemento <code>entry</code> segnala la fine dei metadati per questo articolo.
</ol>

<h2 id=xml-parse>Riconoscere XML</h2>

<p>Python può riconoscere documenti XML in molti modi. Possiede riconoscitori tradizionali di tipo <a href=http://en.wikipedia.org/wiki/XML#DOM><abbr>DOM</abbr></a> e <a href=http://en.wikipedia.org/wiki/Simple_API_for_XML><abbr>SAX</abbr></a>, ma io mi focalizzerò su una libreria differente chiamata ElementTree.

<p class=d>[<a href=esempi/feed.xml>scarica <code>feed.xml</code></a>]
<pre class=screen>
<a><samp class=p>>>> </samp><kbd>import xml.etree.ElementTree as etree</kbd>    <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>tree = etree.parse("esempi/feed.xml")</kbd>  <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>root = tree.getroot()</kbd>                    <span>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd>root</kbd>                                     <span>&#x2463;</span></a>
<samp>&lt;Element {http://www.w3.org/2005/Atom}feed at cd1eb0></samp></pre>
<ol>
<li>La libreria ElementTree fa parte della libreria standard di Python e si trova nel modulo <code>xml.etree.ElementTree</code>.
<li>Il punto d'ingresso principale della libreria ElementTree è la funzione <code>parse()</code>, che può prendere un nome di file o un oggetto simile a un file <span class=fixme>[FIXME xref]</span>. Questa funzione riconosce l'intero documento tutto in una volta. Se la memoria è ridotta, ci sono modi per <a href=http://effbot.org/zone/element-iterparse.htm>riconoscere un documento <abbr>XML</abbr> in maniera incrementale</a>.
<li>La funzione <code>parse()</code> restituisce un oggetto che rappresenta l'intero documento. Questo oggetto <em>non</em> è l'elemento radice. Per ottenere un riferimento all'elemento radice, chiamate il metodo <code>getroot()</code>.
<li>Come vi sareste aspettati, l'elemento radice è l'elemento <code>feed</code> nello spazio di nomi <code>http://www.w3.org/2005/Atom</code>. La rappresentazione sotto forma di stringa di questo oggetto rafforza un punto importante: un elemento <abbr>XML</abbr> è la combinazione del suo spazio di nomi e del nome del suo tag (anche chiamato <i>nome locale</i>). Ogni elemento in questo documento si trova nello spazio di nomi Atom, quindi l'elemento radice viene rappresentato come <code>{http://www.w3.org/2005/Atom}feed</code>.
</ol>

<blockquote class=note>
<p><span>&#x261E;</span>ElementTree rappresenta gli elementi <abbr>XML</abbr> come <code>{<var>spaziodinomi</var>}<var>nomelocale</var></code>. Vedrete e userete questo formato in più punti nella <abbr>API</abbr> di ElementTree.
</blockquote>

<h3 id=xml-elements>Gli elementi sono liste</h3>

<p>In ElementTree, un elemento <abbr>XML</abbr> si comporta come una lista. Gli elementi della lista sono i figli dell'elemento <abbr>XML</abbr>.

<pre class=screen>
# continued from the previous example
<a><samp class=p>>>> </samp><kbd>root.tag</kbd>                        <span>&#x2460;</span></a>
<samp>'{http://www.w3.org/2005/Atom}feed'</samp>
<a><samp class=p>>>> </samp><kbd>len(root)</kbd>                       <span>&#x2461;</span></a>
<samp>8</samp>
<a><samp class=p>>>> </samp><kbd>for child in root:</kbd>              <span>&#x2462;</span></a>
<a><samp class=p>... </samp><kbd>  print(child)</kbd>                  <span>&#x2463;</span></a>
<samp class=p>... </samp>
<samp>&lt;Element {http://www.w3.org/2005/Atom}title at e2b5d0>
&lt;Element {http://www.w3.org/2005/Atom}subtitle at e2b4e0>
&lt;Element {http://www.w3.org/2005/Atom}id at e2b6c0>
&lt;Element {http://www.w3.org/2005/Atom}updated at e2b6f0>
&lt;Element {http://www.w3.org/2005/Atom}link at e2b4b0>
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b720>
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b510>
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b750></samp></pre>
<ol>
<li>Proseguendo l'esempio precedente, l'elemento radice è <code>{http://www.w3.org/2005/Atom}feed</code>.
<li>La &#8220;lunghezza&#8221; dell'elemento radice è il numero dei suoi elementi figli.
<li>Potete usare l'elemento stesso come un iteratore per <span class=wtf>loop through</span> tutti i suoi elementi figli.
<li>Come potete vedere, ci sono effettivamente 8 elementi figli: tutti quelli che contengono metadati a livello di feed (<code>title</code>, <code>subtitle</code>, <code>id</code>, <code>updated</code>, e <code>link</code>) seguiti dai tre elementi <code>entry</code>.
</ol>

<p>Potreste averlo già indovinato, ma voglio sottolinearlo esplicitamente: la lista degli elementi figli include solamente i figli <em>diretti</em>. Ogni elemento <code>entry</code> contiene i propri figli, ma questi non sono inclusi nella lista. Sarebbero inclusi nella lista dei figli di ogni elemento <code>entry</code>, ma non sono inclusi nella lista dei figli dell'elemento <code>feed</code>. Esistono modi di trovare elementi a prescindere da quanto profondamente sono innestati; vedremo due di queste tecniche più avanti in questo capitolo.

<h3 id=xml-attributes>Gli attributi sono dizionari</h3>

<p><abbr>XML</abbr> non è semplicemente una collezione di elementi; ogni elemento può anche avere il proprio insieme di attributi. Una volta che avete un riferimento a uno specifico elemento, potete facilmente ottenere i suoi attributi sotto forma di un dizionario Python.

<pre class=screen>
# continuing from the previous example
<a><samp class=p>>>> </samp><kbd>root.attrib</kbd>                           <span>&#x2460;</span></a>
<samp>{'{http://www.w3.org/XML/1998/namespace}lang': 'en'}</samp>
<a><samp class=p>>>> </samp><kbd>root[4]</kbd>                               <span>&#x2461;</span></a>
<samp>&lt;Element {http://www.w3.org/2005/Atom}link at e181b0></samp>
<a><samp class=p>>>> </samp><kbd>root[4].attrib</kbd>                        <span>&#x2462;</span></a>
<samp>{'href': 'http://diveintomark.org/',
 'type': 'text/html',
 'rel': 'alternate'}</samp>
<a><samp class=p>>>> </samp><kbd>root[3]</kbd>                               <span>&#x2463;</span></a>
<samp>&lt;Element {http://www.w3.org/2005/Atom}updated at e2b4e0></samp>
<a><samp class=p>>>> </samp><kbd>root[3].attrib</kbd>                        <span>&#x2464;</span></a>
<samp>{}</samp></pre>
<ol>
<li>La proprietà <code>attrib</code> è un dizionario degli attributi dell'elemento. Il markup originale qui era <code>&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"></code>. Il prefisso <code>xml:</code> si riferisce a uno spazio di nomi predefinito che ogni documento <abbr>XML</abbr> può usare senza doverlo dichiarare.
<li>Il quinto figlio &mdash; <code>[4]</code> in una lista i cui indici partono da <code>0</code> &mdash; è l'elemento <code>link</code>.
<li>L'elemento <code>link</code> ha tre attributi: <code>href</code>, <code>type</code> e <code>rel</code>.
<li>Il quarto figlio &mdash; <code>[3]</code> in una lista i cui indici partono da <code>0</code> &mdash; è l'elemento <code>updated</code>.
<li>L'elemento <code>updated</code> non ha attributi, quindi la sua proprietà <code>.attrib</code> è semplicemente un dizionario vuoto.
</ol>

<h2 id=xml-find>Cercare nodi all'interno di un documento XML</h2>

<p>Finora abbiamo lavorato con questo documento <abbr>XML</abbr> in maniera &#8220;top down,&#8221; dalla cima in giù, partendo dall'elemento radice, recuperando i suoi elementi figli, e così via attraverso tutto il documento. Ma molti usi di <abbr>XML</abbr> vi richiedono di trovare elementi specifici. ElementTree può fare anche questo.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import xml.etree.ElementTree as etree</kbd>
<samp class=p>>>> </samp><kbd>tree = etree.parse("esempi/feed.xml")</kbd>
<samp class=p>>>> </samp><kbd>root = tree.getroot()</kbd>
<a><samp class=p>>>> </samp><kbd>root.findall("{http://www.w3.org/2005/Atom}entry")</kbd>    <span>&#x2460;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b510>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b540>]</samp>
<samp class=p>>>> </samp><kbd>root.tag</kbd>
<samp>'{http://www.w3.org/2005/Atom}feed'</samp>
<a><samp class=p>>>> </samp><kbd>root.findall("{http://www.w3.org/2005/Atom}feed")</kbd>     <span>&#x2461;</span></a>
<samp>[]</samp>
<a><samp class=p>>>> </samp><kbd>root.findall("{http://www.w3.org/2005/Atom}author")</kbd>   <span>&#x2462;</span></a>
<samp>[]</samp></pre>
<ol>
<li>Il metodo <code>findall()</code> trova elementi figli che corrispondo a una richiesta specifica (I dettagli sul formato della richiesta arriveranno in un minuto.)
<li>Tutti gli elementi &mdash; incluso l'elemento radice, ma anche gli elementi figli &mdash; hanno un metodo <code>findall()</code>. Il metodo trova tutti gli elementi che corrispondono tra gli elementi figli. Ma perché in questo caso non viene trovato alcun risultato? Sebbene possa non essere immediato, questa particolare richiesta cerca solo tra i figli di un elemento. Dato che l'elemento radice <code>feed</code> non ha figli chiamati <code>feed</code>, questa richiesta restituisce una lista vuota.
<li>Anche questo risultato potrebbe sorprendervi. <a href=#divingin>C'è un elemento <code>author</code></a> in questo documento; in effetti, ce ne sono tre (uno per ogni <code>entry</code>). Ma quegli elementi <code>author</code> non sono <em>figli diretti</em> dell'elemento radice; essi sono &#8220;nipoti&#8221; (letteralmente, un elemento figlio di un elemento figlio). Se volete cercare elementi <code>author</code> a qualsiasi livello di <span class=wtf>nesting</span>, potete farlo, ma la forma della richiesta è leggermente differente.
</ol>

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>tree.findall("{http://www.w3.org/2005/Atom}entry")</kbd>    <span>&#x2460;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b510>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b540>]</samp>
<a><samp class=p>>>> </samp><kbd>tree.findall("{http://www.w3.org/2005/Atom}author")</kbd>   <span>&#x2461;</span></a>
<samp>[]</samp>
</pre>
<ol>
<li>Per convenienza, l'oggetto <code>tree</code> (restituito dalla funzione <code>etree.parse()</code>) possiede diversi metodi speculari ai metodi dell'elemento radice. I risultati di questi metodi sono gli stessi che avreste ottenuto invocando il metodo <code>tree.getroot().findall()</code>.
<li>In maniera forse sorprendente, questa richiesta non trova gli elementi <code>author</code> in questo documento. Perché no? Perché questa è solo una scorciatoia per <code>tree.getroot().findall("{http://www.w3.org/2005/Atom}author")</code>, che significa &#8220;trova tutti gli elementi <code>author</code> che sono figli dell'elemento radice.&#8221; Gli elementi <code>author</code> non sono figli dell'elemento radice; sono figli degli elementi <code>entry</code>. Quindi la richiesta non restituisce alcuna corrispondenza.
</ol>

<p><em>Esiste</em> un modo per cercare gli elementi <em>discendenti</em>, <i>i.e.</i> figli, nipoti e qualsiasi elmento a qualsiasi livello di <span class=wtf>nesting</span>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>all_links = tree.findall("//{http://www.w3.org/2005/Atom}link")</kbd>  <span>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd>all_links</kbd>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}link at e181b0>,
 &lt;Element {http://www.w3.org/2005/Atom}link at e2b570>,
 &lt;Element {http://www.w3.org/2005/Atom}link at e2b480>,
 &lt;Element {http://www.w3.org/2005/Atom}link at e2b5a0>]</samp>
<a><samp class=p>>>> </samp><kbd>all_links[0].attrib</kbd>                                              <span>&#x2461;</span></a>
<samp>{'href': 'http://diveintomark.org/',
 'type': 'text/html',
 'rel': 'alternate'}</samp>
<a><samp class=p>>>> </samp><kbd>all_links[1].attrib</kbd>                                              <span>&#x2462;</span></a>
<samp>{'href': 'http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition',
 'type': 'text/html',
 'rel': 'alternate'}</samp>
<samp class=p>>>> </samp><kbd>all_links[2].attrib</kbd>
<samp>{'href': 'http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress',
 'type': 'text/html',
 'rel': 'alternate'}</samp>
<samp class=p>>>> </samp><kbd>all_links[3].attrib</kbd>
<samp>{'href': 'http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats',
 'type': 'text/html',
 'rel': 'alternate'}</samp></pre>
<ol>
<li>Questa richiesta &mdash; <code>//{http://www.w3.org/2005/Atom}link</code> &mdash; è molto simile agli esempi precedenti, tranne per i due caratteri di slash all'inizio della richiesta. Quei due slash significano &#8220;non cercare solo tra i figli diretti; voglio <em>qualsiasi</em> elemento, a prescindere dal livello di <span class=wtf>nesting</span>.&#8221; Quindi il risultato è una lista di quattro elementi <code>link</code>, non uno solo.
<li>Il primo risultato <em>è</em> un figlio diretto dell'elemento radice. Come potete vedere dai suoi attributi, questo è il collegamento alternativo a livello di feed che punta alla versione <abbr>HTML</abbr> del sito web che il feed descrive.
<li>Gli altri tre risultati sono i collegamenti alternativi a livello di singola voce. Ogni elemento <code>entry</code> ha un singolo elemento figlio <code>link</code>, e a causa del doppio slash all'inizio della richiesta, questa richiesta li trova tutti e tre.
</ol>

<p>Il metodo <code>findall()</code> ha altri assi nella manica.

<pre class=screen>
# continuing from the previous example
<a><samp class=p>>>> </samp><kbd>tree.findall("//{http://www.w3.org/2005/Atom}*[@href]")</kbd>                             <span>&#x2460;</span></a>
[&lt;Element {http://www.w3.org/2005/Atom}link at eeb8a0>,
 &lt;Element {http://www.w3.org/2005/Atom}link at eeb990>,
 &lt;Element {http://www.w3.org/2005/Atom}link at eeb960>,
 &lt;Element {http://www.w3.org/2005/Atom}link at eeb9c0>]
<a><samp class=p>>>> </samp><kbd>tree.findall("//{http://www.w3.org/2005/Atom}*[@href='http://diveintomark.org/']")</kbd>  <span>&#x2461;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}link at eeb930>]</samp>
<samp class=p>>>> </samp><kbd>NS = "{http://www.w3.org/2005/Atom}"</kbd>
<a><samp class=p>>>> </samp><kbd>tree.findall("//{NS}author[{NS}uri]".format(NS=NS))</kbd>                                 <span>&#x2462;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}author at eeba80>,
 &lt;Element {http://www.w3.org/2005/Atom}author at eebba0>]</samp></pre>
<ol>
<li>Questa richiesta trova tutti gli elementi nello spazio di nomi Atom, ovunque nel documento, che abbiano un attributo <code>href</code>. I caratteri <code>//</code> all'inizio della richiesta significano &#8220;elementi ovunque (non solo come figli dell'elemento radice).&#8221; <code>{http://www.w3.org/2005/Atom}</code> significa &#8220;solo elementi nello spazio di nomi Atom.&#8221; <code>*</code> significa &#8220;elementi con un qualsiasi nome locale.&#8221; E <code>[@href]</code> significa &#8220;ha un attributo <code>href</code>.&#8221;
<li>La richiesta trova tutti gli elementi Atom con un attributo <code>href</code> il cui valore sia <code>http://diveintomark.org/</code>.
<li>Dopo aver fatto alcune rapide <a href=stringhe.html#formatting-strings>formattazioni di stringhe</a> (perché altrimenti queste richieste composte diventano ridicolmente lunghe), questa richiesta cerca gli elementi Atom <code>author</code> che hanno un elemento Atom <code>uri</code> come figlio. Questa richiesta restituisce solo due elementi <code>author</code>, quelli nella prima e nella seconda <code>entry</code>. L'elemento <code>author</code> nell'ultima <code>entry</code> contiene solo un figlio <code>name</code>, non un <code>uri</code>.
</ol>

<p>Cos'è questo? Dite che volete la potenza del metodo <code>findall()</code>, ma volete lavorare con un iteratore invece che costruire una lista completa? ElementTree può fare anche questo.

<pre class=screen>
# continuing from the previous example
<a><samp class=p>>>> </samp><kbd>it = tree.getiterator("{http://www.w3.org/2005/Atom}link")</kbd>  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>next(it)</kbd>                                                    <span>&#x2461;</span></a>
&lt;Element {http://www.w3.org/2005/Atom}link at 122f1b0>
<samp class=p>>>> </samp><kbd>next(it)</kbd>
&lt;Element {http://www.w3.org/2005/Atom}link at 122f1e0>
<samp class=p>>>> </samp><kbd>next(it)</kbd>
&lt;Element {http://www.w3.org/2005/Atom}link at 122f210>
<samp class=p>>>> </samp><kbd>next(it)</kbd>
&lt;Element {http://www.w3.org/2005/Atom}link at 122f1b0>
<samp class=p>>>> </samp><kbd>next(it)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp></pre>
<ol>
<li>Il metodo <code>getiterator()</code> può prendere zero o più argomenti. Se chiamato senza argomenti, restituisce un iteratore che produce ogni elemento ed elemento figlio nell'intero documento. Oppure, come viene mostrato qui, potete invocarlo con il nome di un elemento nel formato standard di ElementTree. Questo restituisce un iteratore che produce solo gli elementi con quel nome.
<li>
</ol>

<p>Complessivamente, il metodo <code>findall()</code> di ElementTree è una caratteristica molto potente, ma il suo linguaggio di richiesta può essere un po' sorprendente. &Egrave; ufficialmente descritto come un &#8220;<a href=http://effbot.org/zone/element-xpath.htm>supporto limitato per le espressioni XPath</a>.&#8221; <a href=http://www.w3.org/TR/xpath>XPath</a> è uno standard W3C per effettuare ricerche nei documenti <abbr>XML</abbr>. Il linguaggio di richiesta di ElementTree è abbastanza simile a XPath da consentire ricerche di base, ma abbastanza diverso da potervi infastidire se conoscente già XPath. Ora diamo un'occhiata a una libreria <abbr>XML</abbr> di terze parti che estende la <abbr>API</abbr> di ElementTree con un supporto completo per XPath.

<h2 id=xml-lxml>Proseguire con lxml</h2>

<p><a href=http://codespeak.net/lxml/>lxml</a> è una libreria open source di terze parti che si basa sul popolare <a href=http://www.xmlsoft.org/>riconoscitore libxml2</a>. Fornisce una <abbr>API</abbr> compatibile al 100% con ElementTree, poi la estende con un supporto completo per XPath e alcune altre finezze. Ne esistono <a href=http://pypi.python.org/pypi/lxml/>installatori disponibili per Windows</a>; gli utenti Linux dovrebbero sempre provare a usare strumenti specifici per la loro distribuzione come <code>yum</code> o <code>apt-get</code> per installare binari precompilati dai loro <span class=wtf>repositories</span>. Altrimenti, dovrete <a href=http://codespeak.net/lxml/installation.html>installare lxml manualmente</a>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>from lxml import etree</kbd>                   <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>tree = etree.parse("esempi/feed.xml")</kbd>  <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>root = tree.getroot()</kbd>                    <span>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd>root.findall("{http://www.w3.org/2005/Atom}entry")</kbd>  <span>&#x2463;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b510>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b540>]</samp></pre>
<ol>
<li>Una volta importata, lxml fornisce la stessa <abbr>API</abbr> della libreria built-in ElementTree.
<li>La funzione <code>parse()</code>: la stessa di ElementTree.
<li>Il metodo <code>getroot()</code>: anche questo è lo stesso.
<li>Il metodo <code>findall()</code>: esattamente identico.
</ol>

<p>Per documenti <abbr>XML</abbr> grandi, lxml è significativamente più veloce rispetto alla libreria built-in ElementTree. Se state usando solo la <abbr>API</abbr> di ElementTree e volete usare l'implementazione più veloce disponibile, potete provare a importare lxml e <span class=wtf>fall back</span> alla libreria built-in ElementTree.

<pre><code>try:
    from lxml import etree
except ImportError:
    import xml.etree.ElementTree as etree</code></pre>

<p>Ma lxml è molto di più che una ElementTree più veloce. Essa integra anche il supporto per espressioni XPath arbitrarie. Non cercherò di approfondire la sintassi XPath. (Quello potrebbe essere un libro intero di per sé!) Ma vi mostrerò come si integra in lxml.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>import lxml.etree</kbd>                                                  <span>&#x2460;</span></a> 
<samp class=p>>>> </samp><kbd>tree = lxml.etree.parse("esempi/feed.xml")</kbd>
<a><samp class=p>>>> </samp><kbd>NSMAP = {"atom": "http://www.w3.org/2005/Atom"}</kbd>                    <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>entries = tree.xpath("//atom:category[@term='accessibility']/..",</kbd>  <span>&#x2462;</span></a>
<samp class=p>... </samp><kbd>    namespaces=NSMAP)</kbd>
<a><samp class=p>>>> </samp><kbd>entries</kbd>                                                            <span>&#x2463;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b630>]</samp>
<samp class=p>>>> </samp><kbd>entry = entries[0]</kbd>
<a><samp class=p>>>> </samp><kbd>entry.xpath("./atom:title/text()", namespaces=nsmap)</kbd>               <span>&#x2464;</span></a>
<samp>['Accessibility is a harsh mistress']</samp></pre>
<ol>
<li>Inn questo esempio, scriverò <code>import lxml.etree</code> (invece di, diciamo, <code>from lxml import etree</code>), per enfatizzare che queste caratteristiche sono specifiche di lxml.
<li>Per effettuare richieste XPath su elementi in uno spazio di nomi, avete bisogno di definire una corrispondenza tra prefissi e spazi di nomi sotto la semplice forma di un dizionario Python.
<li>Ecco una richiesta XPath. L'espressione XPath cerca gli elementi <code>category</code> (nello spazio di nomi Atom) che contengono un attributo <code>term</code> con il valore <code>accessibility</code>. Ma questo non è l'effettivo risultato della richiesta. Guardate alla fine della stringa di richiesta; avete notato quel <code>/..</code>? Questo significa &#8220;e poi restituisci l'elemento genitore dell'elemento <code>category</code> che hai appena trovato.&#8221; Così questa singola richiesta XPath troverà tutte le voci con un elemento figlio <code>&lt;category term="accessibility"></code>.
<li>La funzione <code>xpath()</code> restituisce una lista di oggetti ElementTree. In questo documento, c'è solo una voce con un elemento <code>category</code> il cui attributo <code>term</code> abbia il valore <code>accessibility</code>.
<li>Le espressioni XPath non restituiscono sempre una lista di elementi. Tecnicamente, la rappresentazione <abbr>DOM</abbr> di un documento <abbr>XML</abbr> <span class=wtf>parsed</span> non contiene elementi; contiene <i>nodi</i>. A seconda del loro tipo, i nodi possono essere elementi, attributi, o anche contenuti testuali. Il risultato di una richiesta XPath è una lista di nodi. Questa richiesta restituisce una lista di nodi testuali: il contenuto testuale (<code>text()</code>) dell'elemento <code>title</code> (<code>atom:title</code>) che è un figlio dell'elemento corrente (<code>./</code>).
</ol>

<h2 id=xml-generate>Generare XML</h2>

<p>Il supporto di Python per <abbr>XML</abbr> non si limita al riconoscimento di documenti esistenti. Potete anche creare documenti <abbr>XML</abbr> da zero.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import xml.etree.ElementTree as etree</kbd>
<a><samp class=p>>>> </samp><kbd>new_feed = etree.Element("{http://www.w3.org/2005/Atom}feed",</kbd>     <span>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd>    attrib={"{http://www.w3.org/XML/1998/namespace}lang": "en"})</kbd>  <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>print(etree.tostring(new_feed))</kbd>                                   <span>&#x2462;</span></a>
<samp>&lt;ns0:feed xmlns:ns0="http://www.w3.org/2005/Atom" xml:lang="en"/></samp></pre>
<ol>
<li>Per creare un nuovo elemento, istanziate la classe <code>Element</code>. Passate il nome dell'elemento (spazio di nomi + nome locale) come primo argomento. Questa istruzione crea un elemento <code>feed</code> nello spazio di nomi Atom. Questo sarà l'elemento radice del nostro nuovo documento.
<li>Per aggiungere attributi all'elemento appena creato, passate un dizionario di nomi e valori di attributi all'argomento <var>attrib</var>. Notate che i nomi di attributi dovrebbero essere nel formato standard di ElementTree, <code>{<var>spaziodinomi</var>}<var>nomelocale</var></code>.
<li>In ogni momento, potete serializzare qualsiasi elemento (e i suoi figli) con la funzione <code>tostring()</code> di ElementTree <code>tostring()</code>.
</ol>

<p>Quella serializzazione vi ha sorpreso? Il modo in cui ElementTree serializza gli spazi di nomi <abbr>XML</abbr> è tecnicamente accurato ma non ottimale. Il documento <abbr>XML</abbr> di esempio all'inizio di questo capitolo definiva uno <i>spazio di nomi di default</i> (<code>xmlns="http://www.w3.org/2005/Atom"</code>). Definire uno spazio di nomi di default è utile per documenti &mdash; come i feed Atom &mdash; dove tutti gli elementi sono nello stesso spazio di nomi, perché potete dichiarare lo spazio di nomi una volta sola e dichiarare ogni elemento utilizzando semplicemente il suo nome locale (<code>&lt;feed></code>, <code>&lt;link></code>, <code>&lt;entry></code>). Non c'è alcun bisogno di usare un prefisso a meno che non vogliate dichiarare elementi appartenenti a un altro spazio di nomi.

<p>Un riconoscitore <abbr>XML</abbr> non sarà in grado di &#8220;vedere&#8221; alcuna differenza tra un documento <abbr>XML</abbr> con uno spazio di nomi di default e un documento <abbr>XML</abbr> con uno spazio di nomi che utilizza un prefisso. La rappresentazione <abbr>DOM</abbr> che risulta da questa serializzazione:

<pre class=nd><code>&lt;ns0:feed xmlns:ns0="http://www.w3.org/2005/Atom" xml:lang="en"/></code></pre>

<p>è identica alla rappresentazione <abbr>DOM</abbr> di questa serializzazione:

<pre class=nd><code>&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"/></code></pre>

<p>L'unica differenza concreta è che la seconda serializzazione è più corta di diversi caratteri. Se dovessimo interamente riscrivere il nostro feed di esempio con un prefisso <code>ns0:</code> in ogni tag di apertura e chiusura, aggiungeremmo 4 caratteri per tag di apertura &times; 79 tag + 4 caratteri per la dichiarazione di spazio di nomi, per un totale di 316 caratteri. Assumendo una <a href=stringhe.html#byte-arrays>codifica UTF-8</a>, questo risulta in 316 byte aggiuntivi. (Dopo aver compresso il documento tramite gzip, la differenza scende a 21 bytes, ma nondimento, 21 byte sono 21 byte.) Forse per voi non ha importanza, ma per qualcosa come un feed Atom, che potrebbe essere scaricato diverse migliaia di volte ogni volta che cambia, risparmiare alcuni byte per ogni richiesta può accumularsi velocemente.

<p>La libreria built-in ElementTree non offre questo controllo a grana fine sulla serializzazione di elementi in uno spazio di nomi, ma lxml lo fa.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import lxml.etree</kbd>
<a><samp class=p>>>> </samp><kbd>NSMAP = {None: "http://www.w3.org/2005/Atom"}</kbd>                     <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>new_feed = lxml.etree.Element("feed", nsmap=NSMAP)</kbd>                <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>print(lxml.etree.tounicode(new_feed))</kbd>                             <span>&#x2462;</span></a>
<samp>&lt;feed xmlns="http://www.w3.org/2005/Atom"/></samp>
<a><samp class=p>>>> </samp><kbd>new_feed.set("{http://www.w3.org/XML/1998/namespace}lang", "en")</kbd>  <span>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd>print(lxml.etree.tounicode(new_feed))</kbd>
<samp>&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"/></samp></pre>
<ol>
<li>Per cominciare, definite una corrispondenza di spazi di nomi sotto forma di dizionario. I valori del dizionario sono spazi di nomi; le chiavi del dizionario sono i prefissi desiderati. Usare <code>None</code> come prefisso dichiara efficacemente uno spazio di nomi di default.
<li>Ora potete passare l'argomento <var>nsmap</var> specifico per lxml quando create un elemento, e lxml rispetterà i prefissi per gli spazi di nomi che avete definito.
<li>Come vi sareste aspettati, questa serializzazione definisce lo spazio di nomi Atom come spazio di nomi di default e dichiara l'elemento <code>feed</code> senza un prefisso per lo spazio di nomi.
<li>Oops, abbiamo dimenticato di aggiungere l'attributo <code>xml:lang</code>. Potete sempre aggiungere attributi a qualsiasi elemento tramite il metodo <code>set()</code>. Esso prende due argomenti: il nome dell'attributo nel formato standard di ElementTree, poi il valore dell'attributo. (Questo metodo non è specifico per lxml. L'unica parte specifica per lxml in questo esempio era l'argomento <var>nsmap</var> per controllare i prefissi degli spazi di nomi nell'uscita serializzata.)
</ol>

<p>I documenti <abbr>XML</abbr> si limitano ad avere un elemento per documento? No, naturalmente no. Potete facilmente creare anche elementi figli.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>title = lxml.etree.SubElement(new_feed, "title",</kbd>          <span>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd>    attrib={"type":"html"})</kbd>                               <span>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd>print(lxml.etree.tounicode(new_feed))</kbd>
<samp>&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">&lt;title type="html"/>&lt;/feed></samp>
<a><samp class=p>>>> </samp><kbd>title.text = "dive into &amp;hellip;"</kbd>                         <span>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd>print(lxml.etree.tounicode(new_feed))</kbd>                     <span>&#x2463;</span></a>
<samp>&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">&lt;title type="html">dive into &amp;amp;hellip;&lt;/title>&lt;/feed></samp>
<a><samp class=p>>>> </samp><kbd>print(lxml.etree.tounicode(new_feed, pretty_print=True))</kbd>  <span>&#x2464;</span></a>
<samp>&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
&lt;title type="html">dive into&amp;amp;hellip;&lt;/title>
&lt;/feed></samp></pre>
<ol>
<li>Per creare un elemento figlio di un elemento esistente, istanziate la classe <code>SubElement</code>. Gli unici argomenti richiesti sono l'elemento genitore (<var>new_feed</var> in questo caso) e il nome del nuovo elemento. Dato che questo elemento figlio erediterà la corrispondenza di spazi di nomi del suo genitore, qui non c'è bisogno di dichiarare nuovamente lo spazio di nome o il prefisso.
<li>Potete anche passare in ingresso un dizionario di attributi. Le chiavi sono i nomi degli attributi; i valori sono i valori degli attributi.
<li>Come vi sareste aspettati, il nuovo elemento <code>title</code> è stato creato nello spazio di nomi Atom, e inserito come figlio dell'elemento <code>feed</code>. Dato che l'elemento <code>title</code> non ha contenuto testuale e non ha figli propri, lxml lo serializza come un elemento vuoto (utilizzando l'abbreviazione <code>/></code>).
<li>Per impostare il contenuto testuale di un elemento, impostate semplicemente la sua proprietà <code>text</code>.
<li>Ora l'elemento <code>title</code> è serializzato insieme al suo contenuto testuale. Durante la serializzazione &Egrave; necessario effettuare l'escape del contenuto testuale che contiene segni di minore oppure caratteri di E commerciale. lxml gestisce questo processo in maniera automatica.
<li>Potete anche applicare <span class=wtf>&#8220;pretty printing&#8221;</span> alla serializzazione, che inserisce ritorni a capo dopo i tag di chiusura e prima dei tag di apertura di elementi che contengono elementi figli ma non hanno contenuto testuale. In termini tecnici, lxml aggiunge &#8220;spazio bianco non significativo&#8221; per rendere l'uscita più leggibile.
</ol>

<h2 id=xml-custom-parser>Personalizzare il vostro riconoscitore XML</h2>

<p>La specifica <abbr>XML</abbr> obbliga  tutti i riconoscitori <abbr>XML</abbr> conformanti a impiegare una &#8220;gestione degli errori draconiana.&#8221; Vale a dire, i riconoscitori si devono fermare e prendere fuoco non appena scoprono un qualsiasi tipo di errore di malformazione nel documento <abbr>XML</abbr>. Gli errori di malformazione includono tag di apertura e chiusura che non corrispondono, entità non definite, caratteri Unicode illegali e un numero di altre regole esoteriche. Questo è in netto contrasto con altri formati comuni come <abbr>HTML</abbr> &mdash; il vostro browser non smette di visualizzare una pagina web se dimenticate di chiudere un tag <abbr>HTML</abbr> o di effettuare l'escape di una E commerciale nel valore di un attributo. (&Egrave; un equivoco comune che <abbr>HTML</abbr> non abbia una gestione degli errori definita. La <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#parsing>gestione degli errori <abbr>HTML</abbr></a> è in realtà piuttosto ben definita, ma è significativamente più complicata di &#8220;fermati e prendi fuoco al primo errore.&#8221;)

<p>Alcune persone (me compreso) credono che l'obbligo a una gestione degli errori draconiana sia stato un errore da parte degli inventori di <abbr>XML</abbr>. Non fraintendetemi; posso certmente vedere la seduzione di una semplificazione delle regole di gestione degli errori. Ma nella pratica il concetto di &#8220;malformazione&#8221; è più complicato di quanto sembra, specialmente per documenti <abbr>XML</abbr> (come i feed Atom) che sono pubblicati sul web e serviti attraverso <abbr>HTTP</abbr>. Nonostante la maturità di <abbr>XML</abbr>, che si è assestato sulla gestione draconiana degli errori nel 1997, i rilevamenti mostrano continuamente che una frazione significativa di feed Atom sul web sono piagati da errori di malformazione.

<p>Quindi, ho ragioni sia teoriche che pratiche per riconoscere documenti <abbr>XML</abbr> &#8220;a tutti i costi,&#8221; cioè per <em>non</em> fermarmi e prendere fuoco al primo errore di malformazione. Se vi trovate a voler fare questa cosa anche voi, lxml può aiutarvi.

<p>Ecco un frammento di un documento <abbr>XML</abbr> <span class=wtf>broken</span>. Ho evidenziato l'errore di malformazione.

<pre class=nd><code>&lt;?xml version="1.0" encoding="utf-8"?>
&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  &lt;title>dive into <mark>&hellip;</mark>&lt;/title>
...
&lt;/feed></code></pre>

<p>Quello è un errore perché l'entità <code>&amp;hellip;</code> non è definita in <abbr>XML</abbr>. (&Egrave; definita in <abbr>HTML</abbr>.) Se provate a riconoscere questo feed <span class=wtf>broken</span> con le impostazioni di default, lxml si bloccherà sulla entità non definita.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import lxml.etree</kbd>
<samp class=p>>>> </samp><kbd>tree = lxml.etree.parse("esempi/feed-broken.xml")</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "lxml.etree.pyx", line 2693, in lxml.etree.parse (src/lxml/lxml.etree.c:52591)
  File "parser.pxi", line 1478, in lxml.etree._parseDocument (src/lxml/lxml.etree.c:75665)
  File "parser.pxi", line 1507, in lxml.etree._parseDocumentFromURL (src/lxml/lxml.etree.c:75993)
  File "parser.pxi", line 1407, in lxml.etree._parseDocFromFile (src/lxml/lxml.etree.c:75002)
  File "parser.pxi", line 965, in lxml.etree._BaseParser._parseDocFromFile (src/lxml/lxml.etree.c:72023)
  File "parser.pxi", line 539, in lxml.etree._ParserContext._handleParseResultDoc (src/lxml/lxml.etree.c:67830)
  File "parser.pxi", line 625, in lxml.etree._handleParseResult (src/lxml/lxml.etree.c:68877)
  File "parser.pxi", line 565, in lxml.etree._raiseParseError (src/lxml/lxml.etree.c:68125)
lxml.etree.XMLSyntaxError: Entity 'hellip' not defined, line 3, column 28</samp></pre>

<p>Per riconoscere questo documento <abbr>XML</abbr> <span class=wtf>broken</span>, nonostante il suo errore di malformazione, avete bisogno di creare un riconoscitore <abbr>XML</abbr> personalizzato.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>parser = lxml.etree.XMLParser(recover=True)</kbd>                  <span>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd>tree = lxml.etree.parse("esempi/feed-broken.xml", parser)</kbd>  <span>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd>parser.error_log</kbd>                                             <span>&#x2462;</span></a>
<samp>esempi/feed-broken.xml:3:28:FATAL:PARSER:ERR_UNDECLARED_ENTITY: Entity 'hellip' not defined</samp>
<samp class=p>>>> </samp><kbd>tree.findall("{http://www.w3.org/2005/Atom}title")</kbd>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}title at ead510>]</samp>
<samp class=p>>>> </samp><kbd>title = tree.findall("{http://www.w3.org/2005/Atom}title")[0]</kbd>
<a><samp class=p>>>> </samp><kbd>title.text</kbd>                                                   <span>&#x2463;</span></a>
<samp>'dive into '</samp>
<a><samp class=p>>>> </samp><kbd>print(lxml.etree.tounicode(tree.getroot()))</kbd>                  <span>&#x2464;</span></a>
<samp>&lt;feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  &lt;title>dive into &lt;/title>
.
. [rest of serialization snipped for brevity]
.</samp></pre>
<ol>
<li>Per creare un riconoscitore personalizzato, istanziate la classe <code>lxml.etree.XMLParser</code>. Può prendere <a href=http://codespeak.net/lxml/parsing.html#parser-options>un numero di differenti argomenti con nome</a>. Quello a cui siamo interessati qui è l'argomento <var>recover</var>. Quando viene impostato a <code>True</code>, il riconoscitore <abbr>XML</abbr> farà del suo meglio per &#8220;compensare&#8221; gli errori di malformazione.
<li>Per riconoscere un documento <abbr>XML</abbr> utilizzando il vostro riconoscitore personalizzato, passate l'oggetto <var>parser</var> come secondo argomento alla funzione <code>parse()</code>. Notate che lxml non solleva alcuna eccezione relativa all'entità <code>&amp;hellip;</code> non definita.
<li>Il riconoscitore mantiene un registro degli errori di malformazione che ha incontrato. (Questo è effettivamente vero a prescindere dal fatto di averlo impostato per compensare quegli errori oppure no.)
<li>Dato che non sapeva cosa fare con l'entità <code>&amp;hellip;</code> non definita, il riconoscitore l'ha semplicemente scartata in silenzio. Il contenuto testuale dell'elemento <code>title</code> diventa <code>"dive into "</code>.
<li>Come potete vedere dalla serializzazione, l'entità <code>&amp;hellip;</code> non è stata spostata; è stata semplicemente scartata.
</ol>

<p>&Egrave; importante reiterare che <strong>non c'è alcuna garanzia di interoperabilità</strong> con i riconoscitori <abbr>XML</abbr> che &#8220;compensano&#8221; gli errori di malformazione. Un riconoscitore differente potrebbe decidere che ha riconosciuto l'entità <code>&amp;hellip;</code> da <abbr>HTML</abbr> e rimpiazzarla con <code>&amp;amp;hellip;</code>. Questo è &#8220;meglio&#8221;? Forse. &Egrave; &#8220;più corretto&#8221;? No, sono entrambi ugualmente scorretti. Il comportamento corretto (in accordo con la specifica <abbr>XML</abbr>) è di fermarsi e prendere fuoco. Se avete deciso di non farlo, siete abbandonati a voi stessi.

<h2 id=furtherreading>Letture di approfondimento</h2>

<ul>
<li><a href=http://en.wikipedia.org/wiki/XML><abbr>XML</abbr> su Wikipedia.org</a>
<li><a href=http://docs.python.org/3.0/library/xml.etree.elementtree.html>La API <abbr>XML</abbr> di ElementTree</a>
<li><a href=http://effbot.org/zone/element.htm>Elementi e alberi di elementi</a>
<li><a href=http://effbot.org/zone/element-xpath.htm>Il supporto XPath in ElementTree</a>
<li><a href=http://effbot.org/zone/element-iterparse.htm>La funzione iterparse di ElementTree</a>
<li><a href=http://codespeak.net/lxml/>lxml</a>
<li><a href=http://codespeak.net/lxml/1.3/parsing.html>Riconoscere <abbr>XML</abbr> e <abbr>HTML</abbr> con lxml</a>
<li><a href=http://codespeak.net/lxml/1.3/xpathxslt.html>Usare XPath e <abbr>XSLT</abbr> con lxml</a>
</ul>

<p class=c>&copy; 2001&ndash;9 <a href=informazioni-sul-libro.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
