<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Test di unità - Dive into Python 3</title>
<link rel=stylesheet type=text/css href=dip3.css>
<link rel=stylesheet type=text/css href=dip3-it.css>
<style>
body{counter-reset:h1 8}
</style>
<link rel=stylesheet type=text/css media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=root value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span>&#8227;</span> <a href=table-of-contents.html#unit-testing>Dive Into Python 3</a> <span>&#8227;</span>
<p id=level>Livello di difficoltà: <span title=intermedio>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Test di unità</h1>
<blockquote class=q>
<p><span>&#x275D;</span> Certitude is not the test of certainty. We have been cocksure of many things that were not so. <span>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Oliver_Wendell_Holmes,_Jr.>Oliver Wendell Holmes, Jr.</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione! (Oppure no?)</h2>
<p class=f>In questo capitolo, scriverete e farete il debug di un insieme di funzioni di utilità per convertire da e verso i numeri romani. Avete visto le meccaniche per la costruzione e la validazione dei numeri romani nel <a href="espressioni-regolari.html#romannumerals">&#8220;Caso di studio: numeri romani&#8221;</a>. Ora fate un passo indietro e considerate cosa ci vorrebbe per espandere quel programma in una utilità a due vie.
<p><a href="espressioni-regolari.html#romannumerals">Le regole per i numeri romani</a> ci hanno condotto a una serie di interessanti osservazioni:
<ol>
<li>C'è un solo modo corretto di rappresentare un particolare numero come numero romano.
<li>Anche l'inverso è vero: se una stringa di caratteri è un numero romano valido, rappresenta un solo numero (cioè, può essere interpretata in un solo modo).
<li>C'è un intervallo limitato di numeri che possono essere espressi come numeri Romani, che nello specifico va da <code>1</code> a <code>3999</code>. (I romani avevano diversi modi di esprimere numeri più grandi, per esempio avendo una barra sopra un numero per rappresentare che il suo valore normale doveva essere moltiplicato per 1000, ma non ce ne occuperemo. Per gli scopi di questo capitolo, conveniamo che i numeri romani vanno da <code>1</code> a <code>3999</code>.) 
<li>Non c'è alcun modo di rappresentare <code>0</code> nei numeri romani.
<li>Non c'è alcun modo di rappresentare numeri negativi nei numeri romani.
<li>Non c'è alcun modo di rappresentare frazioni o numeri non interi nei numeri romani.
</ol>
<p>Cominciamo col tracciare quello che un modulo <code>roman.py</code> dovrebbe fare. Avrà due funzioni principali, <code>to_roman()</code> e <code>from_roman()</code>. La funzione <code>to_roman()</code> dovrà prendere un intero da <code>1</code> a <code>3999</code> e restituirne la rappresentazione come numero romano sotto forma di stringa&hellip;</p>
<p>Fermiamoci subito qui. Ora facciamo qualcosa di un poco inaspettato: scriviamo un test per controllare che la funzione <code>to_roman()</code> faccia quello che volete. Avete letto bene: state per srivere codice che collauda codice che non avete ancora scritto.
<p>Questo si chiama <i>collaudo di unità</i>. L'insieme di due funzioni di conversione &mdash; <code>to_roman(), e più tardi <code>from_roman()</code> &mdash; può essere implementato e collaudato come una singola unità, separata da qualsiasi programma più grande che le importi. Python possiede un framework per il collaudo di unità, un modulo propriamente chiamato <code>unittest</code>.
<p>Il collaudo di unità è una parte importante di una strategia di sviluppo complessivamente centrata sui test. Se scrivete dei test di unità, è importante che li scriviate presto (preferibilmente prima di scrivere il codice che collaudano), e che li manteniate aggiornati man mano che il codice e i requisiti cambiano. Il collaudo di unità non è un rimpiazzo per collaudi funzionali o di sistema di più alto livello, ma è importante in tutte le fasi dello sviluppo:
<ul>
<li>Prima di scrivere codice, vi obbliga a dettagliare i vostri requisiti in modo utile.
<li>Mentre scrivete codice, vi preserva dallo scriverne troppo. Quando tutti i test passano, la funzione è completa.
<li>Quando applicate il refactoring al codice, vi assicura che la nuova versione si comporta allo stesso modo della vecchia versione.
<li>Quando state manutenendo il codice, vi aiuta a pararvi il culo quando qualcuno arriva urlando che il vostro ultimo cambiamento ha rotto il suo vecchio codice (&#8220;Ma <em>signore</em>, tutti i test di unità passavano quando <span class=wtf>I checked it in</span>&hellip;&#8221;)
<li>Quando scrivete codice in gruppo, aumenta la confidenza che il codice che state per <span class=wtf>commit</span> non andrà a rompere il codice di qualcun altro, perché potete lanciare i loro test di unità prima. (Ho visto questo tipo di cose nei <span class=wtf>code sprints</span>. Un gruppo si divide i compiti, ognuno prende le specifiche per il proprio compito, scrive test di unità per esso, e poi condividie i test di unità con il resto del gruppo. In quel modo, nessuno va talmente lontano fino a sviluppare codice che non gioca bene con gli altri.)
</ul>
<h2 id=romantest1>Una singola domanda</h2>
<aside>Ogni test è un'isola.</aside>
<p>Un test risponde a una singola domanda sul codice che sta collaudando. Un test dovrebbe essere in grado di&hellip;
<ul>
<li>&hellip;eseguire completamente da solo, senza alcun input umano. Il collaudo di unità ha a che fare con l'automazione.
<li>&hellip;determinare da solo se la funzione che sta collaudando ha avuto successo oppure è fallita, senza un umano che interpreti i risultati.
<li>&hellip;eseguire in isolamento, separato da qualsiasi altro test (anche se insistono sulla stessa funzione). Ogni test è un'isola.
</ul>
<p>Detto questo, costruiamo un test per il primo requisito:
<ol>
<li>La funzione <code>to_roman()</code> dovrebbe restituire la rappresentazione come numero romano di tutti gli interi da <code>1</code> a <code>3999</code>.
</ol>
<p>Non è immediatamente ovvio come questo codice faccia&hellip; be', <em>niente</em>. Definisce una classe che non ha alcun metodo <code>__init__()</code> method. La classe <em>ha</em> un altro metodo, ma non viene mai chiamato. L'intero script ha un blocco <code>__main__</code>, ma non fa riferimento alla classe o al suo metodo. Ma fa qualcosa, prometto.
<p class=d>[<a href=esempi/romantest1.py>scarica <code>romantest1.py</code></a>]
<pre><code>import roman1
import unittest

<a>class KnownValues(unittest.TestCase):               <span>&#x2460;</span></a>
    known_values = ( (1, 'I'),
                     (2, 'II'),
                     (3, 'III'),
                     (4, 'IV'),
                     (5, 'V'),
                     (6, 'VI'),
                     (7, 'VII'),
                     (8, 'VIII'),
                     (9, 'IX'),
                     (10, 'X'),
                     (50, 'L'),
                     (100, 'C'),
                     (500, 'D'),
                     (1000, 'M'),
                     (31, 'XXXI'),
                     (148, 'CXLVIII'),
                     (294, 'CCXCIV'),
                     (312, 'CCCXII'),
                     (421, 'CDXXI'),
                     (528, 'DXXVIII'),
                     (621, 'DCXXI'),
                     (782, 'DCCLXXXII'),
                     (870, 'DCCCLXX'),
                     (941, 'CMXLI'),
                     (1043, 'MXLIII'),
                     (1110, 'MCX'),
                     (1226, 'MCCXXVI'),
                     (1301, 'MCCCI'),
                     (1485, 'MCDLXXXV'),
                     (1509, 'MDIX'),
                     (1607, 'MDCVII'),
                     (1754, 'MDCCLIV'),
                     (1832, 'MDCCCXXXII'),
                     (1993, 'MCMXCIII'),
                     (2074, 'MMLXXIV'),
                     (2152, 'MMCLII'),
                     (2212, 'MMCCXII'),
                     (2343, 'MMCCCXLIII'),
                     (2499, 'MMCDXCIX'),
                     (2574, 'MMDLXXIV'),
                     (2646, 'MMDCXLVI'),
                     (2723, 'MMDCCXXIII'),
                     (2892, 'MMDCCCXCII'),
                     (2975, 'MMCMLXXV'),
                     (3051, 'MMMLI'),
                     (3185, 'MMMCLXXXV'),
                     (3250, 'MMMCCL'),
                     (3313, 'MMMCCCXIII'),
                     (3408, 'MMMCDVIII'),
                     (3501, 'MMMDI'),
                     (3610, 'MMMDCX'),
                     (3743, 'MMMDCCXLIII'),
                     (3844, 'MMMDCCCXLIV'),
                     (3888, 'MMMDCCCLXXXVIII'),
                     (3940, 'MMMCMXL'),
<a>                     (3999, 'MMMCMXCIX'))           <span>&#x2461;</span></a>

<a>    def test_to_roman_known_values(self):           <span>&#x2462;</span></a>
        """to_roman should give known result with known input"""
        for integer, numeral in self.known_values:
<a>            result = roman1.to_roman(integer)       <span>&#x2463;</span></a>
<a>            self.assertEqual(numeral, result)       <span>&#x2464;</span></a>

if __name__ == "__main__":
    unittest.main()</code></pre>
<ol>
<li>Per scrivere un test, come prima cosa estendete la classe <code>TestCase</code> del modulo <code>unittest</code>. Questa classe mette a disposizione molti metodi utili che potete usare nel vostro test per specificare condizioni specifiche di collaudo.
<li>Questa è una lista di coppie interi/romani che ho verificato manualmente. Include i dieci numeri più bassi, il numero più alto, ogni numero che si traduce in un numero romano con un singolo carattere, e una serie di esempi casuali di altri numeri validi. Il punto di un test di unità non è collaudare ogni possibile ingresso, ma collaudarne un campione rappresentativo.
<li>Ogni test individuale ha il proprio metodo, che non deve prendere alcun parametro e ritornare alcun valore. Se il metodo ritorna normalmente senza sollevare una eccezione, il test si considera passato; se il metodo solleva una eccezione, il test si considera fallito.
<li>Qui potete chiamare la funzione <code>to_roman()</code>. (Be', la funzione non è ancora stata scritta, ma una volta che lo sarà, questa è la riga che la chiamerà.) Notate che avete definito la <abbr>API</abbr> per la funzione <code>to_roman()</code>: deve prendere un intero (il numero da convertire) e restituire una stringa (la rappresentazione come numero romano). Se la <abbr>API</abbr> è differente, il test si considera fallito. Notate anche che non state catturando alcuna eccezione quando chiamate <code>to_roman()</code>. Questo è intenzionale. <code>to_roman()</code> non dovrebbe sollevare alcuna eccezione quando lo chiamate con un ingresso valido, e questi valori di ingresso sono tutti validi. Se <code>to_roman()</code> solleva una eccezione, questo test si considera fallito.
<li>Supponendo che la funzione <code>to_roman()</code> sia stata definita correttamente, invocata correttamente, abbia completato con successo la propria esecuzione, e abbia restituito un valore, l'ultimo passo è controllare se ha restituito il valore <em>corretto</em>. Questa è una domanda comune, e la classe <code>TestCase</code> vi fornisce un metodo, <code>assertEqual</code>, per controllare se due valori sono uguali. Se il risultato restituito da <code>to_roman()</code> (<var>result</var>) non corrisponde al valore noto che vi stavate aspettando (<var>numeral</var>), <code>assertEqual</code> solleverà una eccezione e il test fallirà. Se i due valori sono uguali, <code>assertEqual</code> non farà nulla. Se tutti i valori restituiti da <code>to_roman()</code> corrispondono ai valori che vi aspettate, <code>assertEqual</code> non solleverà mai una eccezione, così <code>testToRomaKnownValues</code> alla fine uscirà normalmente, il che significa che <code>to_roman()</code> avrà passato questo test.
</ol>
<aside>Scrivete un test che fallisce, e poi codice fino a quando ha successo.</aside>
<p>Una volta che avete un test, potete cominciare a implementare la funzione <code>to_roman()</code>. Prima di tutto, dovreste crearla come una funzione vuota e verificare che il test fallisca. Se il test ha successo prima che abbiate scritto del codice, state sbagliando qualcosa &mdash; i vostri test non stanno per niente collaudando il vostro codice! Scrivete un test che fallisce, e poi codice fino a quando ha successo.
<pre><code># roman1.py

function to_roman(n):
    """convert integer to Roman numeral"""
<a>    pass                                   <span>&#x2460;</span></a></code></pre>
<ol>
<li>A questo punto, volete definire la <abbr>API</abbr> della funzione <code>to_roman()</code>, ma non volete ancora scriverne il codice. (Il vostro test deve prima fallire.) Per crearne lo scheletro, usate la parola riservata <code>pass</code> di Python <span class=fixme>[FIXME ref]</span>, che non fa precisamente niente.
</ol>
<p>Eseguite <code>romantest1.py</code> dalla linea di comando per lanciare i test. Se chiamate lo script con l'opzione <code>-v</code>, vi darà un output più verboso in modo che possiate esattamente vedere cosa succede quando ogni test viene eseguito. Con ogni probabilità, il vostro output dovrebbe somigliare a questo:
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest1.py -v</kbd>
<samp><a>to_roman should give known result with known input ... FAIL            <span>&#x2460;</span></a>

======================================================================
FAIL: to_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest1.py", line 73, in test_to_roman_known_values
    self.assertEqual(numeral, result)
<a>AssertionError: 'I' != None                                            <span>&#x2461;</span></a>

----------------------------------------------------------------------
<a>Ran 1 test in 0.016s                                                   <span>&#x2462;</span></a>

<a>FAILED (failures=1)                                                    <span>&#x2463;</span></a></samp></pre>
<ol>
<li>Lanciare lo script esegue <code>unittest.main()</code>, che esegue ogni test. Ogni test è un metodo all'interno di ogni classe in <code>romantest.py</code> che erediti da <code>unittest.TestCase</code>. Per ogni test, il modulo <code>unittest</code> stamperà la <code>docstring</code> del metodo e un risultato di successo o fallimento per quel test. Come ci aspettavamo, questo test fallisce.
<li>Per ogni test falilto, <code>unittest</code> visualizzerà le informazioni <span class=wtf>trace</span> che mostrano esattamente cos'è successo. In questo caso, la chiamata ad <code>assertEqual()</code> ha sollevato una eccezione di tipo <code>AssertionError</code> perché si aspettava che <code>to_roman(1)</code> restituisse <code>"I"</code>, ma non lo ha fatto. (Dato che non c'era nessuna istruzione esplicita di <code>return</code>, la funzione ha restituito <code>None</code>, il valore nullo di Python.)
<li>Dopo i dettagli di ogni test, <code>unittest</code> visualizza un riassunto di quanti test sono stati eseguiti e quanto tempo hanno impiegato.
<li>Nell'insieme, un test di unità è fallito perché almeno un test non è passato. Quando un test non passa, <code>unittest</code> distingue tra fallimenti ed errori. Un fallimento è una chiamata a un metodo <code>assertXYZ</code>, come <code>assertEqual</code> o <code>assertRaises</code>, che fallisce perché la condizione asserita non è vera o l'eccezione attesa non è stata sollevata. Un errore è qualsiasi altro tipo di eccezione sollevata dal codice che state collaudando o dal test di unità stesso.
</ol>
<p><em>Ora</em>, infine, potete scrivere la funzione <code>to_roman()</code>.
<p class=d>[<a href=esempi/roman1.py>scarica <code>roman1.py</code></a>]
<pre><code>roman_numeral_map = (('M',  1000),
                     ('CM', 900),
                     ('D',  500),
                     ('CD', 400),
                     ('C',  100),
                     ('XC', 90),
                     ('L',  50),
                     ('XL', 40),
                     ('X',  10),
                     ('IX', 9),
                     ('V',  5),
                     ('IV', 4),
<a>                     ('I',  1))                 <span>&#x2460;</span></a>

def to_roman(n):
    """convert integer to Roman numeral"""
    result = ""
    for numeral, integer in roman_numeral_map:
<a>        while n >= integer:                     <span>&#x2461;</span></a>
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li><var>roman_numeral_map</var> è una tupla di tuple che definisce tre cose: la rappresentazione a caratteri dei numeri romani più basilari; l'ordine dei numeri romani (discendente secondo il valore, da <code>M</code> fino a <code>I</code>); il valore di ogni numero romano. Ogni tupla interna è una coppia di <code>(<var>numero</var>, <var>valore</var>)</code>. Non ci sono solo i numeri romani con un singolo carattere; sono definiti anche coppie di due caratteri come <code>CM</code> (&#8220;un centinaio meno un migliaio&#8221;). Questo rende più semplice il codice della funzione <code>to_roman()</code>.
<li>Ed ecco dove la ricca struttura dati di <var>roman_numeral_map</var> vi ripaga, perché non avete bisogno di alcuna logica speciale per gestire la regola di sottrazione. Per convertire verso i numeri romani, dovete semplicemente iterare attraverso <var>roman_numeral_map</var> cercando il più grande valore intero minore o uguale al numero in ingresso. Una volta trovato, aggiungete la rappresentazione del numero romano alla fine del risultato, sottraete il corrispondente valore intero dal numero in ingresso, <span class=wtf>lather, rinse, repeat</span>.
</ol>
<p>Se non vi è ancora chiaro come la funzione <code>to_roman()</code> lavora, aggiungete una chiamata a <code>print()</code> alla fine del ciclo <code>while</code>:
<pre><code>
while n >= integer:
    result += numeral
    n -= integer
    print('subtracting {0} from input, adding {1} to output'.format(integer, numeral))</code></pre>
<p>Con le istruzioni <code>print()</code> di debug, il risultato somiglia al seguente:
<pre class=screen>
<samp class=p>>>> </samp><kbd>import roman1</kbd>
<samp class=p>>>> </samp><kbd>roman1.to_roman(1424)</kbd>
<samp>subtracting 1000 from input, adding M to output
subtracting 400 from input, adding CD to output
subtracting 10 from input, adding X to output
subtracting 10 from input, adding X to output
subtracting 4 from input, adding IV to output
'MCDXXIV'</samp></pre>
<p>Quindi la funzione <code>to_roman() sembra funzionare, almeno in questo controllo manuale. Ma passerà il test che avete scritto?
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest1.py -v</kbd>
<samp>to_roman should give known result with known input ... ok

----------------------------------------------------------------------
Ran 1 test in 0.016s

OK</samp></pre>
<ol>
<li>Urrà! La funzione <code>to_roman()</code> passa il test per i &#8220;valori noti.&#8221; Non è completo, ma mette alla prova la funzione con una varietà di ingressi, compresi interi che producono ogni numero romano con un singolo carattere, l'intero più grande possibile (<code>3999</code>), e l'intero che produce il numero romano più lungo (<code>3888</code>). A questo punto, potete essere ragionevolmente confidenti che la funzione funzioni per ogni ingresso valido che potete darle.
</ol>
<p>Ingresso &#8220;valido&#8221;? Hmm. E se l'ingresso non fosse valido?
<h2 id=romantest2>&#8220;Fermati e prendi fuoco&#8221;</h2>
<aside>Il modo che ha Python di fermarsi e prendere fuoco è sollevare una eccezione.</aside>
<p>Non è sufficiente verificare che una funzione abbia successo quando le viene dato un ingresso valido; dovete anche verificare che fallisca quando le viene dato un ingresso non valido. E non un qualsiasi tipo di fallimento; devono fallire nel modo che vi aspettate.
<pre class=screen>
<samp class=p>>>> </samp><kbd>import roman1</kbd>
<samp class=p>>>> </samp><kbd>roman1.to_roman(4000)</kbd>
<samp>'MMMM'</samp>
<samp class=p>>>> </samp><kbd>roman1.to_roman(5000)</kbd>
<samp>'MMMMM'</samp>
<a><samp class=p>>>> </samp><kbd>roman1.to_roman(9000)</kbd>  <span>&#x2460;</span></a>
<samp>'MMMMMMMMM'</samp></pre>
<ol>
<li>Questo non è assolutamente quello che volete &mdash; quello non è nemmeno un numero romano valido! In effetti, ognuno di questi numeri è fuori dall'intervallo degli ingressi accettabili, ma la funzione ritorna un finto valore comunque. Restituire silenziosamente valori sbagliati è <em>maaaaaaale</em>; se un programma deve fallire, è molto meglio che fallisca velocemente e rumorosamente. &#8220;Fermati e prendi fuoco,&#8221; come dice il detto. Il modo che ha Python per fermarsi e prendere fuoco è sollevare una eccezione.
</ol>
<p>La questione da chiedersi è, &#8220;Come posso esprimere questo sotto forma di un requisito collaudabile?&#8221; Che ne dite di questo, per cominciare:
<blockquote>
<p>La funzione <code>to_roman()</code> dovrebbe sollevare una eccezione di tipo <code>OutOfRangeError</code> quando le viene passato un intero più grande di <code>3999</code>.
</blockquote>
<p>Che aspetto potrebbe avere il test?
<p class=d>[<a href=esempi/romantest2.py>scarica <code>romantest2.py</code></a>]
<pre><code>
<a>class ToRomanBadInput(unittest.TestCase):                                 <span>&#x2460;</span></a>
<a>    def test_too_large(self):                                             <span>&#x2461;</span></a>
        """to_roman should fail with large input"""
<a>        self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)  <span>&#x2462;</span></a></code></pre>
<ol>
<li>Come nel test precedente, create una classe che eredita da <code>unittest.TestCase</code>. Potete avere più di un test per classe (come vedrete più tardi in questo capitolo), ma ho scelto di creare una nuova classe in questo caso perché questo collaudo è qualcosa di diverso rispetto all'ultimo. Terremo tutti i collaudi sugli ingressi validi insieme in una classe, e tutti i collaudi sugli ingressi non validi insieme in un'altra.
<li>Come nel test precedente, il test stesso è un metodo della classe, con un nome che comincia con <code>test</code>.
<li>La classe <code>unittest.TestCase</code> fornisce il metodo <code>assertRaises</code> method, che prende i seguenti argomenti: l'eccezione che vi aspettate, la funzione che state collaudando, e gli argomenti che volete passare a quella funzione. (Se la funzione che state collaudando prende più di un argomento, passateli tutti ad <code>assertRaises</code>, in ordine, e verranno passati direttamente alla funzione che state collaudando.)
</ol>
<p>Fate molta attenzione a quest'ultima riga di codice. Invece di chiamare direttamente <code>to_roman() e controllare manualmente che sollevi una particolare eccezione (avvolgendola in un blocco <code>try...except</code> <span class=fixme>[FIXME xref]</span>), il metodo <code>assertRaises</code> ha incapsulato tutto questo per noi. Tutto quello che fate è dirgli quali sono l'eccezione che vi aspettate (<code>roman2.OutOfRangeError</code>), la funzione (<code>to_roman()</code>), e gli argomenti della funzione (<code>4000</code>). Il metodo <code>assertRaises</code> si prende cura di chiamare <code>to_roman()</code> e controllare che sollevi <code>roman2.OutOfRangeError</code>.
<p>Notate anche che state passando la funzione <code>to_roman()</code> stessa come un argomento; non la state chiamando, e non ne state il nome sotto forma di stringa. Ho recentemente menzionato quant'è comodo che <a href="il-vostro-primo-programma-python.html#everythingisanobject">ogni cosa in Python sia un oggetto</a>?
<p>Quindi cosa succede quando lanciate la <span class=wtf>test suite</span> con questo nuovo test?
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
<a>to_roman should fail with large input ... ERROR                         <span>&#x2460;</span></a>

======================================================================
ERROR: to_roman should fail with large input                          
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest2.py", line 78, in test_too_large
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
<a>AttributeError: 'module' object has no attribute 'OutOfRangeError'      <span>&#x2461;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.000s

FAILED (errors=1)</samp></pre>
<ol>
<li>Avreste dovuto aspettarvi che questo fallisse (dato che non avete scritto ancora il codice per farlo passare), ma&hellip; non è esattamente &#8220;fallito,&#8221; ha invece avuto un &#8220;errore.&#8221; Questa è una distinzione sottile ma importante. Un test di unità ha effettivamente <em>tre</em> valori di ritorno: successo, fallimento, ed errore. Successo, ovviamente, significa che il test è passato &mdash; il codice ha fatto quello che vi aspettavate. &#8220;Fallimento&#8221; è il risultato del test precedente (fino a quando non avete scritto il codice per farlo passare) &mdash; eseguiva il codice ma il risultato non era quello che vi aspettavate. &#8220;Errore&#8221; significa che il codice non ha nemmeno eseguito correttamente.
<li>Perché il codice non ha eseguito correttamente? La <span class=wtf>traceback</span> dà la risposta: il modulo che state collaudando non ha una eccezione chiamata <code>OutOfRangeError</code>. Ricordate, avete passato questa eccezione al metodo <code>assertRaises()</code>, perché è l'eccezione che volete che la funzione sollevi dato un ingresso fuodi dall'intervallo consentito. Ma l'eccezione non esiste, quindi la chiamata al metodo <code>assertRaises()</code> fallisce. Non ha avuto la possibilità di collaudare la funzione <code>to_roman()</code>; non è arrivata così lontano.
</ol>
<p>Per risolvere questo problema, dovete definire l'eccezione <code>OutOfRangeError</code> in <code>roman2.py</code>.
<pre><code><a>class OutOfRangeError(ValueError):  <span>&#x2460;</span></a>
<a>    pass                            <span>&#x2461;</span></a></code></pre>
<ol>
<li>Le eccezioni sono classi. Un errore di tipo &#8220;out of range&#8221; è un tipo di errore sui valori &mdash; il valore passato come argomento è fuori dal suo intervallo accettabile. Così questa eccezione eredita dalla eccezione built-in <code>ValueError</code>. Questo non è strettamente necessario (avrebbe potuto semplicemente ereditare dalla classe base <code>Exception</code>), ma suona corretto.
<li>Le eccezioni non fanno effettivamente niente, ma avete bisogno di almeno una riga di codice per costruire una classe. Chiamare <code>pass</code> non fa precisamente nulla, ma è una riga di codice Python, e quindi costituisce una classe.
</ol>
<p>Ora lanciate nuovamente la <span class=wtf>test suite</span>.
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
<a>to_roman should fail with large input ... FAIL                          <span>&#x2460;</span></a>

======================================================================
FAIL: to_roman should fail with large input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest2.py", line 78, in test_too_large
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
<a>AssertionError: OutOfRangeError not raised by to_roman                 <span>&#x2461;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.016s

FAILED (failures=1)</samp></pre>
<ol>
<li>Il nuovo test non è ancora passato, ma non restituisce nemmeno un errore. Invece, il test fallisce. Questo è progresso! Significa che la chiamata al metodo <code>assertRaises</code> questa volta ha avuto successo, e che il framework per il collaudo di unità ha effettivamente collaudato la funzione <code>to_roman()</code>.
<li>Naturalmente, la funzione <code>to_roman()</code> non ha sollevato l'eccezione <code>OutOfRangeError</code> che avete appena definito, perché non gli avete ancora detto di farlo. Questa è una notizia eccellente! Significa che questo è un test valido &mdash; fallisce prima che scriviate il codice per farlo passare.
</ol>
<p>Ora potete scrivere il codice per far passare questo test.
<p class=d>[<a href=esempi/roman2.py>scarica <code>roman2.py</code></a>]
<pre><code>def to_roman(n):
    """convert integer to Roman numeral"""
    if n > 3999:
<a>        raise OutOfRangeError("number out of range (must be less than 3999)")  <span>&#x2460;</span></a>

    result = ""
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Questo è semplice: se l'ingresso dato (<var>n</var>) è più grande di <code>3999</code>, solleva una eccezione di tipo <code>OutOfRangeError</code>. Il test di unità non controlla il messaggio nella stringa che accompagna l'eccezione, sebbene possiate scrivere un altro test che faccia questo controllo (ma fate attenzione ai problemi di internazionalizzazione per stringhe che variano con l'ambiente o la lingua dell'utente).
</ol>
<p>Questo fa passare il test? Scopriamolo.
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
<a>to_roman should fail with large input ... ok                            <span>&#x2460;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</samp></pre>
<ol>
<li>Urrà! Entrambi i test passano. Dato che avete lavorato iterativamente, rimbalzando avanti e indietro tra i test e il codice, potete essere sicuri che le due righe di codice che avete scritto sono la causa del passaggio di quel test dal &#8220;fallimento&#8221; al &#8220;successo.&#8221; Questo tipo di confidenza si guadagna a un certo prezzo, ma si ripagherà da sola durante la vita del vostro codice.
</ol>

<h2 id=romantest3>Più fermate, più fuoco</h2>

<p>Insieme al collaudo per numeri troppo grandi, avete bisogno di collaudare numeri che siano troppo piccoli. Come <a href=#divingin>abbiamo notato nei nostri requisiti funzionali</a>, i numeri romani non posso esprimere lo <code>0</code> o i numeri negativi.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import roman2</kbd>
<samp class=p>>>> </samp><kbd>roman2.to_roman(0)</kbd>
<samp>''</samp>
<samp class=p>>>> </samp><kbd>roman2.to_roman(-1)</kbd>
<samp>''</samp></pre>

<p><em>Questo</em> non va bene. Aggiungiamo dei test per ognuna di queste condizioni.

<p class=d>[<a href=esempi/romantest3.py>scarica <code>romantest3.py</code></a>]
<pre><code>
class ToRomanBadInput(unittest.TestCase):
    def test_too_large(self):
        """to_roman should fail with large input"""
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 4000)  <span>&#x2460;</span></a>

    def test_zero(self):
        """to_roman should fail with 0 input"""
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)     <span>&#x2461;</span></a>

    def test_negative(self):
        """to_roman should fail with negative input"""
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)    <span>&#x2462;</span></a></code></pre>
<ol>
<li>Il metodo <code>test_too_large()</code> non è cambiato rispetto al passo precedente. Lo includo qui per mostrare dove trova posto il nuovo codice.
<li>Ecco un nuovo test: il metodo <code>test_zero()</code>. Come il metodo <code>test_too_large()</code>, dice al metodo <code>assertRaises()</code> definito in <code>unittest.TestCase</code> di chiamare la nostra funzione <code>to_roman()</code> con un parametro di <code>0</code>, e verificare che sollevi l'eccezione appropriata, <code>OutOfRangeError</code>.
<li>Il metodo <code>test_negative()</code> è quasi identico, se non che passa <code>-1</code> alla funzione <code>to_roman()</code>. Se uno di questi nuovi test <em>non</em> solleva una eccezione di tipo <code>OutOfRangeError</code> (perché la funzione restituisce un valore, o perché solleva qualche altra eccezione), il test si considera fallito.
</ol>

<p>Ora verifichiamo che il test fallisca:

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest3.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
to_roman should fail with negative input ... FAIL
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... FAIL

======================================================================
FAIL: to_roman should fail with negative input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest3.py", line 86, in test_negative
    self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)
AssertionError: OutOfRangeError not raised by to_roman

======================================================================
FAIL: to_roman should fail with 0 input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest3.py", line 82, in test_zero
    self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)
AssertionError: OutOfRangeError not raised by to_roman

----------------------------------------------------------------------
Ran 4 tests in 0.000s

FAILED (failures=2)</samp></pre>

<p>Eccellente. Entrambi i test falliscono, come era da aspettarsi. Ora passiamo al codice e vediamo cosa possiamo fare per farli passare.

<p class=d>[<a href=esempi/roman3.py>scarica <code>roman3.py</code></a>]
<pre><code>def to_roman(n):
    """convert integer to Roman numeral"""
<a>    if not (0 < n < 4000):                                              <span>&#x2460;</span></a>
<a>        raise OutOfRangeError("number out of range (must be 0..3999)")  <span>&#x2461;</span></a>

    result = ""
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Questa è una classica scorciatoia di Python: confronti multipli allo stesso tempo. Questo è equivalente a <code>if not ((0 &lt; n) and (n &lt; 4000))</code>, ma è molto più facile da leggere. Questa riga di codice dovrebbe catturare gli ingressi che sono troppo grandi, negativi, o zero.
<li>Se cambiate le vostre condizioni, assicuratevi di aggiornare i vostri messaggi in modo che riflettano i cambiamenti. Il framework <code>unittest</code> non se ne curerà, ma renderebbe difficile effettuare un controllo manuale se il vostro codice lanciasse eccezioni non correttamente descritte.
</ol>

<p>Potrei mostrarvi un'intera serie di esempi non correlati che mostrano che la scorciatoia dei confronti multipli allo stesso tempo funziona, ma invece eseguirò semplicemente i test di unità e lo dimostrerò.

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest3.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.016s

OK</samp></pre>

<h2 id=romantest4>E ancora una cosa&hellip;</h2>

<p>C'era anocra un <a href=#divingin>requisito funzionale</a> per la conversione dei numeri in numeri romani: gestire i numeri non interi.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import roman3</kbd>
<a><samp class=p>>>> </samp><kbd>roman3.to_roman(0.5)</kbd>  <span>&#x2460;</span></a>
<samp>''</samp>
<a><samp class=p>>>> </samp><kbd>roman3.to_roman(1.5)</kbd>  <span>&#x2461;</span></a>
<samp>'I'</samp></pre>
<ol>
<li>Oh, questo non va bene.
<li>Oh, questo è ancora peggio. Entrambi i casi dovrebbero sollevare una eccezione. Invece, danno risultati fasulli.
</ol>

<p>Fare il collaudo per i numeri non interi non è difficile. Prima di tutto, definite una eccezione chiamata <code>NonIntegerError</code>.

<pre><code># roman4.py
class OutOfRangeError(ValueError): pass
<mark>class NotIntegerError(ValueError): pass</mark></code></pre>

<p>Poi, scrivete un test che contolli l'eccezione <code>NonIntegerError</code>.

<pre><code>class ToRomanBadInput(unittest.TestCase):
    .
    .
    .
    def test_non_integer(self):
        """to_roman should fail with non-integer input"""
<mark>        self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)</mark></code></pre>

<p>Ora contollate che il test fallisca in maniera appropriata.

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest4.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... FAIL
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

======================================================================
FAIL: to_roman should fail with non-integer input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest4.py", line 90, in test_non_integer
    self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)
<mark>AssertionError: NotIntegerError not raised by to_roman</mark>

----------------------------------------------------------------------
Ran 5 tests in 0.000s

FAILED (failures=1)</samp></pre>

<p>Scrivete il codice che fa passare il test.

<pre><code>def to_roman(n):
    """convert integer to Roman numeral"""
    if not (0 < n < 4000):
        raise OutOfRangeError("number out of range (must be 0..3999)")
<a>    if not isinstance(n, int):                                          <span>&#x2460;</span></a>
<a>        raise NotIntegerError("non-integers can not be converted")      <span>&#x2461;</span></a>

    result = ""
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>La funzione built-in <code>isinstance()</code> verifica che una variabile sia di un particolare tipo (o, tecnicamente, di un qualsiasi tipo discendente).
<li>Se l'argomento <var>n</var> non è un <code>int</code>, sollevate la nostra eccezione <code>NotIntegerError</code> appena coniata.
</ol>

<p>Infine, controllate che il codice faccia effettivamente passare il test.

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest4.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK</samp></pre>

<!--
<li><a href="#roman.requirements">Requirement #3</a> specifies that <code>to_roman()</code> cannot accept a non-integer number, so here you test to make sure that <code>to_roman()</code> raises a <code>roman.NotIntegerError</code> exception when called with <code>0.5</code>. If <code>to_roman()</code> does not raise a <code>roman.NotIntegerError</code>, this test is considered failed.
-->

<!--
For instance, the <code>testFromRomanCase</code> method (&#8220;<code>from_roman()</code> should only accept uppercase input&#8221;) was an error, because the call to <code>numeral.upper()</code> raised an <code>AttributeError</code> exception, because <code>to_roman()</code> was supposed to return a string but didn't. But <code>testZero</code> (&#8220;<code>to_roman()</code> should fail with 0 input&#8221;) was a failure, because the call to <code>from_roman()</code> did not raise the <code>InvalidRomanNumeral</code> exception that <code>assertRaises</code> was looking for.
-->


<!--
<li>For each failed test case, <code>unittest</code> displays the trace information showing exactly what happened. In this case, the call to <code>assertRaises</code> (also called <code>failUnlessRaises</code>) raised an <code>AssertionError</code> because it was expecting <code>to_roman()</code> to raise an <code>OutOfRangeError</code> and it didn't.
-->


<!--
<p>Given all of this, what would you expect out of a set of functions to convert to and from Roman numerals?
<ol>
<li><code>to_roman</code> should return the Roman numeral representation for all integers <code>1</code> to <code>3999</code>.
<li><code>to_roman</code> should fail when given an integer outside the range <code>1</code> to <code>3999</code>.
<li><code>to_roman</code> should fail when given a non-integer number.
<li><code>from_roman</code> should take a valid Roman numeral and return the number that it represents.
<li><code>from_roman</code> should fail when given an invalid Roman numeral.
<li>If you take a number, convert it to Roman numerals, then convert that back to a number, you should end up with the number
      you started with. So <code>from_roman(to_roman(n)) == n</code> for all <var>n</var> in <code>1..3999</code>.
<li><code>to_roman</code> should always return a Roman numeral using uppercase letters.
<li><code>from_roman</code> should only accept uppercase Roman numerals (<i class=foreignphrase><abbr>i.e.</abbr></i> it should fail when given lowercase input).
</ol>
-->


<!--
<ol>
<li>The <code>re.compile</code> function can take an optional second argument, which is a set of one or more flags that control various options about the
            compiled regular expression. Here you're specifying the <code>re.VERBOSE</code> flag, which tells Python that there are in-line comments within the regular expression itself. The comments and all the whitespace around them are
<em>not</em> considered part of the regular expression; the <code>re.compile</code> function simply strips them all out when it compiles the expression. This new, &#8220;verbose&#8221; version is identical to the old version, but it is infinitely more readable.
</ol>
-->

<p class=c>&copy; 2001&ndash;9 <a href=about.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=jquery.js></script>
<script src=dip3.js></script>
