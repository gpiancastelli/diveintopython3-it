<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Test di unità - Dive into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<link rel=stylesheet href=dip3-it.css>
<style>
body{counter-reset:h1 8}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
</head>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input name=q size=25>&nbsp;<input type=submit name=root value=Search></div></form>
<p>Voi siete qui: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#unit-testing>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>Livello di difficoltà: <span class=u title=principiante>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Test di unità</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Certitude is not the test of certainty. We have been cocksure of many things that were not so. <span class=u>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Oliver_Wendell_Holmes,_Jr.>Oliver Wendell Holmes, Jr.</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Immersione! (Oppure no?)</h2>
<p class=f>In questo capitolo, scriverete e farete il debug di un insieme di funzioni di utilità per convertire da e verso i numeri romani. Avete visto le meccaniche per la costruzione e la validazione dei numeri romani nel <a href=espressioni-regolari.html#romannumerals>&#8220;Caso di studio: numeri romani&#8221;</a>. Ora fate un passo indietro e considerate come potremmo fare per trasformare quel programma in una utilità a due vie.
<p><a href=espressioni-regolari.html#romannumerals>Le regole per i numeri romani</a> ci hanno condotto a una serie di interessanti osservazioni:
<ol>
<li>C'è un solo modo corretto di rappresentare un particolare numero come numero romano.
<li>Anche l'inverso è vero: se una stringa di caratteri è un numero romano valido, rappresenta un solo numero (cioè, può essere interpretata in un solo modo).
<li>C'è un intervallo limitato di numeri che possono essere espressi come numeri romani, che nello specifico va da <code>1</code> a <code>3999</code>. (I romani avevano diversi modi di esprimere numeri più grandi, per esempio tracciando una barra sopra un numero per dire che il suo valore normale doveva essere moltiplicato per 1000, ma non ce ne occuperemo. Per gli scopi di questo capitolo, conveniamo che i numeri romani vadano da <code>1</code> a <code>3999</code>.) 
<li>Non c'è alcun modo di rappresentare <code>0</code> nei numeri romani.
<li>Non c'è alcun modo di rappresentare numeri negativi nei numeri romani.
<li>Non c'è alcun modo di rappresentare frazioni o numeri non interi nei numeri romani.
</ol>
<p>Cominciamo col tracciare quello che un modulo <code>roman.py</code> dovrebbe fare. Il modulo avrà due funzioni principali, <code>to_roman()</code> e <code>from_roman()</code>. La funzione <code>to_roman()</code> dovrà prendere un intero da <code>1</code> a <code>3999</code> e restituirne la rappresentazione come numero romano sotto forma di stringa&hellip;
<p>Fermiamoci subito qui. Ora facciamo qualcosa di un poco inaspettato: scriviamo un test per controllare che la funzione <code>to_roman()</code> faccia quello che volete. Avete letto bene: state per scrivere codice che collauda codice che non avete ancora scritto.
<p>Questa pratica si chiama <i>collaudo di unità</i>. L'insieme di due funzioni di conversione &mdash; <code>to_roman()</code> e, più tardi, <code>from_roman()</code> &mdash; può essere implementato e collaudato come una singola unità, separata da qualsiasi programma più grande che le importi. Python possiede un framework per il collaudo di unità, un modulo propriamente chiamato <code>unittest</code>.
<p>Il collaudo di unità è una parte importante di una strategia di sviluppo complessivamente centrata sui test. Se scrivete dei test di unità, è importante che li scriviate presto (preferibilmente prima di scrivere il codice che collaudano) e che li manteniate aggiornati man mano che il codice e i requisiti cambiano. Il collaudo di unità non è un rimpiazzo per collaudi funzionali o di sistema di più alto livello, ma è importante in tutte le fasi dello sviluppo:
<ul>
<li>Prima di scrivere codice, vi obbliga a dettagliare i vostri requisiti in modo utile.
<li>Mentre scrivete codice, vi preserva dallo scriverne troppo. Quando tutti i test passano, la funzione è completa.
<li>Quando applicate il refactoring al codice, vi assicura che la nuova versione si comporta allo stesso modo della vecchia versione.
<li>Quando state mantenendo il codice, vi aiuta a pararvi il culo quando qualcuno arriva urlando che il vostro ultimo cambiamento ha guastato il suo vecchio codice (&#8220;Ma <em>signore</em>, tutti i test di unità passavano quando <span class=wtf>I checked it in</span>&hellip;&#8221;)
<li>Quando scrivete codice in gruppo, aumenta la confidenza che il codice che state per <span class=wtf>commit</span> non andrà a guastare il codice di qualcun altro, perché potete lanciare i loro test di unità prima. (Ho visto questo tipo di cose nelle maratone di programmazione. Un gruppo si divide i compiti, ognuno prende le specifiche per il proprio compito, scrive test di unità per esso, e poi condivide i test di unità con il resto del gruppo. In quel modo, nessuno va talmente lontano fino a sviluppare codice che non si interfaccia bene con quello degli altri.)
</ul>

<p class=a>&#x2042;

<h2 id=romantest1>Una singola domanda</h2>
<aside>Ogni test è un'isola.</aside>
<p>Un test risponde a una singola domanda sul codice che sta collaudando. Un test dovrebbe essere in grado di&hellip;
<ul>
<li>&hellip;eseguire completamente da solo, senza alcun intervento umano. Il collaudo di unità ha a che fare con l'automazione.
<li>&hellip;determinare da solo se la funzione che sta collaudando ha avuto successo oppure è fallita, senza un umano che interpreti i risultati.
<li>&hellip;eseguire in isolamento, separato da qualsiasi altro test (anche se collaudano la stessa funzione). Ogni test è un'isola.
</ul>
<p>Detto questo, costruiamo un test per il primo requisito:
<ol>
<li>La funzione <code>to_roman()</code> dovrebbe restituire la rappresentazione come numero romano di tutti gli interi da <code>1</code> a <code>3999</code>.
</ol>
<p>Non è immediatamente ovvio come questo codice faccia&hellip; be', <em>alcunché</em>. Definisce una classe che non ha alcun metodo <code>__init__()</code>. La classe <em>ha</em> un altro metodo, ma non viene mai chiamato. L'intero script ha un blocco <code>__main__</code>, ma non fa riferimento alla classe o al suo metodo. Ma fa qualcosa, prometto.
<p class=d>[<a href=esempi/romantest1.py>scarica <code>romantest1.py</code></a>]
<pre><code class=pp>import roman1
import unittest

<a>class KnownValues(unittest.TestCase):               <span class=u>&#x2460;</span></a>
    known_values = ( (1, 'I'),
                     (2, 'II'),
                     (3, 'III'),
                     (4, 'IV'),
                     (5, 'V'),
                     (6, 'VI'),
                     (7, 'VII'),
                     (8, 'VIII'),
                     (9, 'IX'),
                     (10, 'X'),
                     (50, 'L'),
                     (100, 'C'),
                     (500, 'D'),
                     (1000, 'M'),
                     (31, 'XXXI'),
                     (148, 'CXLVIII'),
                     (294, 'CCXCIV'),
                     (312, 'CCCXII'),
                     (421, 'CDXXI'),
                     (528, 'DXXVIII'),
                     (621, 'DCXXI'),
                     (782, 'DCCLXXXII'),
                     (870, 'DCCCLXX'),
                     (941, 'CMXLI'),
                     (1043, 'MXLIII'),
                     (1110, 'MCX'),
                     (1226, 'MCCXXVI'),
                     (1301, 'MCCCI'),
                     (1485, 'MCDLXXXV'),
                     (1509, 'MDIX'),
                     (1607, 'MDCVII'),
                     (1754, 'MDCCLIV'),
                     (1832, 'MDCCCXXXII'),
                     (1993, 'MCMXCIII'),
                     (2074, 'MMLXXIV'),
                     (2152, 'MMCLII'),
                     (2212, 'MMCCXII'),
                     (2343, 'MMCCCXLIII'),
                     (2499, 'MMCDXCIX'),
                     (2574, 'MMDLXXIV'),
                     (2646, 'MMDCXLVI'),
                     (2723, 'MMDCCXXIII'),
                     (2892, 'MMDCCCXCII'),
                     (2975, 'MMCMLXXV'),
                     (3051, 'MMMLI'),
                     (3185, 'MMMCLXXXV'),
                     (3250, 'MMMCCL'),
                     (3313, 'MMMCCCXIII'),
                     (3408, 'MMMCDVIII'),
                     (3501, 'MMMDI'),
                     (3610, 'MMMDCX'),
                     (3743, 'MMMDCCXLIII'),
                     (3844, 'MMMDCCCXLIV'),
                     (3888, 'MMMDCCCLXXXVIII'),
                     (3940, 'MMMCMXL'),
<a>                     (3999, 'MMMCMXCIX'))           <span class=u>&#x2461;</span></a>

<a>    def test_to_roman_known_values(self):           <span class=u>&#x2462;</span></a>
        '''to_roman should give known result with known input'''
        for integer, numeral in self.known_values:
<a>            result = roman1.to_roman(integer)       <span class=u>&#x2463;</span></a>
<a>            self.assertEqual(numeral, result)       <span class=u>&#x2464;</span></a>

if __name__ == '__main__':
    unittest.main()</code></pre>
<ol>
<li>Per scrivere un test, come prima cosa estendete la classe <code>TestCase</code> del modulo <code>unittest</code>. Questa classe mette a disposizione molti metodi utili che potete usare nel vostro test per esprimere specifiche condizioni di collaudo.
<li>Questa è una lista di coppie interi/romani che ho verificato manualmente. Include i dieci numeri più bassi, il numero più alto, ogni numero che si traduce in un numero romano con un singolo carattere, e una serie di esempi casuali di altri numeri validi. Il punto di un test di unità non è collaudare ogni possibile ingresso, ma collaudarne un campione rappresentativo.
<li>Ogni test individuale ha il proprio metodo, che non deve prendere alcun parametro e restituire alcun valore. Se il metodo ritorna normalmente senza sollevare una eccezione, il test si considera passato; se il metodo solleva una eccezione, il test si considera fallito.
<li>Qui potete chiamare la funzione <code>to_roman()</code>. (Be', la funzione non è ancora stata scritta, ma una volta che lo sarà, questa è la riga che la chiamerà.) Notate che avete definito la <abbr>API</abbr> per la funzione <code>to_roman()</code>: deve prendere un intero (il numero da convertire) e restituire una stringa (la rappresentazione come numero romano). Se la <abbr>API</abbr> è differente, il test si considera fallito. Notate anche che state intenzionalmente evitando di catturare alcuna eccezione quando chiamate <code>to_roman()</code>. La funzione non dovrebbe sollevare alcuna eccezione quando la chiamate con un ingresso valido, e questi valori di ingresso sono tutti validi. Se <code>to_roman()</code> solleva una eccezione, questo test si considera fallito.
<li>Supponendo che la funzione <code>to_roman()</code> sia stata definita correttamente, invocata correttamente, abbia completato con successo la propria esecuzione e abbia restituito un valore, l'ultimo passo è controllare se ha restituito il valore <em>corretto</em>. Questa è una necessità talmente comune che la classe <code>TestCase</code> vi fornisce il metodo <code>assertEqual</code> per controllare se due valori sono uguali. Se il risultato restituito da <code>to_roman()</code> (<var>result</var>) non corrisponde al valore noto che vi stavate aspettando (<var>numeral</var>), <code>assertEqual()</code> solleverà una eccezione e il test fallirà. Se i due valori sono uguali, <code>assertEqual()</code> non farà nulla. Se tutti i valori restituiti da <code>to_roman()</code> corrispondono ai valori che vi aspettate, <code>assertEqual()</code> non solleverà mai alcuna eccezione, così <code>testToRomaKnownValues</code> concluderà normalmente la propria esecuzione, il che significa che <code>to_roman()</code> avrà passato questo test.
</ol>
<aside>Scrivete un test che fallisce, poi programmate fino a quando ha successo.</aside>
<p>Ora che avete scritto un test, potete cominciare a implementare la funzione <code>to_roman()</code>. Prima di tutto, dovreste creare lo scheletro vuoto della funzione e verificare che il test fallisca. Se il test ha successo prima che abbiate scritto del codice, state sbagliando qualcosa &mdash; i vostri test non stanno per niente collaudando il vostro codice! Scrivete un test che fallisce, poi programmate fino a quando ha successo.
<pre><code class=pp># roman1.py

function to_roman(n):
    '''convert integer to Roman numeral'''
<a>    pass                                   <span class=u>&#x2460;</span></a></code></pre>
<ol>
<li>A questo punto, volete definire la <abbr>API</abbr> della funzione <code>to_roman()</code>, ma non volete ancora scriverne il codice. (Il vostro test deve prima fallire.) Per creare lo scheletro della funzione, usate la parola riservata <code>pass</code> di Python <span class=fixme>[FIXME ref]</span>, che non fa precisamente niente.
</ol>
<p>Per lanciare i test, eseguite <code>romantest1.py</code> dalla linea di comando. Se chiamate lo script con l'opzione <code>-v</code>, le informazioni visualizzate saranno più verbose in modo che possiate vedere esattamente cosa succede quando ogni test viene eseguito. Con ogni probabilità, il risultato della vostra esecuzione dovrebbe somigliare a questo:
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest1.py -v</kbd>
<samp><a>to_roman should give known result with known input ... FAIL            <span class=u>&#x2460;</span></a>

======================================================================
FAIL: to_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest1.py", line 73, in test_to_roman_known_values
    self.assertEqual(numeral, result)
<a>AssertionError: 'I' != None                                            <span class=u>&#x2461;</span></a>

----------------------------------------------------------------------
<a>Ran 1 test in 0.016s                                                   <span class=u>&#x2462;</span></a>

<a>FAILED (failures=1)                                                    <span class=u>&#x2463;</span></a></samp></pre>
<ol>
<li>Lanciare lo script esegue <code>unittest.main()</code> che a sua volta esegue tutti i test. Ogni test è un metodo all'interno di ogni classe in <code>romantest.py</code> che erediti da <code>unittest.TestCase</code>. Per ogni test, il modulo <code>unittest</code> mostrerà la <code>docstring</code> del metodo e un risultato di successo o fallimento per quel test. Come ci aspettavamo, questo test fallisce.
<li>Per ogni test fallito, <code>unittest</code> visualizzerà le informazioni della traccia dello stack di esecuzione che mostrano esattamente cos'è successo. In questo caso, la chiamata ad <code>assertEqual()</code> ha sollevato una eccezione di tipo <code>AssertionError</code> perché si aspettava che <code>to_roman(1)</code> restituisse <code>'I'</code>, ma non lo ha fatto. (Dato che non c'era nessuna istruzione esplicita di <code>return</code>, la funzione ha restituito <code>None</code>, il valore nullo di Python.)
<li>Dopo i dettagli di ogni test, <code>unittest</code> visualizza un riepilogo di quanti test sono stati eseguiti e quanto tempo hanno impiegato.
<li>Nell'insieme, il collaudo di unità è fallito perché almeno un test non è passato. Quando un test non passa, <code>unittest</code> distingue tra fallimenti ed errori. Un fallimento corrisponde alla chiamata a un metodo di asserzione, come <code>assertEqual()</code> o <code>assertRaises()</code>, che fallisce perché la condizione asserita non è vera o l'eccezione attesa non è stata sollevata. Un errore corrisponde a qualsiasi altro tipo di eccezione sollevata dal codice che state collaudando o dal test di unità stesso.
</ol>
<p><em>Ora</em>, finalmente, potete scrivere la funzione <code>to_roman()</code>.
<p class=d>[<a href=esempi/roman1.py>scarica <code>roman1.py</code></a>]
<pre><code class=pp>roman_numeral_map = (('M',  1000),
                     ('CM', 900),
                     ('D',  500),
                     ('CD', 400),
                     ('C',  100),
                     ('XC', 90),
                     ('L',  50),
                     ('XL', 40),
                     ('X',  10),
                     ('IX', 9),
                     ('V',  5),
                     ('IV', 4),
<a>                     ('I',  1))                 <span class=u>&#x2460;</span></a>

def to_roman(n):
    '''convert integer to Roman numeral'''
    result = ''
    for numeral, integer in roman_numeral_map:
<a>        while n >= integer:                     <span class=u>&#x2461;</span></a>
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li><var>roman_numeral_map</var> è una tupla di tuple che definisce tre cose: la rappresentazione a caratteri dei numeri romani di base; l'ordine dei numeri romani (discendente secondo il valore, da <code>M</code> fino a <code>I</code>); il valore di ogni numero romano. Ogni tupla interna rappresenta una coppia <code>(<var>numero</var>, <var>valore</var>)</code>. Non ci sono solo i numeri romani con un singolo carattere; sono definite anche coppie di due caratteri come <code>CM</code> (&#8220;un centinaio meno un migliaio&#8221;). Questo rende più semplice il codice della funzione <code>to_roman()</code>.
<li>Ed ecco dove la ricca struttura dati di <var>roman_numeral_map</var> vi ricompensa, perché non avete bisogno di alcuna logica speciale per gestire la regola di sottrazione. Per convertire verso i numeri romani, dovete semplicemente iterare attraverso <var>roman_numeral_map</var> cercando il più grande valore intero minore o uguale al numero in ingresso. Una volta trovato, aggiungete la rappresentazione del numero romano alla fine del risultato, sottraete il corrispondente valore intero dal numero in ingresso, insaponate, sciacquate, ripetete.
</ol>
<p>Se non vi è ancora chiaro come la funzione <code>to_roman()</code> lavora, aggiungete una chiamata a <code>print()</code> alla fine del ciclo <code>while</code>:
<pre><code class=pp>
while n >= integer:
    result += numeral
    n -= integer
    print('subtracting {0} from input, adding {1} to output'.format(integer, numeral))</code></pre>
<p>Con l'istruzione <code>print()</code> di debug, il risultato somiglia al seguente:
<pre class=screen>
<samp class=p>>>> </samp><kbd>import roman1</kbd>
<samp class=p>>>> </samp><kbd>roman1.to_roman(1424)</kbd>
<samp>subtracting 1000 from input, adding M to output
subtracting 400 from input, adding CD to output
subtracting 10 from input, adding X to output
subtracting 10 from input, adding X to output
subtracting 4 from input, adding IV to output
'MCDXXIV'</samp></pre>
<p>Quindi la funzione <code>to_roman()</code> sembra funzionare, almeno in questo controllo manuale. Ma passerà il test che avete scritto?
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest1.py -v</kbd>
<samp>to_roman should give known result with known input ... ok

----------------------------------------------------------------------
Ran 1 test in 0.016s

OK</samp></pre>
<ol>
<li>Urrà! La funzione <code>to_roman()</code> passa il test per i &#8220;valori noti.&#8221; Certo il test non è completo, ma mette alla prova la funzione con una varietà di ingressi, compresi interi che producono ogni numero romano con un singolo carattere, l'intero più grande possibile (<code>3999</code>), e l'intero che produce il numero romano più lungo (<code>3888</code>). A questo punto, potete essere ragionevolmente fiduciosi che la funzione funzioni per ogni ingresso valido che possiate darle.
</ol>
<p>Ingresso &#8220;valido&#8221;? Hmm. E se l'ingresso non fosse valido?

<p class=a>&#x2042;

<h2 id=romantest2>&#8220;Fermati e prendi fuoco&#8221;</h2>
<aside>Il modo che ha Python di fermarsi e prendere fuoco è sollevare una eccezione.</aside>
<p>Non è sufficiente verificare che una funzione abbia successo quando le viene dato un ingresso valido; dovete anche verificare che fallisca quando le viene dato un ingresso non valido. E non un qualsiasi tipo di fallimento; la funzione deve fallire nel modo che vi aspettate.
<pre class=screen>
<samp class=p>>>> </samp><kbd>import roman1</kbd>
<samp class=p>>>> </samp><kbd>roman1.to_roman(4000)</kbd>
<samp>'MMMM'</samp>
<samp class=p>>>> </samp><kbd>roman1.to_roman(5000)</kbd>
<samp>'MMMMM'</samp>
<a><samp class=p>>>> </samp><kbd>roman1.to_roman(9000)</kbd>  <span class=u>&#x2460;</span></a>
<samp>'MMMMMMMMM'</samp></pre>
<ol>
<li>Questo non è assolutamente quello che volete &mdash; quello non è nemmeno un numero romano valido! In effetti, ognuno di questi numeri è fuori dall'intervallo degli ingressi accettabili, ma la funzione restituisce comunque un finto valore. Restituire silenziosamente valori sbagliati è <em>maaaaaaale</em>; se un programma deve fallire, è molto meglio che fallisca velocemente e rumorosamente. &#8220;Fermati e prendi fuoco,&#8221; come si dice in gergo. Il modo che ha Python di fermarsi e prendere fuoco è sollevare una eccezione.
</ol>
<p>La domanda da porsi è: &#8220;Come posso esprimere questa idea sotto forma di un requisito collaudabile?&#8221; Che ne dite di questo, per cominciare:
<blockquote>
<p>La funzione <code>to_roman()</code> dovrebbe sollevare una eccezione di tipo <code>OutOfRangeError</code> quando le viene passato un intero più grande di <code>3999</code>.
</blockquote>
<p>Che aspetto potrebbe avere il test?
<p class=d>[<a href=esempi/romantest2.py>scarica <code>romantest2.py</code></a>]
<pre><code class=pp><a>class ToRomanBadInput(unittest.TestCase):                                 <span class=u>&#x2460;</span></a>
<a>    def test_too_large(self):                                             <span class=u>&#x2461;</span></a>
        '''to_roman should fail with large input'''
<a>        self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)  <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>Come nel test precedente, create una classe che eredita da <code>unittest.TestCase</code>. Potete avere più di un test per classe (come vedrete più avanti in questo capitolo), ma in questo caso ho scelto di creare una nuova classe perché questo collaudo è qualcosa di diverso rispetto al precedente. Raggrupperemo tutti i collaudi sugli ingressi validi in una classe, e tutti i collaudi sugli ingressi non validi in un'altra.
<li>Come nel test precedente, il test vero e proprio è un metodo della classe, con un nome che comincia con <code>test</code>.
<li>La classe <code>unittest.TestCase</code> fornisce il metodo <code>assertRaises()</code>, che prende i seguenti argomenti: l'eccezione che vi aspettate, la funzione che state collaudando, e gli argomenti che volete passare a quella funzione. (Se la funzione che state collaudando prende più di un argomento, passateli tutti ad <code>assertRaises()</code>, in ordine, ed essi verranno passati direttamente alla funzione che state collaudando.)
</ol>
<p>Fate molta attenzione a quest'ultima riga di codice. Invece di invocare direttamente <code>to_roman()</code> e controllare manualmente che sollevi una particolare eccezione (incorporando la chiamata di funzione in un blocco <code>try...except</code> <span class=fixme>[FIXME xref]</span>), state utilizzando il metodo <code>assertRaises()</code>, che ha incapsulato per noi tutte queste operazioni. Tutto quello che dovete fare è dirgli quali sono l'eccezione che vi aspettate (<code>roman2.OutOfRangeError</code>), la funzione da invocare (<code>to_roman()</code>) e gli argomenti con cui invocarla (<code>4000</code>). Il metodo <code>assertRaises()</code> si prende cura di chiamare <code>to_roman()</code> e controllare che sollevi <code>roman2.OutOfRangeError</code>.
<p>Notate anche che state passando la funzione <code>to_roman()</code> stessa come un argomento; non la state invocando e non ne state passando il nome sotto forma di stringa. Ho recentemente menzionato quant'è comodo che <a href=il-vostro-primo-programma-python.html#everythingisanobject>ogni cosa in Python sia un oggetto</a>?
<p>Quindi cosa succede quando lanciate la <span class=wtf>test suite</span> con questo nuovo test?
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
<a>to_roman should fail with large input ... ERROR                         <span class=u>&#x2460;</span></a>

======================================================================
ERROR: to_roman should fail with large input                          
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest2.py", line 78, in test_too_large
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
<a>AttributeError: 'module' object has no attribute 'OutOfRangeError'      <span class=u>&#x2461;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.000s

FAILED (errors=1)</samp></pre>
<ol>
<li>Avreste dovuto aspettarvi che questo test fallisse (dato che non avete scritto ancora il codice per farlo passare) ma&hellip; non è esattamente &#8220;fallito,&#8221; bensì c'è stato un &#8220;errore.&#8221; Questa è una distinzione sottile ma importante. Un test di unità ha effettivamente <em>tre</em> valori di ritorno: successo, fallimento, ed errore. Successo, ovviamente, significa che il test è passato &mdash; il codice ha fatto quello che vi aspettavate. &#8220;Fallimento&#8221; è il risultato del test precedente (fino a quando non avete scritto il codice per farlo passare) &mdash; il codice veniva eseguito ma il risultato non era quello che vi aspettavate. &#8220;Errore&#8221; significa che il codice non è nemmeno stato eseguito correttamente.
<li>Perché il codice non è stato eseguito correttamente? La traccia dello stack di esecuzione ci fornisce la risposta: il modulo che state collaudando non include alcuna eccezione chiamata <code>OutOfRangeError</code>. Ricordate, avete passato questa eccezione al metodo <code>assertRaises()</code>, perché è l'eccezione che volete che la funzione sollevi quando riceve un ingresso fuori dall'intervallo consentito. Ma l'eccezione non esiste, quindi la chiamata al metodo <code>assertRaises()</code> fallisce. Il metodo non ha avuto la possibilità di collaudare la funzione <code>to_roman()</code>; non è arrivato così lontano.
</ol>
<p>Per risolvere questo problema, dovete definire l'eccezione <code>OutOfRangeError</code> in <code>roman2.py</code>.
<pre><code class=pp><a>class OutOfRangeError(ValueError):  <span class=u>&#x2460;</span></a>
<a>    pass                            <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Le eccezioni sono classi. Un errore di tipo &#8220;out of range&#8221; è un tipo di errore sui valori &mdash; il valore passato come argomento è fuori dal suo intervallo accettabile. Così questa eccezione eredita dalla eccezione built-in <code>ValueError</code>. Questo non è strettamente necessario (avrebbe potuto semplicemente ereditare dalla classe base <code>Exception</code>), ma suona corretto.
<li>Le eccezioni non fanno effettivamente niente, ma avete bisogno di almeno una riga di codice per costruire una classe. L'istruzione <code>pass</code> non fa precisamente nulla, ma è una riga di codice Python, e quindi costituisce una classe.
</ol>
<p>Ora lanciate nuovamente la <span class=wtf>test suite</span>.
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
<a>to_roman should fail with large input ... FAIL                          <span class=u>&#x2460;</span></a>

======================================================================
FAIL: to_roman should fail with large input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest2.py", line 78, in test_too_large
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
<a>AssertionError: OutOfRangeError not raised by to_roman                 <span class=u>&#x2461;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.016s

FAILED (failures=1)</samp></pre>
<ol>
<li>Il nuovo test non è ancora passato, ma non restituisce nemmeno un errore. Invece, il test fallisce. Questo è progresso! Significa che la chiamata al metodo <code>assertRaises()</code> questa volta ha avuto successo, e che il framework per il collaudo di unità ha effettivamente collaudato la funzione <code>to_roman()</code>.
<li>Naturalmente, la funzione <code>to_roman()</code> non ha sollevato l'eccezione <code>OutOfRangeError</code> che avete appena definito, perché non gli avete ancora detto di farlo. Questa è una notizia eccellente! Significa che questo è un test valido &mdash; fallisce prima che scriviate il codice per farlo passare.
</ol>
<p>Ora potete scrivere il codice per far passare questo test.
<p class=d>[<a href=esempi/roman2.py>scarica <code>roman2.py</code></a>]
<pre><code class=pp>def to_roman(n):
    '''convert integer to Roman numeral'''
    if n > 3999:
<a>        raise OutOfRangeError('number out of range (must be less than 3999)')  <span class=u>&#x2460;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Questo è semplice: se l'ingresso dato (<var>n</var>) è più grande di <code>3999</code>, allora solleva una eccezione di tipo <code>OutOfRangeError</code>. Il test di unità non controlla il messaggio nella stringa che accompagna l'eccezione, sebbene possiate scrivere un altro test che faccia questo controllo (ma fate attenzione ai problemi di internazionalizzazione per stringhe che variano con l'ambiente o la lingua dell'utente).
</ol>
<p>Questo fa passare il test? Scopriamolo.
<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
<a>to_roman should fail with large input ... ok                            <span class=u>&#x2460;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</samp></pre>
<ol>
<li>Urrà! Entrambi i test passano. Dato che avete lavorato iterativamente, spostandovi avanti e indietro tra i test e il codice, potete essere sicuri che le due righe di codice che avete scritto sono la causa del passaggio di quel test dal &#8220;fallimento&#8221; al &#8220;successo.&#8221; Questo tipo di confidenza si guadagna a un certo prezzo, ma si ripagherà da sola durante la vita del vostro codice.
</ol>

<p class=a>&#x2042;

<h2 id=romantest3>Più fermate, più fuoco</h2>

<p>Insieme al collaudo per numeri troppo grandi, avete anche bisogno di collaudare numeri che siano troppo piccoli. Come <a href=#divingin>abbiamo notato nei nostri requisiti funzionali</a>, i numeri romani non posso esprimere lo <code>0</code> o i numeri negativi.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import roman2</kbd>
<samp class=p>>>> </samp><kbd>roman2.to_roman(0)</kbd>
<samp>''</samp>
<samp class=p>>>> </samp><kbd>roman2.to_roman(-1)</kbd>
<samp>''</samp></pre>

<p><em>Questo</em> non va bene. Aggiungiamo dei test per ognuna di queste condizioni.

<p class=d>[<a href=esempi/romantest3.py>scarica <code>romantest3.py</code></a>]
<pre><code class=pp>class ToRomanBadInput(unittest.TestCase):
    def test_too_large(self):
        '''to_roman should fail with large input'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 4000)  <span class=u>&#x2460;</span></a>

    def test_zero(self):
        '''to_roman should fail with 0 input'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)     <span class=u>&#x2461;</span></a>

    def test_negative(self):
        '''to_roman should fail with negative input'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)    <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>Il metodo <code>test_too_large()</code> non è cambiato rispetto al passo precedente. Lo includo qui per mostrare dove trova posto il nuovo codice.
<li>Ecco un nuovo test: il metodo <code>test_zero()</code>. Come il metodo <code>test_too_large()</code>, dice al metodo <code>assertRaises()</code> definito in <code>unittest.TestCase</code> di chiamare la nostra funzione <code>to_roman()</code> con un parametro di <code>0</code>, e verificare che sollevi l'eccezione appropriata, <code>OutOfRangeError</code>.
<li>Il metodo <code>test_negative()</code> è quasi identico, se non che passa <code>-1</code> alla funzione <code>to_roman()</code>. Se uno di questi nuovi test <em>non</em> solleva una eccezione di tipo <code>OutOfRangeError</code> (perché la funzione restituisce un valore, o perché solleva qualche altra eccezione), il collaudo si considera fallito.
</ol>

<p>Ora verifichiamo che i test falliscano:

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest3.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
to_roman should fail with negative input ... FAIL
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... FAIL

======================================================================
FAIL: to_roman should fail with negative input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest3.py", line 86, in test_negative
    self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)
AssertionError: OutOfRangeError not raised by to_roman

======================================================================
FAIL: to_roman should fail with 0 input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest3.py", line 82, in test_zero
    self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)
AssertionError: OutOfRangeError not raised by to_roman

----------------------------------------------------------------------
Ran 4 tests in 0.000s

FAILED (failures=2)</samp></pre>

<p>Eccellente. Entrambi i test falliscono, come era da aspettarsi. Ora passiamo al codice e vediamo cosa possiamo fare per farli passare.

<p class=d>[<a href=esempi/roman3.py>scarica <code>roman3.py</code></a>]
<pre><code class=pp>def to_roman(n):
    '''convert integer to Roman numeral'''
<a>    if not (0 < n < 4000):                                              <span class=u>&#x2460;</span></a>
<a>        raise OutOfRangeError('number out of range (must be 0..3999)')  <span class=u>&#x2461;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Questa è una classica scorciatoia di Python: confronti multipli allo stesso tempo. Questo codice è equivalente a <code>if not ((0 &lt; n) and (n &lt; 4000))</code>, ma è molto più facile da leggere. Questa riga di codice dovrebbe catturare gli ingressi che sono troppo grandi, negativi, o zero.
<li>Se cambiate le vostre condizioni, assicuratevi di aggiornare i vostri messaggi in modo che riflettano i cambiamenti. Il framework <code>unittest</code> non se ne curerà, ma sarebbe difficile effettuare un controllo manuale se il vostro codice lanciasse eccezioni non correttamente descritte.
</ol>

<p>Potrei fornirvi un'intera serie di esempi non correlati che mostrano che la scorciatoia dei confronti multipli allo stesso tempo funziona, ma invece eseguirò semplicemente i test di unità e lo dimostrerò.

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest3.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.016s

OK</samp></pre>

<p class=a>&#x2042;

<h2 id=romantest4>E ancora una cosa&hellip;</h2>

<p>C'era ancora un <a href=#divingin>requisito funzionale</a> per la conversione dei numeri in numeri romani: gestire i numeri non interi.

<pre class=screen>
<samp class=p>>>> </samp><kbd>import roman3</kbd>
<a><samp class=p>>>> </samp><kbd>roman3.to_roman(0.5)</kbd>  <span class=u>&#x2460;</span></a>
<samp>''</samp>
<a><samp class=p>>>> </samp><kbd>roman3.to_roman(1.5)</kbd>  <span class=u>&#x2461;</span></a>
<samp>'I'</samp></pre>
<ol>
<li>Oh, questo non va bene.
<li>Oh, questo è ancora peggio. Entrambi i casi dovrebbero sollevare una eccezione. Invece, danno risultati fasulli.
</ol>

<p>Fare il collaudo per i numeri non interi non è difficile. Prima di tutto, definite una eccezione chiamata <code>NonIntegerError</code>.

<pre><code class=pp># roman4.py
class OutOfRangeError(ValueError): pass
<mark>class NotIntegerError(ValueError): pass</mark></code></pre>

<p>Poi, scrivete un test che verifichi la generazione dell'eccezione <code>NonIntegerError</code>.

<pre><code class=pp>class ToRomanBadInput(unittest.TestCase):
    .
    .
    .
    def test_non_integer(self):
        '''to_roman should fail with non-integer input'''
<mark>        self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)</mark></code></pre>

<p>Ora contollate che il test fallisca in maniera appropriata.

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest4.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... FAIL
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

======================================================================
FAIL: to_roman should fail with non-integer input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest4.py", line 90, in test_non_integer
    self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)
<mark>AssertionError: NotIntegerError not raised by to_roman</mark>

----------------------------------------------------------------------
Ran 5 tests in 0.000s

FAILED (failures=1)</samp></pre>

<p>Scrivete il codice che fa passare il test.

<pre><code class=pp>def to_roman(n):
    '''convert integer to Roman numeral'''
    if not (0 < n < 4000):
        raise OutOfRangeError('number out of range (must be 0..3999)')
<a>    if not isinstance(n, int):                                          <span class=u>&#x2460;</span></a>
<a>        raise NotIntegerError('non-integers can not be converted')      <span class=u>&#x2461;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>La funzione built-in <code>isinstance()</code> verifica che una variabile sia di un particolare tipo (o, tecnicamente, di un qualsiasi tipo discendente).
<li>Se l'argomento <var>n</var> non è un <code>int</code>, sollevate la nostra eccezione <code>NotIntegerError</code> appena coniata.
</ol>

<p>Infine, controllate che il codice faccia effettivamente passare il test.

<pre class=screen>
<samp class=p>you@localhost:~$ </samp><kbd>python3 romantest4.py -v</kbd>
<samp>to_roman should give known result with known input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK</samp></pre>

<p>Ora potete smettere di programmare.

<p class=v><a rel=prev class=todo><span class=u>&#x261C;</span></a> <a rel=next class=todo><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;9 <a href=informazioni-sul-libro.html>Mark Pilgrim</a><br>
&copy; 2009 <a href=informazioni-sulla-traduzione.html>Giulio Piancastelli</a> per la traduzione italiana
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
